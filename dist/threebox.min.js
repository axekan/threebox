var Ht=(l,_)=>()=>(_||l((_={exports:{}}).exports,_),_.exports);var mn=Ht((qa,Pu)=>{(function(l,_){typeof qa=="object"&&typeof Pu<"u"?_(qa):typeof define=="function"&&define.amd?define(["exports"],_):_((l=typeof globalThis<"u"?globalThis:l||self).THREE={})})(qa,function(l){"use strict";let _="132",re="300 es";class Me{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});let n=this._listeners;n[e]===void 0&&(n[e]=[]),n[e].indexOf(t)===-1&&n[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;let n=this._listeners;return n[e]!==void 0&&n[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;let n=this._listeners[e];if(n!==void 0){let i=n.indexOf(t);i!==-1&&n.splice(i,1)}}dispatchEvent(e){if(this._listeners===void 0)return;let t=this._listeners[e.type];if(t!==void 0){e.target=this;let n=t.slice(0);for(let i=0,r=n.length;i<r;i++)n[i].call(this,e);e.target=null}}}let fe=[];for(let s=0;s<256;s++)fe[s]=(s<16?"0":"")+s.toString(16);let je=1234567,rt=Math.PI/180,Et=180/Math.PI;function nt(){let s=4294967295*Math.random()|0,e=4294967295*Math.random()|0,t=4294967295*Math.random()|0,n=4294967295*Math.random()|0;return(fe[255&s]+fe[s>>8&255]+fe[s>>16&255]+fe[s>>24&255]+"-"+fe[255&e]+fe[e>>8&255]+"-"+fe[e>>16&15|64]+fe[e>>24&255]+"-"+fe[63&t|128]+fe[t>>8&255]+"-"+fe[t>>16&255]+fe[t>>24&255]+fe[255&n]+fe[n>>8&255]+fe[n>>16&255]+fe[n>>24&255]).toUpperCase()}function Ke(s,e,t){return Math.max(e,Math.min(t,s))}function at(s,e){return(s%e+e)%e}function Wt(s,e,t){return(1-t)*s+t*e}function Dt(s){return(s&s-1)==0&&s!==0}function kn(s){return Math.pow(2,Math.ceil(Math.log(s)/Math.LN2))}function ti(s){return Math.pow(2,Math.floor(Math.log(s)/Math.LN2))}var Ln=Object.freeze({__proto__:null,DEG2RAD:rt,RAD2DEG:Et,generateUUID:nt,clamp:Ke,euclideanModulo:at,mapLinear:function(s,e,t,n,i){return n+(s-e)*(i-n)/(t-e)},inverseLerp:function(s,e,t){return s!==e?(t-s)/(e-s):0},lerp:Wt,damp:function(s,e,t,n){return Wt(s,e,1-Math.exp(-t*n))},pingpong:function(s,e=1){return e-Math.abs(at(s,2*e)-e)},smoothstep:function(s,e,t){return s<=e?0:s>=t?1:(s=(s-e)/(t-e))*s*(3-2*s)},smootherstep:function(s,e,t){return s<=e?0:s>=t?1:(s=(s-e)/(t-e))*s*s*(s*(6*s-15)+10)},randInt:function(s,e){return s+Math.floor(Math.random()*(e-s+1))},randFloat:function(s,e){return s+Math.random()*(e-s)},randFloatSpread:function(s){return s*(.5-Math.random())},seededRandom:function(s){return s!==void 0&&(je=s%2147483647),je=16807*je%2147483647,(je-1)/2147483646},degToRad:function(s){return s*rt},radToDeg:function(s){return s*Et},isPowerOfTwo:Dt,ceilPowerOfTwo:kn,floorPowerOfTwo:ti,setQuaternionFromProperEuler:function(s,e,t,n,i){let r=Math.cos,a=Math.sin,c=r(t/2),h=a(t/2),u=r((e+n)/2),d=a((e+n)/2),p=r((e-n)/2),f=a((e-n)/2),m=r((n-e)/2),g=a((n-e)/2);switch(i){case"XYX":s.set(c*d,h*p,h*f,c*u);break;case"YZY":s.set(h*f,c*d,h*p,c*u);break;case"ZXZ":s.set(h*p,h*f,c*d,c*u);break;case"XZX":s.set(c*d,h*g,h*m,c*u);break;case"YXY":s.set(h*m,c*d,h*g,c*u);break;case"ZYZ":s.set(h*g,h*m,c*d,c*u);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}}});class me{constructor(e=0,t=0){this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this)}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this)}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){let t=this.x,n=this.y,i=e.elements;return this.x=i[0]*t+i[3]*n+i[6],this.y=i[1]*t+i[4]*n+i[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){let n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){let t=this.x-e.x,n=this.y-e.y;return t*t+n*n}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t,n){return n!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){let n=Math.cos(t),i=Math.sin(t),r=this.x-e.x,a=this.y-e.y;return this.x=r*n-a*i+e.x,this.y=r*i+a*n+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}}me.prototype.isVector2=!0;class Nt{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(e,t,n,i,r,a,c,h,u){let d=this.elements;return d[0]=e,d[1]=i,d[2]=c,d[3]=t,d[4]=r,d[5]=h,d[6]=n,d[7]=a,d[8]=u,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){let t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],this}extractBasis(e,t,n){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(e){let t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){let n=e.elements,i=t.elements,r=this.elements,a=n[0],c=n[3],h=n[6],u=n[1],d=n[4],p=n[7],f=n[2],m=n[5],g=n[8],y=i[0],x=i[3],v=i[6],w=i[1],A=i[4],S=i[7],D=i[2],F=i[5],q=i[8];return r[0]=a*y+c*w+h*D,r[3]=a*x+c*A+h*F,r[6]=a*v+c*S+h*q,r[1]=u*y+d*w+p*D,r[4]=u*x+d*A+p*F,r[7]=u*v+d*S+p*q,r[2]=f*y+m*w+g*D,r[5]=f*x+m*A+g*F,r[8]=f*v+m*S+g*q,this}multiplyScalar(e){let t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){let e=this.elements,t=e[0],n=e[1],i=e[2],r=e[3],a=e[4],c=e[5],h=e[6],u=e[7],d=e[8];return t*a*d-t*c*u-n*r*d+n*c*h+i*r*u-i*a*h}invert(){let e=this.elements,t=e[0],n=e[1],i=e[2],r=e[3],a=e[4],c=e[5],h=e[6],u=e[7],d=e[8],p=d*a-c*u,f=c*h-d*r,m=u*r-a*h,g=t*p+n*f+i*m;if(g===0)return this.set(0,0,0,0,0,0,0,0,0);let y=1/g;return e[0]=p*y,e[1]=(i*u-d*n)*y,e[2]=(c*n-i*a)*y,e[3]=f*y,e[4]=(d*t-i*h)*y,e[5]=(i*r-c*t)*y,e[6]=m*y,e[7]=(n*h-u*t)*y,e[8]=(a*t-n*r)*y,this}transpose(){let e,t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){let t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,n,i,r,a,c){let h=Math.cos(r),u=Math.sin(r);return this.set(n*h,n*u,-n*(h*a+u*c)+a+e,-i*u,i*h,-i*(-u*a+h*c)+c+t,0,0,1),this}scale(e,t){let n=this.elements;return n[0]*=e,n[3]*=e,n[6]*=e,n[1]*=t,n[4]*=t,n[7]*=t,this}rotate(e){let t=Math.cos(e),n=Math.sin(e),i=this.elements,r=i[0],a=i[3],c=i[6],h=i[1],u=i[4],d=i[7];return i[0]=t*r+n*h,i[3]=t*a+n*u,i[6]=t*c+n*d,i[1]=-n*r+t*h,i[4]=-n*a+t*u,i[7]=-n*c+t*d,this}translate(e,t){let n=this.elements;return n[0]+=e*n[2],n[3]+=e*n[5],n[6]+=e*n[8],n[1]+=t*n[2],n[4]+=t*n[5],n[7]+=t*n[8],this}equals(e){let t=this.elements,n=e.elements;for(let i=0;i<9;i++)if(t[i]!==n[i])return!1;return!0}fromArray(e,t=0){for(let n=0;n<9;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){let n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e}clone(){return new this.constructor().fromArray(this.elements)}}let Rn;Nt.prototype.isMatrix3=!0;class ui{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{Rn===void 0&&(Rn=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),Rn.width=e.width,Rn.height=e.height;let n=Rn.getContext("2d");e instanceof ImageData?n.putImageData(e,0,0):n.drawImage(e,0,0,e.width,e.height),t=Rn}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}}let gr=0;class zt extends Me{constructor(e=zt.DEFAULT_IMAGE,t=zt.DEFAULT_MAPPING,n=1001,i=1001,r=1006,a=1008,c=1023,h=1009,u=1,d=3e3){super(),Object.defineProperty(this,"id",{value:gr++}),this.uuid=nt(),this.name="",this.image=e,this.mipmaps=[],this.mapping=t,this.wrapS=n,this.wrapT=i,this.magFilter=r,this.minFilter=a,this.anisotropy=u,this.format=c,this.internalFormat=null,this.type=h,this.offset=new me(0,0),this.repeat=new me(1,1),this.center=new me(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Nt,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=d,this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.image=e.image,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.encoding=e.encoding,this}toJSON(e){let t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];let n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(this.image!==void 0){let i=this.image;if(i.uuid===void 0&&(i.uuid=nt()),!t&&e.images[i.uuid]===void 0){let r;if(Array.isArray(i)){r=[];for(let a=0,c=i.length;a<c;a++)i[a].isDataTexture?r.push(xn(i[a].image)):r.push(xn(i[a]))}else r=xn(i);e.images[i.uuid]={uuid:i.uuid,url:r}}n.image=i.uuid}return t||(e.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==300)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case 1e3:e.x=e.x-Math.floor(e.x);break;case 1001:e.x=e.x<0?0:1;break;case 1002:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x)}if(e.y<0||e.y>1)switch(this.wrapT){case 1e3:e.y=e.y-Math.floor(e.y);break;case 1001:e.y=e.y<0?0:1;break;case 1002:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y)}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&this.version++}}function xn(s){return typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&s instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&s instanceof ImageBitmap?ui.getDataURL(s):s.data?{data:Array.prototype.slice.call(s.data),width:s.width,height:s.height,type:s.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}zt.DEFAULT_IMAGE=void 0,zt.DEFAULT_MAPPING=300,zt.prototype.isTexture=!0;class _t{constructor(e=0,t=0,n=0,i=1){this.x=e,this.y=t,this.z=n,this.w=i}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,n,i){return this.x=e,this.y=t,this.z=n,this.w=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){let t=this.x,n=this.y,i=this.z,r=this.w,a=e.elements;return this.x=a[0]*t+a[4]*n+a[8]*i+a[12]*r,this.y=a[1]*t+a[5]*n+a[9]*i+a[13]*r,this.z=a[2]*t+a[6]*n+a[10]*i+a[14]*r,this.w=a[3]*t+a[7]*n+a[11]*i+a[15]*r,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);let t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,n,i,r,h=e.elements,u=h[0],d=h[4],p=h[8],f=h[1],m=h[5],g=h[9],y=h[2],x=h[6],v=h[10];if(Math.abs(d-f)<.01&&Math.abs(p-y)<.01&&Math.abs(g-x)<.01){if(Math.abs(d+f)<.1&&Math.abs(p+y)<.1&&Math.abs(g+x)<.1&&Math.abs(u+m+v-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;let A=(u+1)/2,S=(m+1)/2,D=(v+1)/2,F=(d+f)/4,q=(p+y)/4,X=(g+x)/4;return A>S&&A>D?A<.01?(n=0,i=.707106781,r=.707106781):(n=Math.sqrt(A),i=F/n,r=q/n):S>D?S<.01?(n=.707106781,i=0,r=.707106781):(i=Math.sqrt(S),n=F/i,r=X/i):D<.01?(n=.707106781,i=.707106781,r=0):(r=Math.sqrt(D),n=q/r,i=X/r),this.set(n,i,r,t),this}let w=Math.sqrt((x-g)*(x-g)+(p-y)*(p-y)+(f-d)*(f-d));return Math.abs(w)<.001&&(w=1),this.x=(x-g)/w,this.y=(p-y)/w,this.z=(f-d)/w,this.w=Math.acos((u+m+v-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){let n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this.w=e.w+(t.w-e.w)*n,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t,n){return n!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}}_t.prototype.isVector4=!0;class $t extends Me{constructor(e,t,n={}){super(),this.width=e,this.height=t,this.depth=1,this.scissor=new _t(0,0,e,t),this.scissorTest=!1,this.viewport=new _t(0,0,e,t),this.texture=new zt(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.isRenderTargetTexture=!0,this.texture.image={width:e,height:t,depth:1},this.texture.generateMipmaps=n.generateMipmaps!==void 0&&n.generateMipmaps,this.texture.internalFormat=n.internalFormat!==void 0?n.internalFormat:null,this.texture.minFilter=n.minFilter!==void 0?n.minFilter:1006,this.depthBuffer=n.depthBuffer===void 0||n.depthBuffer,this.stencilBuffer=n.stencilBuffer!==void 0&&n.stencilBuffer,this.depthTexture=n.depthTexture!==void 0?n.depthTexture:null}setTexture(e){e.image={width:this.width,height:this.height,depth:this.depth},this.texture=e}setSize(e,t,n=1){this.width===e&&this.height===t&&this.depth===n||(this.width=e,this.height=t,this.depth=n,this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.texture.image={...this.texture.image},this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.depthTexture=e.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}$t.prototype.isWebGLRenderTarget=!0;class Qr extends $t{constructor(e,t,n){super(e,t);let i=this.texture;this.texture=[];for(let r=0;r<n;r++)this.texture[r]=i.clone()}setSize(e,t,n=1){if(this.width!==e||this.height!==t||this.depth!==n){this.width=e,this.height=t,this.depth=n;for(let i=0,r=this.texture.length;i<r;i++)this.texture[i].image.width=e,this.texture[i].image.height=t,this.texture[i].image.depth=n;this.dispose()}return this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t),this}copy(e){this.dispose(),this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.depthTexture=e.depthTexture,this.texture.length=0;for(let t=0,n=e.texture.length;t<n;t++)this.texture[t]=e.texture[t].clone();return this}}Qr.prototype.isWebGLMultipleRenderTargets=!0;class $r extends $t{constructor(e,t,n){super(e,t,n),this.samples=4}copy(e){return super.copy.call(this,e),this.samples=e.samples,this}}$r.prototype.isWebGLMultisampleRenderTarget=!0;class tn{constructor(e=0,t=0,n=0,i=1){this._x=e,this._y=t,this._z=n,this._w=i}static slerp(e,t,n,i){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),n.slerpQuaternions(e,t,i)}static slerpFlat(e,t,n,i,r,a,c){let h=n[i+0],u=n[i+1],d=n[i+2],p=n[i+3],f=r[a+0],m=r[a+1],g=r[a+2],y=r[a+3];if(c===0)return e[t+0]=h,e[t+1]=u,e[t+2]=d,void(e[t+3]=p);if(c===1)return e[t+0]=f,e[t+1]=m,e[t+2]=g,void(e[t+3]=y);if(p!==y||h!==f||u!==m||d!==g){let x=1-c,v=h*f+u*m+d*g+p*y,w=v>=0?1:-1,A=1-v*v;if(A>Number.EPSILON){let D=Math.sqrt(A),F=Math.atan2(D,v*w);x=Math.sin(x*F)/D,c=Math.sin(c*F)/D}let S=c*w;if(h=h*x+f*S,u=u*x+m*S,d=d*x+g*S,p=p*x+y*S,x===1-c){let D=1/Math.sqrt(h*h+u*u+d*d+p*p);h*=D,u*=D,d*=D,p*=D}}e[t]=h,e[t+1]=u,e[t+2]=d,e[t+3]=p}static multiplyQuaternionsFlat(e,t,n,i,r,a){let c=n[i],h=n[i+1],u=n[i+2],d=n[i+3],p=r[a],f=r[a+1],m=r[a+2],g=r[a+3];return e[t]=c*g+d*p+h*m-u*f,e[t+1]=h*g+d*f+u*p-c*m,e[t+2]=u*g+d*m+c*f-h*p,e[t+3]=d*g-c*p-h*f-u*m,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,n,i){return this._x=e,this._y=t,this._z=n,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){if(!e||!e.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");let n=e._x,i=e._y,r=e._z,a=e._order,c=Math.cos,h=Math.sin,u=c(n/2),d=c(i/2),p=c(r/2),f=h(n/2),m=h(i/2),g=h(r/2);switch(a){case"XYZ":this._x=f*d*p+u*m*g,this._y=u*m*p-f*d*g,this._z=u*d*g+f*m*p,this._w=u*d*p-f*m*g;break;case"YXZ":this._x=f*d*p+u*m*g,this._y=u*m*p-f*d*g,this._z=u*d*g-f*m*p,this._w=u*d*p+f*m*g;break;case"ZXY":this._x=f*d*p-u*m*g,this._y=u*m*p+f*d*g,this._z=u*d*g+f*m*p,this._w=u*d*p-f*m*g;break;case"ZYX":this._x=f*d*p-u*m*g,this._y=u*m*p+f*d*g,this._z=u*d*g-f*m*p,this._w=u*d*p+f*m*g;break;case"YZX":this._x=f*d*p+u*m*g,this._y=u*m*p+f*d*g,this._z=u*d*g-f*m*p,this._w=u*d*p-f*m*g;break;case"XZY":this._x=f*d*p-u*m*g,this._y=u*m*p-f*d*g,this._z=u*d*g+f*m*p,this._w=u*d*p+f*m*g;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+a)}return t!==!1&&this._onChangeCallback(),this}setFromAxisAngle(e,t){let n=t/2,i=Math.sin(n);return this._x=e.x*i,this._y=e.y*i,this._z=e.z*i,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(e){let t=e.elements,n=t[0],i=t[4],r=t[8],a=t[1],c=t[5],h=t[9],u=t[2],d=t[6],p=t[10],f=n+c+p;if(f>0){let m=.5/Math.sqrt(f+1);this._w=.25/m,this._x=(d-h)*m,this._y=(r-u)*m,this._z=(a-i)*m}else if(n>c&&n>p){let m=2*Math.sqrt(1+n-c-p);this._w=(d-h)/m,this._x=.25*m,this._y=(i+a)/m,this._z=(r+u)/m}else if(c>p){let m=2*Math.sqrt(1+c-n-p);this._w=(r-u)/m,this._x=(i+a)/m,this._y=.25*m,this._z=(h+d)/m}else{let m=2*Math.sqrt(1+p-n-c);this._w=(a-i)/m,this._x=(r+u)/m,this._y=(h+d)/m,this._z=.25*m}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let n=e.dot(t)+1;return n<Number.EPSILON?(n=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=n):(this._x=0,this._y=-e.z,this._z=e.y,this._w=n)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=n),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(Ke(this.dot(e),-1,1)))}rotateTowards(e,t){let n=this.angleTo(e);if(n===0)return this;let i=Math.min(1,t/n);return this.slerp(e,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e,t){return t!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(e,t)):this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){let n=e._x,i=e._y,r=e._z,a=e._w,c=t._x,h=t._y,u=t._z,d=t._w;return this._x=n*d+a*c+i*u-r*h,this._y=i*d+a*h+r*c-n*u,this._z=r*d+a*u+n*h-i*c,this._w=a*d-n*c-i*h-r*u,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);let n=this._x,i=this._y,r=this._z,a=this._w,c=a*e._w+n*e._x+i*e._y+r*e._z;if(c<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,c=-c):this.copy(e),c>=1)return this._w=a,this._x=n,this._y=i,this._z=r,this;let h=1-c*c;if(h<=Number.EPSILON){let m=1-t;return this._w=m*a+t*this._w,this._x=m*n+t*this._x,this._y=m*i+t*this._y,this._z=m*r+t*this._z,this.normalize(),this._onChangeCallback(),this}let u=Math.sqrt(h),d=Math.atan2(u,c),p=Math.sin((1-t)*d)/u,f=Math.sin(t*d)/u;return this._w=a*p+this._w*f,this._x=n*p+this._x*f,this._y=i*p+this._y*f,this._z=r*p+this._z*f,this._onChangeCallback(),this}slerpQuaternions(e,t,n){this.copy(e).slerp(t,n)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}tn.prototype.isQuaternion=!0;class L{constructor(e=0,t=0,n=0){this.x=e,this.y=t,this.z=n}set(e,t,n){return n===void 0&&(n=this.z),this.x=e,this.y=t,this.z=n,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(e,t)):(this.x*=e.x,this.y*=e.y,this.z*=e.z,this)}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return e&&e.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(Gl.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(Gl.setFromAxisAngle(e,t))}applyMatrix3(e){let t=this.x,n=this.y,i=this.z,r=e.elements;return this.x=r[0]*t+r[3]*n+r[6]*i,this.y=r[1]*t+r[4]*n+r[7]*i,this.z=r[2]*t+r[5]*n+r[8]*i,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){let t=this.x,n=this.y,i=this.z,r=e.elements,a=1/(r[3]*t+r[7]*n+r[11]*i+r[15]);return this.x=(r[0]*t+r[4]*n+r[8]*i+r[12])*a,this.y=(r[1]*t+r[5]*n+r[9]*i+r[13])*a,this.z=(r[2]*t+r[6]*n+r[10]*i+r[14])*a,this}applyQuaternion(e){let t=this.x,n=this.y,i=this.z,r=e.x,a=e.y,c=e.z,h=e.w,u=h*t+a*i-c*n,d=h*n+c*t-r*i,p=h*i+r*n-a*t,f=-r*t-a*n-c*i;return this.x=u*h+f*-r+d*-c-p*-a,this.y=d*h+f*-a+p*-r-u*-c,this.z=p*h+f*-c+u*-a-d*-r,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){let t=this.x,n=this.y,i=this.z,r=e.elements;return this.x=r[0]*t+r[4]*n+r[8]*i,this.y=r[1]*t+r[5]*n+r[9]*i,this.z=r[2]*t+r[6]*n+r[10]*i,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){let n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this}cross(e,t){return t!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(e,t)):this.crossVectors(this,e)}crossVectors(e,t){let n=e.x,i=e.y,r=e.z,a=t.x,c=t.y,h=t.z;return this.x=i*h-r*c,this.y=r*a-n*h,this.z=n*c-i*a,this}projectOnVector(e){let t=e.lengthSq();if(t===0)return this.set(0,0,0);let n=e.dot(this)/t;return this.copy(e).multiplyScalar(n)}projectOnPlane(e){return eo.copy(this).projectOnVector(e),this.sub(eo)}reflect(e){return this.sub(eo.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){let t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;let n=this.dot(e)/t;return Math.acos(Ke(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){let t=this.x-e.x,n=this.y-e.y,i=this.z-e.z;return t*t+n*n+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,n){let i=Math.sin(t)*e;return this.x=i*Math.sin(n),this.y=Math.cos(t)*e,this.z=i*Math.cos(n),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,n){return this.x=e*Math.sin(t),this.y=n,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){let t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){let t=this.setFromMatrixColumn(e,0).length(),n=this.setFromMatrixColumn(e,1).length(),i=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=n,this.z=i,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,4*t)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,3*t)}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t,n){return n!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}}L.prototype.isVector3=!0;let eo=new L,Gl=new tn;class Cn{constructor(e=new L(1/0,1/0,1/0),t=new L(-1/0,-1/0,-1/0)){this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){let t=1/0,n=1/0,i=1/0,r=-1/0,a=-1/0,c=-1/0;for(let h=0,u=e.length;h<u;h+=3){let d=e[h],p=e[h+1],f=e[h+2];d<t&&(t=d),p<n&&(n=p),f<i&&(i=f),d>r&&(r=d),p>a&&(a=p),f>c&&(c=f)}return this.min.set(t,n,i),this.max.set(r,a,c),this}setFromBufferAttribute(e){let t=1/0,n=1/0,i=1/0,r=-1/0,a=-1/0,c=-1/0;for(let h=0,u=e.count;h<u;h++){let d=e.getX(h),p=e.getY(h),f=e.getZ(h);d<t&&(t=d),p<n&&(n=p),f<i&&(i=f),d>r&&(r=d),p>a&&(a=p),f>c&&(c=f)}return this.min.set(t,n,i),this.max.set(r,a,c),this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){let n=es.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}setFromObject(e){return this.makeEmpty(),this.expandByObject(e)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e){e.updateWorldMatrix(!1,!1);let t=e.geometry;t!==void 0&&(t.boundingBox===null&&t.computeBoundingBox(),to.copy(t.boundingBox),to.applyMatrix4(e.matrixWorld),this.union(to));let n=e.children;for(let i=0,r=n.length;i<r;i++)this.expandByObject(n[i]);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,es),es.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,n;return e.normal.x>0?(t=e.normal.x*this.min.x,n=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,n=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,n+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,n+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,n+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,n+=e.normal.z*this.min.z),t<=-e.constant&&n>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(ts),Ns.subVectors(this.max,ts),yr.subVectors(e.a,ts),vr.subVectors(e.b,ts),xr.subVectors(e.c,ts),wi.subVectors(vr,yr),Si.subVectors(xr,vr),ki.subVectors(yr,xr);let t=[0,-wi.z,wi.y,0,-Si.z,Si.y,0,-ki.z,ki.y,wi.z,0,-wi.x,Si.z,0,-Si.x,ki.z,0,-ki.x,-wi.y,wi.x,0,-Si.y,Si.x,0,-ki.y,ki.x,0];return!!no(t,yr,vr,xr,Ns)&&(t=[1,0,0,0,1,0,0,0,1],!!no(t,yr,vr,xr,Ns)&&(zs.crossVectors(wi,Si),t=[zs.x,zs.y,zs.z],no(t,yr,vr,xr,Ns)))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return es.copy(e).clamp(this.min,this.max).sub(e).length()}getBoundingSphere(e){return this.getCenter(e.center),e.radius=.5*this.getSize(es).length(),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()||(di[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),di[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),di[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),di[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),di[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),di[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),di[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),di[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(di)),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}Cn.prototype.isBox3=!0;let di=[new L,new L,new L,new L,new L,new L,new L,new L],es=new L,to=new Cn,yr=new L,vr=new L,xr=new L,wi=new L,Si=new L,ki=new L,ts=new L,Ns=new L,zs=new L,Vi=new L;function no(s,e,t,n,i){for(let r=0,a=s.length-3;r<=a;r+=3){Vi.fromArray(s,r);let c=i.x*Math.abs(Vi.x)+i.y*Math.abs(Vi.y)+i.z*Math.abs(Vi.z),h=e.dot(Vi),u=t.dot(Vi),d=n.dot(Vi);if(Math.max(-Math.max(h,u,d),Math.min(h,u,d))>c)return!1}return!0}let Kd=new Cn,kl=new L,io=new L,ro=new L;class Ti{constructor(e=new L,t=-1){this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){let n=this.center;t!==void 0?n.copy(t):Kd.setFromPoints(e).getCenter(n);let i=0;for(let r=0,a=e.length;r<a;r++)i=Math.max(i,n.distanceToSquared(e[r]));return this.radius=Math.sqrt(i),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){let t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){let n=this.center.distanceToSquared(e);return t.copy(e),n>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){ro.subVectors(e,this.center);let t=ro.lengthSq();if(t>this.radius*this.radius){let n=Math.sqrt(t),i=.5*(n-this.radius);this.center.add(ro.multiplyScalar(i/n)),this.radius+=i}return this}union(e){return io.subVectors(e.center,this.center).normalize().multiplyScalar(e.radius),this.expandByPoint(kl.copy(e.center).add(io)),this.expandByPoint(kl.copy(e.center).sub(io)),this}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}let pi=new L,so=new L,Bs=new L,Ei=new L,ao=new L,Hs=new L,oo=new L;class Ai{constructor(e=new L,t=new L(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.direction).multiplyScalar(e).add(this.origin)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,pi)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);let n=t.dot(this.direction);return n<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){let t=pi.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(pi.copy(this.direction).multiplyScalar(t).add(this.origin),pi.distanceToSquared(e))}distanceSqToSegment(e,t,n,i){so.copy(e).add(t).multiplyScalar(.5),Bs.copy(t).sub(e).normalize(),Ei.copy(this.origin).sub(so);let r=.5*e.distanceTo(t),a=-this.direction.dot(Bs),c=Ei.dot(this.direction),h=-Ei.dot(Bs),u=Ei.lengthSq(),d=Math.abs(1-a*a),p,f,m,g;if(d>0)if(p=a*h-c,f=a*c-h,g=r*d,p>=0)if(f>=-g)if(f<=g){let y=1/d;p*=y,f*=y,m=p*(p+a*f+2*c)+f*(a*p+f+2*h)+u}else f=r,p=Math.max(0,-(a*f+c)),m=-p*p+f*(f+2*h)+u;else f=-r,p=Math.max(0,-(a*f+c)),m=-p*p+f*(f+2*h)+u;else f<=-g?(p=Math.max(0,-(-a*r+c)),f=p>0?-r:Math.min(Math.max(-r,-h),r),m=-p*p+f*(f+2*h)+u):f<=g?(p=0,f=Math.min(Math.max(-r,-h),r),m=f*(f+2*h)+u):(p=Math.max(0,-(a*r+c)),f=p>0?r:Math.min(Math.max(-r,-h),r),m=-p*p+f*(f+2*h)+u);else f=a>0?-r:r,p=Math.max(0,-(a*f+c)),m=-p*p+f*(f+2*h)+u;return n&&n.copy(this.direction).multiplyScalar(p).add(this.origin),i&&i.copy(Bs).multiplyScalar(f).add(so),m}intersectSphere(e,t){pi.subVectors(e.center,this.origin);let n=pi.dot(this.direction),i=pi.dot(pi)-n*n,r=e.radius*e.radius;if(i>r)return null;let a=Math.sqrt(r-i),c=n-a,h=n+a;return c<0&&h<0?null:c<0?this.at(h,t):this.at(c,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){let t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;let n=-(this.origin.dot(e.normal)+e.constant)/t;return n>=0?n:null}intersectPlane(e,t){let n=this.distanceToPlane(e);return n===null?null:this.at(n,t)}intersectsPlane(e){let t=e.distanceToPoint(this.origin);return t===0?!0:e.normal.dot(this.direction)*t<0}intersectBox(e,t){let n,i,r,a,c,h,u=1/this.direction.x,d=1/this.direction.y,p=1/this.direction.z,f=this.origin;return u>=0?(n=(e.min.x-f.x)*u,i=(e.max.x-f.x)*u):(n=(e.max.x-f.x)*u,i=(e.min.x-f.x)*u),d>=0?(r=(e.min.y-f.y)*d,a=(e.max.y-f.y)*d):(r=(e.max.y-f.y)*d,a=(e.min.y-f.y)*d),n>a||r>i?null:((r>n||n!=n)&&(n=r),(a<i||i!=i)&&(i=a),p>=0?(c=(e.min.z-f.z)*p,h=(e.max.z-f.z)*p):(c=(e.max.z-f.z)*p,h=(e.min.z-f.z)*p),n>h||c>i?null:((c>n||n!=n)&&(n=c),(h<i||i!=i)&&(i=h),i<0?null:this.at(n>=0?n:i,t)))}intersectsBox(e){return this.intersectBox(e,pi)!==null}intersectTriangle(e,t,n,i,r){ao.subVectors(t,e),Hs.subVectors(n,e),oo.crossVectors(ao,Hs);let a,c=this.direction.dot(oo);if(c>0){if(i)return null;a=1}else{if(!(c<0))return null;a=-1,c=-c}Ei.subVectors(this.origin,e);let h=a*this.direction.dot(Hs.crossVectors(Ei,Hs));if(h<0)return null;let u=a*this.direction.dot(ao.cross(Ei));if(u<0||h+u>c)return null;let d=-a*Ei.dot(oo);return d<0?null:this.at(d/c,r)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class Xe{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(e,t,n,i,r,a,c,h,u,d,p,f,m,g,y,x){let v=this.elements;return v[0]=e,v[4]=t,v[8]=n,v[12]=i,v[1]=r,v[5]=a,v[9]=c,v[13]=h,v[2]=u,v[6]=d,v[10]=p,v[14]=f,v[3]=m,v[7]=g,v[11]=y,v[15]=x,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Xe().fromArray(this.elements)}copy(e){let t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],this}copyPosition(e){let t=this.elements,n=e.elements;return t[12]=n[12],t[13]=n[13],t[14]=n[14],this}setFromMatrix3(e){let t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,n){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(e,t,n){return this.set(e.x,t.x,n.x,0,e.y,t.y,n.y,0,e.z,t.z,n.z,0,0,0,0,1),this}extractRotation(e){let t=this.elements,n=e.elements,i=1/_r.setFromMatrixColumn(e,0).length(),r=1/_r.setFromMatrixColumn(e,1).length(),a=1/_r.setFromMatrixColumn(e,2).length();return t[0]=n[0]*i,t[1]=n[1]*i,t[2]=n[2]*i,t[3]=0,t[4]=n[4]*r,t[5]=n[5]*r,t[6]=n[6]*r,t[7]=0,t[8]=n[8]*a,t[9]=n[9]*a,t[10]=n[10]*a,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){e&&e.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");let t=this.elements,n=e.x,i=e.y,r=e.z,a=Math.cos(n),c=Math.sin(n),h=Math.cos(i),u=Math.sin(i),d=Math.cos(r),p=Math.sin(r);if(e.order==="XYZ"){let f=a*d,m=a*p,g=c*d,y=c*p;t[0]=h*d,t[4]=-h*p,t[8]=u,t[1]=m+g*u,t[5]=f-y*u,t[9]=-c*h,t[2]=y-f*u,t[6]=g+m*u,t[10]=a*h}else if(e.order==="YXZ"){let f=h*d,m=h*p,g=u*d,y=u*p;t[0]=f+y*c,t[4]=g*c-m,t[8]=a*u,t[1]=a*p,t[5]=a*d,t[9]=-c,t[2]=m*c-g,t[6]=y+f*c,t[10]=a*h}else if(e.order==="ZXY"){let f=h*d,m=h*p,g=u*d,y=u*p;t[0]=f-y*c,t[4]=-a*p,t[8]=g+m*c,t[1]=m+g*c,t[5]=a*d,t[9]=y-f*c,t[2]=-a*u,t[6]=c,t[10]=a*h}else if(e.order==="ZYX"){let f=a*d,m=a*p,g=c*d,y=c*p;t[0]=h*d,t[4]=g*u-m,t[8]=f*u+y,t[1]=h*p,t[5]=y*u+f,t[9]=m*u-g,t[2]=-u,t[6]=c*h,t[10]=a*h}else if(e.order==="YZX"){let f=a*h,m=a*u,g=c*h,y=c*u;t[0]=h*d,t[4]=y-f*p,t[8]=g*p+m,t[1]=p,t[5]=a*d,t[9]=-c*d,t[2]=-u*d,t[6]=m*p+g,t[10]=f-y*p}else if(e.order==="XZY"){let f=a*h,m=a*u,g=c*h,y=c*u;t[0]=h*d,t[4]=-p,t[8]=u*d,t[1]=f*p+y,t[5]=a*d,t[9]=m*p-g,t[2]=g*p-m,t[6]=c*d,t[10]=y*p+f}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(Qd,e,$d)}lookAt(e,t,n){let i=this.elements;return Pn.subVectors(e,t),Pn.lengthSq()===0&&(Pn.z=1),Pn.normalize(),Li.crossVectors(n,Pn),Li.lengthSq()===0&&(Math.abs(n.z)===1?Pn.x+=1e-4:Pn.z+=1e-4,Pn.normalize(),Li.crossVectors(n,Pn)),Li.normalize(),Us.crossVectors(Pn,Li),i[0]=Li.x,i[4]=Us.x,i[8]=Pn.x,i[1]=Li.y,i[5]=Us.y,i[9]=Pn.y,i[2]=Li.z,i[6]=Us.z,i[10]=Pn.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(e,t)):this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){let n=e.elements,i=t.elements,r=this.elements,a=n[0],c=n[4],h=n[8],u=n[12],d=n[1],p=n[5],f=n[9],m=n[13],g=n[2],y=n[6],x=n[10],v=n[14],w=n[3],A=n[7],S=n[11],D=n[15],F=i[0],q=i[4],X=i[8],te=i[12],J=i[1],$=i[5],Re=i[9],ye=i[13],ae=i[2],be=i[6],Ce=i[10],Ie=i[14],ke=i[3],$e=i[7],et=i[11],_e=i[15];return r[0]=a*F+c*J+h*ae+u*ke,r[4]=a*q+c*$+h*be+u*$e,r[8]=a*X+c*Re+h*Ce+u*et,r[12]=a*te+c*ye+h*Ie+u*_e,r[1]=d*F+p*J+f*ae+m*ke,r[5]=d*q+p*$+f*be+m*$e,r[9]=d*X+p*Re+f*Ce+m*et,r[13]=d*te+p*ye+f*Ie+m*_e,r[2]=g*F+y*J+x*ae+v*ke,r[6]=g*q+y*$+x*be+v*$e,r[10]=g*X+y*Re+x*Ce+v*et,r[14]=g*te+y*ye+x*Ie+v*_e,r[3]=w*F+A*J+S*ae+D*ke,r[7]=w*q+A*$+S*be+D*$e,r[11]=w*X+A*Re+S*Ce+D*et,r[15]=w*te+A*ye+S*Ie+D*_e,this}multiplyScalar(e){let t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){let e=this.elements,t=e[0],n=e[4],i=e[8],r=e[12],a=e[1],c=e[5],h=e[9],u=e[13],d=e[2],p=e[6],f=e[10],m=e[14];return e[3]*(+r*h*p-i*u*p-r*c*f+n*u*f+i*c*m-n*h*m)+e[7]*(+t*h*m-t*u*f+r*a*f-i*a*m+i*u*d-r*h*d)+e[11]*(+t*u*p-t*c*m-r*a*p+n*a*m+r*c*d-n*u*d)+e[15]*(-i*c*d-t*h*p+t*c*f+i*a*p-n*a*f+n*h*d)}transpose(){let e=this.elements,t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,n){let i=this.elements;return e.isVector3?(i[12]=e.x,i[13]=e.y,i[14]=e.z):(i[12]=e,i[13]=t,i[14]=n),this}invert(){let e=this.elements,t=e[0],n=e[1],i=e[2],r=e[3],a=e[4],c=e[5],h=e[6],u=e[7],d=e[8],p=e[9],f=e[10],m=e[11],g=e[12],y=e[13],x=e[14],v=e[15],w=p*x*u-y*f*u+y*h*m-c*x*m-p*h*v+c*f*v,A=g*f*u-d*x*u-g*h*m+a*x*m+d*h*v-a*f*v,S=d*y*u-g*p*u+g*c*m-a*y*m-d*c*v+a*p*v,D=g*p*h-d*y*h-g*c*f+a*y*f+d*c*x-a*p*x,F=t*w+n*A+i*S+r*D;if(F===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);let q=1/F;return e[0]=w*q,e[1]=(y*f*r-p*x*r-y*i*m+n*x*m+p*i*v-n*f*v)*q,e[2]=(c*x*r-y*h*r+y*i*u-n*x*u-c*i*v+n*h*v)*q,e[3]=(p*h*r-c*f*r-p*i*u+n*f*u+c*i*m-n*h*m)*q,e[4]=A*q,e[5]=(d*x*r-g*f*r+g*i*m-t*x*m-d*i*v+t*f*v)*q,e[6]=(g*h*r-a*x*r-g*i*u+t*x*u+a*i*v-t*h*v)*q,e[7]=(a*f*r-d*h*r+d*i*u-t*f*u-a*i*m+t*h*m)*q,e[8]=S*q,e[9]=(g*p*r-d*y*r-g*n*m+t*y*m+d*n*v-t*p*v)*q,e[10]=(a*y*r-g*c*r+g*n*u-t*y*u-a*n*v+t*c*v)*q,e[11]=(d*c*r-a*p*r-d*n*u+t*p*u+a*n*m-t*c*m)*q,e[12]=D*q,e[13]=(d*y*i-g*p*i+g*n*f-t*y*f-d*n*x+t*p*x)*q,e[14]=(g*c*i-a*y*i-g*n*h+t*y*h+a*n*x-t*c*x)*q,e[15]=(a*p*i-d*c*i+d*n*h-t*p*h-a*n*f+t*c*f)*q,this}scale(e){let t=this.elements,n=e.x,i=e.y,r=e.z;return t[0]*=n,t[4]*=i,t[8]*=r,t[1]*=n,t[5]*=i,t[9]*=r,t[2]*=n,t[6]*=i,t[10]*=r,t[3]*=n,t[7]*=i,t[11]*=r,this}getMaxScaleOnAxis(){let e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],n=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],i=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,n,i))}makeTranslation(e,t,n){return this.set(1,0,0,e,0,1,0,t,0,0,1,n,0,0,0,1),this}makeRotationX(e){let t=Math.cos(e),n=Math.sin(e);return this.set(1,0,0,0,0,t,-n,0,0,n,t,0,0,0,0,1),this}makeRotationY(e){let t=Math.cos(e),n=Math.sin(e);return this.set(t,0,n,0,0,1,0,0,-n,0,t,0,0,0,0,1),this}makeRotationZ(e){let t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,0,n,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){let n=Math.cos(t),i=Math.sin(t),r=1-n,a=e.x,c=e.y,h=e.z,u=r*a,d=r*c;return this.set(u*a+n,u*c-i*h,u*h+i*c,0,u*c+i*h,d*c+n,d*h-i*a,0,u*h-i*c,d*h+i*a,r*h*h+n,0,0,0,0,1),this}makeScale(e,t,n){return this.set(e,0,0,0,0,t,0,0,0,0,n,0,0,0,0,1),this}makeShear(e,t,n,i,r,a){return this.set(1,n,r,0,e,1,a,0,t,i,1,0,0,0,0,1),this}compose(e,t,n){let i=this.elements,r=t._x,a=t._y,c=t._z,h=t._w,u=r+r,d=a+a,p=c+c,f=r*u,m=r*d,g=r*p,y=a*d,x=a*p,v=c*p,w=h*u,A=h*d,S=h*p,D=n.x,F=n.y,q=n.z;return i[0]=(1-(y+v))*D,i[1]=(m+S)*D,i[2]=(g-A)*D,i[3]=0,i[4]=(m-S)*F,i[5]=(1-(f+v))*F,i[6]=(x+w)*F,i[7]=0,i[8]=(g+A)*q,i[9]=(x-w)*q,i[10]=(1-(f+y))*q,i[11]=0,i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=1,this}decompose(e,t,n){let i=this.elements,r=_r.set(i[0],i[1],i[2]).length(),a=_r.set(i[4],i[5],i[6]).length(),c=_r.set(i[8],i[9],i[10]).length();this.determinant()<0&&(r=-r),e.x=i[12],e.y=i[13],e.z=i[14],Vn.copy(this);let h=1/r,u=1/a,d=1/c;return Vn.elements[0]*=h,Vn.elements[1]*=h,Vn.elements[2]*=h,Vn.elements[4]*=u,Vn.elements[5]*=u,Vn.elements[6]*=u,Vn.elements[8]*=d,Vn.elements[9]*=d,Vn.elements[10]*=d,t.setFromRotationMatrix(Vn),n.x=r,n.y=a,n.z=c,this}makePerspective(e,t,n,i,r,a){a===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");let c=this.elements,h=2*r/(t-e),u=2*r/(n-i),d=(t+e)/(t-e),p=(n+i)/(n-i),f=-(a+r)/(a-r),m=-2*a*r/(a-r);return c[0]=h,c[4]=0,c[8]=d,c[12]=0,c[1]=0,c[5]=u,c[9]=p,c[13]=0,c[2]=0,c[6]=0,c[10]=f,c[14]=m,c[3]=0,c[7]=0,c[11]=-1,c[15]=0,this}makeOrthographic(e,t,n,i,r,a){let c=this.elements,h=1/(t-e),u=1/(n-i),d=1/(a-r),p=(t+e)*h,f=(n+i)*u,m=(a+r)*d;return c[0]=2*h,c[4]=0,c[8]=0,c[12]=-p,c[1]=0,c[5]=2*u,c[9]=0,c[13]=-f,c[2]=0,c[6]=0,c[10]=-2*d,c[14]=-m,c[3]=0,c[7]=0,c[11]=0,c[15]=1,this}equals(e){let t=this.elements,n=e.elements;for(let i=0;i<16;i++)if(t[i]!==n[i])return!1;return!0}fromArray(e,t=0){for(let n=0;n<16;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){let n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e[t+9]=n[9],e[t+10]=n[10],e[t+11]=n[11],e[t+12]=n[12],e[t+13]=n[13],e[t+14]=n[14],e[t+15]=n[15],e}}Xe.prototype.isMatrix4=!0;let _r=new L,Vn=new Xe,Qd=new L(0,0,0),$d=new L(1,1,1),Li=new L,Us=new L,Pn=new L,Vl=new Xe,Wl=new tn;class Wi{constructor(e=0,t=0,n=0,i=Wi.DefaultOrder){this._x=e,this._y=t,this._z=n,this._order=i}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,n,i=this._order){return this._x=e,this._y=t,this._z=n,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,n=!0){let i=e.elements,r=i[0],a=i[4],c=i[8],h=i[1],u=i[5],d=i[9],p=i[2],f=i[6],m=i[10];switch(t){case"XYZ":this._y=Math.asin(Ke(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(-d,m),this._z=Math.atan2(-a,r)):(this._x=Math.atan2(f,u),this._z=0);break;case"YXZ":this._x=Math.asin(-Ke(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(c,m),this._z=Math.atan2(h,u)):(this._y=Math.atan2(-p,r),this._z=0);break;case"ZXY":this._x=Math.asin(Ke(f,-1,1)),Math.abs(f)<.9999999?(this._y=Math.atan2(-p,m),this._z=Math.atan2(-a,u)):(this._y=0,this._z=Math.atan2(h,r));break;case"ZYX":this._y=Math.asin(-Ke(p,-1,1)),Math.abs(p)<.9999999?(this._x=Math.atan2(f,m),this._z=Math.atan2(h,r)):(this._x=0,this._z=Math.atan2(-a,u));break;case"YZX":this._z=Math.asin(Ke(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(-d,u),this._y=Math.atan2(-p,r)):(this._x=0,this._y=Math.atan2(c,m));break;case"XZY":this._z=Math.asin(-Ke(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(f,u),this._y=Math.atan2(c,r)):(this._x=Math.atan2(-d,m),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,n===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,n){return Vl.makeRotationFromQuaternion(e),this.setFromRotationMatrix(Vl,t,n)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return Wl.setFromEuler(this),this.setFromQuaternion(Wl,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}toVector3(e){return e?e.set(this._x,this._y,this._z):new L(this._x,this._y,this._z)}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}Wi.prototype.isEuler=!0,Wi.DefaultOrder="XYZ",Wi.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class lo{constructor(){this.mask=1}set(e){this.mask=1<<e|0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!=0}}let ep=0,ql=new L,br=new tn,fi=new Xe,Gs=new L,ns=new L,tp=new L,np=new tn,jl=new L(1,0,0),Xl=new L(0,1,0),Zl=new L(0,0,1),ip={type:"added"},Yl={type:"removed"};class pt extends Me{constructor(){super(),Object.defineProperty(this,"id",{value:ep++}),this.uuid=nt(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=pt.DefaultUp.clone();let e=new L,t=new Wi,n=new tn,i=new L(1,1,1);t._onChange(function(){n.setFromEuler(t,!1)}),n._onChange(function(){t.setFromQuaternion(n,void 0,!1)}),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new Xe},normalMatrix:{value:new Nt}}),this.matrix=new Xe,this.matrixWorld=new Xe,this.matrixAutoUpdate=pt.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new lo,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return br.setFromAxisAngle(e,t),this.quaternion.multiply(br),this}rotateOnWorldAxis(e,t){return br.setFromAxisAngle(e,t),this.quaternion.premultiply(br),this}rotateX(e){return this.rotateOnAxis(jl,e)}rotateY(e){return this.rotateOnAxis(Xl,e)}rotateZ(e){return this.rotateOnAxis(Zl,e)}translateOnAxis(e,t){return ql.copy(e).applyQuaternion(this.quaternion),this.position.add(ql.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(jl,e)}translateY(e){return this.translateOnAxis(Xl,e)}translateZ(e){return this.translateOnAxis(Zl,e)}localToWorld(e){return e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return e.applyMatrix4(fi.copy(this.matrixWorld).invert())}lookAt(e,t,n){e.isVector3?Gs.copy(e):Gs.set(e,t,n);let i=this.parent;this.updateWorldMatrix(!0,!1),ns.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?fi.lookAt(ns,Gs,this.up):fi.lookAt(Gs,ns,this.up),this.quaternion.setFromRotationMatrix(fi),i&&(fi.extractRotation(i.matrixWorld),br.setFromRotationMatrix(fi),this.quaternion.premultiply(br.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.parent!==null&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(ip)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}let t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(Yl)),this}removeFromParent(){let e=this.parent;return e!==null&&e.remove(this),this}clear(){for(let e=0;e<this.children.length;e++){let t=this.children[e];t.parent=null,t.dispatchEvent(Yl)}return this.children.length=0,this}attach(e){return this.updateWorldMatrix(!0,!1),fi.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),fi.multiply(e.parent.matrixWorld)),e.applyMatrix4(fi),this.add(e),e.updateWorldMatrix(!1,!0),this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let n=0,i=this.children.length;n<i;n++){let r=this.children[n].getObjectByProperty(e,t);if(r!==void 0)return r}}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(ns,e,tp),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(ns,np,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);let t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);let t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);let t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].traverseVisible(e)}traverseAncestors(e){let t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);let t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].updateMatrixWorld(e)}updateWorldMatrix(e,t){let n=this.parent;if(e===!0&&n!==null&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){let i=this.children;for(let r=0,a=i.length;r<a;r++)i[r].updateWorldMatrix(!1,!0)}}toJSON(e){let t=e===void 0||typeof e=="string",n={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});let i={};function r(c,h){return c[h.uuid]===void 0&&(c[h.uuid]=h.toJSON(e)),h.uuid}if(i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON())),this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&(i.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=r(e.geometries,this.geometry);let c=this.geometry.parameters;if(c!==void 0&&c.shapes!==void 0){let h=c.shapes;if(Array.isArray(h))for(let u=0,d=h.length;u<d;u++){let p=h[u];r(e.shapes,p)}else r(e.shapes,h)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(r(e.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){let c=[];for(let h=0,u=this.material.length;h<u;h++)c.push(r(e.materials,this.material[h]));i.material=c}else i.material=r(e.materials,this.material);if(this.children.length>0){i.children=[];for(let c=0;c<this.children.length;c++)i.children.push(this.children[c].toJSON(e).object)}if(this.animations.length>0){i.animations=[];for(let c=0;c<this.animations.length;c++){let h=this.animations[c];i.animations.push(r(e.animations,h))}}if(t){let c=a(e.geometries),h=a(e.materials),u=a(e.textures),d=a(e.images),p=a(e.shapes),f=a(e.skeletons),m=a(e.animations);c.length>0&&(n.geometries=c),h.length>0&&(n.materials=h),u.length>0&&(n.textures=u),d.length>0&&(n.images=d),p.length>0&&(n.shapes=p),f.length>0&&(n.skeletons=f),m.length>0&&(n.animations=m)}return n.object=i,n;function a(c){let h=[];for(let u in c){let d=c[u];delete d.metadata,h.push(d)}return h}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let n=0;n<e.children.length;n++){let i=e.children[n];this.add(i.clone())}return this}}pt.DefaultUp=new L(0,1,0),pt.DefaultMatrixAutoUpdate=!0,pt.prototype.isObject3D=!0;let Wn=new L,mi=new L,co=new L,gi=new L,Mr=new L,wr=new L,Jl=new L,ho=new L,uo=new L,po=new L;class Yt{constructor(e=new L,t=new L,n=new L){this.a=e,this.b=t,this.c=n}static getNormal(e,t,n,i){i.subVectors(n,t),Wn.subVectors(e,t),i.cross(Wn);let r=i.lengthSq();return r>0?i.multiplyScalar(1/Math.sqrt(r)):i.set(0,0,0)}static getBarycoord(e,t,n,i,r){Wn.subVectors(i,t),mi.subVectors(n,t),co.subVectors(e,t);let a=Wn.dot(Wn),c=Wn.dot(mi),h=Wn.dot(co),u=mi.dot(mi),d=mi.dot(co),p=a*u-c*c;if(p===0)return r.set(-2,-1,-1);let f=1/p,m=(u*h-c*d)*f,g=(a*d-c*h)*f;return r.set(1-m-g,g,m)}static containsPoint(e,t,n,i){return this.getBarycoord(e,t,n,i,gi),gi.x>=0&&gi.y>=0&&gi.x+gi.y<=1}static getUV(e,t,n,i,r,a,c,h){return this.getBarycoord(e,t,n,i,gi),h.set(0,0),h.addScaledVector(r,gi.x),h.addScaledVector(a,gi.y),h.addScaledVector(c,gi.z),h}static isFrontFacing(e,t,n,i){return Wn.subVectors(n,t),mi.subVectors(e,t),Wn.cross(mi).dot(i)<0}set(e,t,n){return this.a.copy(e),this.b.copy(t),this.c.copy(n),this}setFromPointsAndIndices(e,t,n,i){return this.a.copy(e[t]),this.b.copy(e[n]),this.c.copy(e[i]),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return Wn.subVectors(this.c,this.b),mi.subVectors(this.a,this.b),.5*Wn.cross(mi).length()}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return Yt.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return Yt.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,n,i,r){return Yt.getUV(e,this.a,this.b,this.c,t,n,i,r)}containsPoint(e){return Yt.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return Yt.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){let n=this.a,i=this.b,r=this.c,a,c;Mr.subVectors(i,n),wr.subVectors(r,n),ho.subVectors(e,n);let h=Mr.dot(ho),u=wr.dot(ho);if(h<=0&&u<=0)return t.copy(n);uo.subVectors(e,i);let d=Mr.dot(uo),p=wr.dot(uo);if(d>=0&&p<=d)return t.copy(i);let f=h*p-d*u;if(f<=0&&h>=0&&d<=0)return a=h/(h-d),t.copy(n).addScaledVector(Mr,a);po.subVectors(e,r);let m=Mr.dot(po),g=wr.dot(po);if(g>=0&&m<=g)return t.copy(r);let y=m*u-h*g;if(y<=0&&u>=0&&g<=0)return c=u/(u-g),t.copy(n).addScaledVector(wr,c);let x=d*g-m*p;if(x<=0&&p-d>=0&&m-g>=0)return Jl.subVectors(r,i),c=(p-d)/(p-d+(m-g)),t.copy(i).addScaledVector(Jl,c);let v=1/(x+y+f);return a=y*v,c=f*v,t.copy(n).addScaledVector(Mr,a).addScaledVector(wr,c)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}let rp=0;class nn extends Me{constructor(){super(),Object.defineProperty(this,"id",{value:rp++}),this.uuid=nt(),this.name="",this.type="Material",this.fog=!0,this.blending=1,this.side=0,this.vertexColors=!1,this.opacity=1,this.format=1023,this.transparent=!1,this.blendSrc=204,this.blendDst=205,this.blendEquation=100,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=7680,this.stencilZFail=7680,this.stencilZPass=7680,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(let t in e){let n=e[t];if(n===void 0){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}if(t==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=n===1;continue}let i=this[t];i!==void 0?i&&i.isColor?i.set(n):i&&i.isVector3&&n&&n.isVector3?i.copy(n):this[t]=n:console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.")}}toJSON(e){let t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});let n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function i(r){let a=[];for(let c in r){let h=r[c];delete h.metadata,a.push(h)}return a}if(n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),this.roughness!==void 0&&(n.roughness=this.roughness),this.metalness!==void 0&&(n.metalness=this.metalness),this.sheenTint&&this.sheenTint.isColor&&(n.sheenTint=this.sheenTint.getHex()),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(n.specularIntensity=this.specularIntensity),this.specularTint&&this.specularTint.isColor&&(n.specularTint=this.specularTint.getHex()),this.shininess!==void 0&&(n.shininess=this.shininess),this.clearcoat!==void 0&&(n.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(e).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(e).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(e).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(e).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(e).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularTintMap&&this.specularTintMap.isTexture&&(n.specularTintMap=this.specularTintMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(n.combine=this.combine)),this.envMapIntensity!==void 0&&(n.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(n.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&(n.attenuationDistance=this.attenuationDistance),this.attenuationTint!==void 0&&(n.attenuationTint=this.attenuationTint.getHex()),this.size!==void 0&&(n.size=this.size),this.shadowSide!==null&&(n.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==1&&(n.blending=this.blending),this.side!==0&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.format!==1023&&(n.format=this.format),this.transparent===!0&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.colorWrite=this.colorWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation&&this.rotation!==0&&(n.rotation=this.rotation),this.polygonOffset===!0&&(n.polygonOffset=!0),this.polygonOffsetFactor!==0&&(n.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&this.linewidth!==1&&(n.linewidth=this.linewidth),this.dashSize!==void 0&&(n.dashSize=this.dashSize),this.gapSize!==void 0&&(n.gapSize=this.gapSize),this.scale!==void 0&&(n.scale=this.scale),this.dithering===!0&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(n.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(n.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(n.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(n.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(n.flatShading=this.flatShading),this.visible===!1&&(n.visible=!1),this.toneMapped===!1&&(n.toneMapped=!1),JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData),t){let r=i(e.textures),a=i(e.images);r.length>0&&(n.textures=r),a.length>0&&(n.images=a)}return n}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.fog=e.fog,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.format=e.format,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;let t=e.clippingPlanes,n=null;if(t!==null){let i=t.length;n=new Array(i);for(let r=0;r!==i;++r)n[r]=t[r].clone()}return this.clippingPlanes=n,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}}nn.prototype.isMaterial=!0;let Kl={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},qn={h:0,s:0,l:0},ks={h:0,s:0,l:0};function fo(s,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?s+6*(e-s)*t:t<.5?e:t<2/3?s+6*(e-s)*(2/3-t):s}function mo(s){return s<.04045?.0773993808*s:Math.pow(.9478672986*s+.0521327014,2.4)}function go(s){return s<.0031308?12.92*s:1.055*Math.pow(s,.41666)-.055}class De{constructor(e,t,n){return t===void 0&&n===void 0?this.set(e):this.setRGB(e,t,n)}set(e){return e&&e.isColor?this.copy(e):typeof e=="number"?this.setHex(e):typeof e=="string"&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(255&e)/255,this}setRGB(e,t,n){return this.r=e,this.g=t,this.b=n,this}setHSL(e,t,n){if(e=at(e,1),t=Ke(t,0,1),n=Ke(n,0,1),t===0)this.r=this.g=this.b=n;else{let i=n<=.5?n*(1+t):n+t-n*t,r=2*n-i;this.r=fo(r,i,e+1/3),this.g=fo(r,i,e),this.b=fo(r,i,e-1/3)}return this}setStyle(e){function t(i){i!==void 0&&parseFloat(i)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let n;if(n=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)){let i,r=n[1],a=n[2];switch(r){case"rgb":case"rgba":if(i=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(255,parseInt(i[1],10))/255,this.g=Math.min(255,parseInt(i[2],10))/255,this.b=Math.min(255,parseInt(i[3],10))/255,t(i[4]),this;if(i=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(100,parseInt(i[1],10))/100,this.g=Math.min(100,parseInt(i[2],10))/100,this.b=Math.min(100,parseInt(i[3],10))/100,t(i[4]),this;break;case"hsl":case"hsla":if(i=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)){let c=parseFloat(i[1])/360,h=parseInt(i[2],10)/100,u=parseInt(i[3],10)/100;return t(i[4]),this.setHSL(c,h,u)}}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(e)){let i=n[1],r=i.length;if(r===3)return this.r=parseInt(i.charAt(0)+i.charAt(0),16)/255,this.g=parseInt(i.charAt(1)+i.charAt(1),16)/255,this.b=parseInt(i.charAt(2)+i.charAt(2),16)/255,this;if(r===6)return this.r=parseInt(i.charAt(0)+i.charAt(1),16)/255,this.g=parseInt(i.charAt(2)+i.charAt(3),16)/255,this.b=parseInt(i.charAt(4)+i.charAt(5),16)/255,this}return e&&e.length>0?this.setColorName(e):this}setColorName(e){let t=Kl[e.toLowerCase()];return t!==void 0?this.setHex(t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copyGammaToLinear(e,t=2){return this.r=Math.pow(e.r,t),this.g=Math.pow(e.g,t),this.b=Math.pow(e.b,t),this}copyLinearToGamma(e,t=2){let n=t>0?1/t:1;return this.r=Math.pow(e.r,n),this.g=Math.pow(e.g,n),this.b=Math.pow(e.b,n),this}convertGammaToLinear(e){return this.copyGammaToLinear(this,e),this}convertLinearToGamma(e){return this.copyLinearToGamma(this,e),this}copySRGBToLinear(e){return this.r=mo(e.r),this.g=mo(e.g),this.b=mo(e.b),this}copyLinearToSRGB(e){return this.r=go(e.r),this.g=go(e.g),this.b=go(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return 255*this.r<<16^255*this.g<<8^255*this.b<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(e){let t=this.r,n=this.g,i=this.b,r=Math.max(t,n,i),a=Math.min(t,n,i),c,h,u=(a+r)/2;if(a===r)c=0,h=0;else{let d=r-a;switch(h=u<=.5?d/(r+a):d/(2-r-a),r){case t:c=(n-i)/d+(n<i?6:0);break;case n:c=(i-t)/d+2;break;case i:c=(t-n)/d+4}c/=6}return e.h=c,e.s=h,e.l=u,e}getStyle(){return"rgb("+(255*this.r|0)+","+(255*this.g|0)+","+(255*this.b|0)+")"}offsetHSL(e,t,n){return this.getHSL(qn),qn.h+=e,qn.s+=t,qn.l+=n,this.setHSL(qn.h,qn.s,qn.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,n){return this.r=e.r+(t.r-e.r)*n,this.g=e.g+(t.g-e.g)*n,this.b=e.b+(t.b-e.b)*n,this}lerpHSL(e,t){this.getHSL(qn),e.getHSL(ks);let n=Wt(qn.h,ks.h,t),i=Wt(qn.s,ks.s,t),r=Wt(qn.l,ks.l,t);return this.setHSL(n,i,r),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),e.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}De.NAMES=Kl,De.prototype.isColor=!0,De.prototype.r=1,De.prototype.g=1,De.prototype.b=1;class yi extends nn{constructor(e){super(),this.type="MeshBasicMaterial",this.color=new De(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this}}yi.prototype.isMeshBasicMaterial=!0;let Bt=new L,Vs=new me;class bt{constructor(e,t,n){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=n===!0,this.usage=35044,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this}copyAt(e,t,n){e*=this.itemSize,n*=t.itemSize;for(let i=0,r=this.itemSize;i<r;i++)this.array[e+i]=t.array[n+i];return this}copyArray(e){return this.array.set(e),this}copyColorsArray(e){let t=this.array,n=0;for(let i=0,r=e.length;i<r;i++){let a=e[i];a===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",i),a=new De),t[n++]=a.r,t[n++]=a.g,t[n++]=a.b}return this}copyVector2sArray(e){let t=this.array,n=0;for(let i=0,r=e.length;i<r;i++){let a=e[i];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",i),a=new me),t[n++]=a.x,t[n++]=a.y}return this}copyVector3sArray(e){let t=this.array,n=0;for(let i=0,r=e.length;i<r;i++){let a=e[i];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",i),a=new L),t[n++]=a.x,t[n++]=a.y,t[n++]=a.z}return this}copyVector4sArray(e){let t=this.array,n=0;for(let i=0,r=e.length;i<r;i++){let a=e[i];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",i),a=new _t),t[n++]=a.x,t[n++]=a.y,t[n++]=a.z,t[n++]=a.w}return this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,n=this.count;t<n;t++)Vs.fromBufferAttribute(this,t),Vs.applyMatrix3(e),this.setXY(t,Vs.x,Vs.y);else if(this.itemSize===3)for(let t=0,n=this.count;t<n;t++)Bt.fromBufferAttribute(this,t),Bt.applyMatrix3(e),this.setXYZ(t,Bt.x,Bt.y,Bt.z);return this}applyMatrix4(e){for(let t=0,n=this.count;t<n;t++)Bt.x=this.getX(t),Bt.y=this.getY(t),Bt.z=this.getZ(t),Bt.applyMatrix4(e),this.setXYZ(t,Bt.x,Bt.y,Bt.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)Bt.x=this.getX(t),Bt.y=this.getY(t),Bt.z=this.getZ(t),Bt.applyNormalMatrix(e),this.setXYZ(t,Bt.x,Bt.y,Bt.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)Bt.x=this.getX(t),Bt.y=this.getY(t),Bt.z=this.getZ(t),Bt.transformDirection(e),this.setXYZ(t,Bt.x,Bt.y,Bt.z);return this}set(e,t=0){return this.array.set(e,t),this}getX(e){return this.array[e*this.itemSize]}setX(e,t){return this.array[e*this.itemSize]=t,this}getY(e){return this.array[e*this.itemSize+1]}setY(e,t){return this.array[e*this.itemSize+1]=t,this}getZ(e){return this.array[e*this.itemSize+2]}setZ(e,t){return this.array[e*this.itemSize+2]=t,this}getW(e){return this.array[e*this.itemSize+3]}setW(e,t){return this.array[e*this.itemSize+3]=t,this}setXY(e,t,n){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this}setXYZ(e,t,n,i){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=i,this}setXYZW(e,t,n,i,r){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=i,this.array[e+3]=r,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){let e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==35044&&(e.usage=this.usage),this.updateRange.offset===0&&this.updateRange.count===-1||(e.updateRange=this.updateRange),e}}bt.prototype.isBufferAttribute=!0;class Ql extends bt{constructor(e,t,n){super(new Int8Array(e),t,n)}}class $l extends bt{constructor(e,t,n){super(new Uint8Array(e),t,n)}}class ec extends bt{constructor(e,t,n){super(new Uint8ClampedArray(e),t,n)}}class tc extends bt{constructor(e,t,n){super(new Int16Array(e),t,n)}}class Ws extends bt{constructor(e,t,n){super(new Uint16Array(e),t,n)}}class nc extends bt{constructor(e,t,n){super(new Int32Array(e),t,n)}}class qs extends bt{constructor(e,t,n){super(new Uint32Array(e),t,n)}}class ic extends bt{constructor(e,t,n){super(new Uint16Array(e),t,n)}}ic.prototype.isFloat16BufferAttribute=!0;class Ue extends bt{constructor(e,t,n){super(new Float32Array(e),t,n)}}class rc extends bt{constructor(e,t,n){super(new Float64Array(e),t,n)}}function sc(s){if(s.length===0)return-1/0;let e=s[0];for(let t=1,n=s.length;t<n;++t)s[t]>e&&(e=s[t]);return e}let sp={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function Sr(s,e){return new sp[s](e)}let ap=0,Hn=new Xe,yo=new pt,Tr=new L,Dn=new Cn,is=new Cn,rn=new L;class st extends Me{constructor(){super(),Object.defineProperty(this,"id",{value:ap++}),this.uuid=nt(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(sc(e)>65535?qs:Ws)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,n=0){this.groups.push({start:e,count:t,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){let t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);let n=this.attributes.normal;if(n!==void 0){let r=new Nt().getNormalMatrix(e);n.applyNormalMatrix(r),n.needsUpdate=!0}let i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(e),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return Hn.makeRotationFromQuaternion(e),this.applyMatrix4(Hn),this}rotateX(e){return Hn.makeRotationX(e),this.applyMatrix4(Hn),this}rotateY(e){return Hn.makeRotationY(e),this.applyMatrix4(Hn),this}rotateZ(e){return Hn.makeRotationZ(e),this.applyMatrix4(Hn),this}translate(e,t,n){return Hn.makeTranslation(e,t,n),this.applyMatrix4(Hn),this}scale(e,t,n){return Hn.makeScale(e,t,n),this.applyMatrix4(Hn),this}lookAt(e){return yo.lookAt(e),yo.updateMatrix(),this.applyMatrix4(yo.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Tr).negate(),this.translate(Tr.x,Tr.y,Tr.z),this}setFromPoints(e){let t=[];for(let n=0,i=e.length;n<i;n++){let r=e[n];t.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new Ue(t,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Cn);let e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new L(-1/0,-1/0,-1/0),new L(1/0,1/0,1/0));if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let n=0,i=t.length;n<i;n++){let r=t[n];Dn.setFromBufferAttribute(r),this.morphTargetsRelative?(rn.addVectors(this.boundingBox.min,Dn.min),this.boundingBox.expandByPoint(rn),rn.addVectors(this.boundingBox.max,Dn.max),this.boundingBox.expandByPoint(rn)):(this.boundingBox.expandByPoint(Dn.min),this.boundingBox.expandByPoint(Dn.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Ti);let e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new L,1/0);if(e){let n=this.boundingSphere.center;if(Dn.setFromBufferAttribute(e),t)for(let r=0,a=t.length;r<a;r++){let c=t[r];is.setFromBufferAttribute(c),this.morphTargetsRelative?(rn.addVectors(Dn.min,is.min),Dn.expandByPoint(rn),rn.addVectors(Dn.max,is.max),Dn.expandByPoint(rn)):(Dn.expandByPoint(is.min),Dn.expandByPoint(is.max))}Dn.getCenter(n);let i=0;for(let r=0,a=e.count;r<a;r++)rn.fromBufferAttribute(e,r),i=Math.max(i,n.distanceToSquared(rn));if(t)for(let r=0,a=t.length;r<a;r++){let c=t[r],h=this.morphTargetsRelative;for(let u=0,d=c.count;u<d;u++)rn.fromBufferAttribute(c,u),h&&(Tr.fromBufferAttribute(e,u),rn.add(Tr)),i=Math.max(i,n.distanceToSquared(rn))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){let e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");let n=e.array,i=t.position.array,r=t.normal.array,a=t.uv.array,c=i.length/3;t.tangent===void 0&&this.setAttribute("tangent",new bt(new Float32Array(4*c),4));let h=t.tangent.array,u=[],d=[];for(let J=0;J<c;J++)u[J]=new L,d[J]=new L;let p=new L,f=new L,m=new L,g=new me,y=new me,x=new me,v=new L,w=new L;function A(J,$,Re){p.fromArray(i,3*J),f.fromArray(i,3*$),m.fromArray(i,3*Re),g.fromArray(a,2*J),y.fromArray(a,2*$),x.fromArray(a,2*Re),f.sub(p),m.sub(p),y.sub(g),x.sub(g);let ye=1/(y.x*x.y-x.x*y.y);isFinite(ye)&&(v.copy(f).multiplyScalar(x.y).addScaledVector(m,-y.y).multiplyScalar(ye),w.copy(m).multiplyScalar(y.x).addScaledVector(f,-x.x).multiplyScalar(ye),u[J].add(v),u[$].add(v),u[Re].add(v),d[J].add(w),d[$].add(w),d[Re].add(w))}let S=this.groups;S.length===0&&(S=[{start:0,count:n.length}]);for(let J=0,$=S.length;J<$;++J){let Re=S[J],ye=Re.start;for(let ae=ye,be=ye+Re.count;ae<be;ae+=3)A(n[ae+0],n[ae+1],n[ae+2])}let D=new L,F=new L,q=new L,X=new L;function te(J){q.fromArray(r,3*J),X.copy(q);let $=u[J];D.copy($),D.sub(q.multiplyScalar(q.dot($))).normalize(),F.crossVectors(X,$);let Re=F.dot(d[J])<0?-1:1;h[4*J]=D.x,h[4*J+1]=D.y,h[4*J+2]=D.z,h[4*J+3]=Re}for(let J=0,$=S.length;J<$;++J){let Re=S[J],ye=Re.start;for(let ae=ye,be=ye+Re.count;ae<be;ae+=3)te(n[ae+0]),te(n[ae+1]),te(n[ae+2])}}computeVertexNormals(){let e=this.index,t=this.getAttribute("position");if(t!==void 0){let n=this.getAttribute("normal");if(n===void 0)n=new bt(new Float32Array(3*t.count),3),this.setAttribute("normal",n);else for(let f=0,m=n.count;f<m;f++)n.setXYZ(f,0,0,0);let i=new L,r=new L,a=new L,c=new L,h=new L,u=new L,d=new L,p=new L;if(e)for(let f=0,m=e.count;f<m;f+=3){let g=e.getX(f+0),y=e.getX(f+1),x=e.getX(f+2);i.fromBufferAttribute(t,g),r.fromBufferAttribute(t,y),a.fromBufferAttribute(t,x),d.subVectors(a,r),p.subVectors(i,r),d.cross(p),c.fromBufferAttribute(n,g),h.fromBufferAttribute(n,y),u.fromBufferAttribute(n,x),c.add(d),h.add(d),u.add(d),n.setXYZ(g,c.x,c.y,c.z),n.setXYZ(y,h.x,h.y,h.z),n.setXYZ(x,u.x,u.y,u.z)}else for(let f=0,m=t.count;f<m;f+=3)i.fromBufferAttribute(t,f+0),r.fromBufferAttribute(t,f+1),a.fromBufferAttribute(t,f+2),d.subVectors(a,r),p.subVectors(i,r),d.cross(p),n.setXYZ(f+0,d.x,d.y,d.z),n.setXYZ(f+1,d.x,d.y,d.z),n.setXYZ(f+2,d.x,d.y,d.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(e,t){if(!e||!e.isBufferGeometry)return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",e);t===void 0&&(t=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));let n=this.attributes;for(let i in n){if(e.attributes[i]===void 0)continue;let r=n[i].array,a=e.attributes[i],c=a.array,h=a.itemSize*t,u=Math.min(c.length,r.length-h);for(let d=0,p=h;d<u;d++,p++)r[p]=c[d]}return this}normalizeNormals(){let e=this.attributes.normal;for(let t=0,n=e.count;t<n;t++)rn.fromBufferAttribute(e,t),rn.normalize(),e.setXYZ(t,rn.x,rn.y,rn.z)}toNonIndexed(){function e(c,h){let u=c.array,d=c.itemSize,p=c.normalized,f=new u.constructor(h.length*d),m=0,g=0;for(let y=0,x=h.length;y<x;y++){m=c.isInterleavedBufferAttribute?h[y]*c.data.stride+c.offset:h[y]*d;for(let v=0;v<d;v++)f[g++]=u[m++]}return new bt(f,d,p)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;let t=new st,n=this.index.array,i=this.attributes;for(let c in i){let h=e(i[c],n);t.setAttribute(c,h)}let r=this.morphAttributes;for(let c in r){let h=[],u=r[c];for(let d=0,p=u.length;d<p;d++){let f=e(u[d],n);h.push(f)}t.morphAttributes[c]=h}t.morphTargetsRelative=this.morphTargetsRelative;let a=this.groups;for(let c=0,h=a.length;c<h;c++){let u=a[c];t.addGroup(u.start,u.count,u.materialIndex)}return t}toJSON(){let e={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){let h=this.parameters;for(let u in h)h[u]!==void 0&&(e[u]=h[u]);return e}e.data={attributes:{}};let t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});let n=this.attributes;for(let h in n){let u=n[h];e.data.attributes[h]=u.toJSON(e.data)}let i={},r=!1;for(let h in this.morphAttributes){let u=this.morphAttributes[h],d=[];for(let p=0,f=u.length;p<f;p++){let m=u[p];d.push(m.toJSON(e.data))}d.length>0&&(i[h]=d,r=!0)}r&&(e.data.morphAttributes=i,e.data.morphTargetsRelative=this.morphTargetsRelative);let a=this.groups;a.length>0&&(e.data.groups=JSON.parse(JSON.stringify(a)));let c=this.boundingSphere;return c!==null&&(e.data.boundingSphere={center:c.center.toArray(),radius:c.radius}),e}clone(){return new st().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;let t={};this.name=e.name;let n=e.index;n!==null&&this.setIndex(n.clone(t));let i=e.attributes;for(let u in i){let d=i[u];this.setAttribute(u,d.clone(t))}let r=e.morphAttributes;for(let u in r){let d=[],p=r[u];for(let f=0,m=p.length;f<m;f++)d.push(p[f].clone(t));this.morphAttributes[u]=d}this.morphTargetsRelative=e.morphTargetsRelative;let a=e.groups;for(let u=0,d=a.length;u<d;u++){let p=a[u];this.addGroup(p.start,p.count,p.materialIndex)}let c=e.boundingBox;c!==null&&(this.boundingBox=c.clone());let h=e.boundingSphere;return h!==null&&(this.boundingSphere=h.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}st.prototype.isBufferGeometry=!0;let ac=new Xe,Er=new Ai,vo=new Ti,Ri=new L,Ci=new L,Pi=new L,xo=new L,_o=new L,bo=new L,js=new L,Xs=new L,Zs=new L,Ys=new me,Js=new me,Ks=new me,Mo=new L,Qs=new L;class en extends pt{constructor(e=new st,t=new yi){super(),this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this}updateMorphTargets(){let e=this.geometry;if(e.isBufferGeometry){let t=e.morphAttributes,n=Object.keys(t);if(n.length>0){let i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,a=i.length;r<a;r++){let c=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[c]=r}}}}else{let t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(e,t){let n=this.geometry,i=this.material,r=this.matrixWorld;if(i===void 0||(n.boundingSphere===null&&n.computeBoundingSphere(),vo.copy(n.boundingSphere),vo.applyMatrix4(r),e.ray.intersectsSphere(vo)===!1)||(ac.copy(r).invert(),Er.copy(e.ray).applyMatrix4(ac),n.boundingBox!==null&&Er.intersectsBox(n.boundingBox)===!1))return;let a;if(n.isBufferGeometry){let c=n.index,h=n.attributes.position,u=n.morphAttributes.position,d=n.morphTargetsRelative,p=n.attributes.uv,f=n.attributes.uv2,m=n.groups,g=n.drawRange;if(c!==null)if(Array.isArray(i))for(let y=0,x=m.length;y<x;y++){let v=m[y],w=i[v.materialIndex];for(let A=Math.max(v.start,g.start),S=Math.min(v.start+v.count,g.start+g.count);A<S;A+=3){let D=c.getX(A),F=c.getX(A+1),q=c.getX(A+2);a=$s(this,w,e,Er,h,u,d,p,f,D,F,q),a&&(a.faceIndex=Math.floor(A/3),a.face.materialIndex=v.materialIndex,t.push(a))}}else for(let y=Math.max(0,g.start),x=Math.min(c.count,g.start+g.count);y<x;y+=3){let v=c.getX(y),w=c.getX(y+1),A=c.getX(y+2);a=$s(this,i,e,Er,h,u,d,p,f,v,w,A),a&&(a.faceIndex=Math.floor(y/3),t.push(a))}else if(h!==void 0)if(Array.isArray(i))for(let y=0,x=m.length;y<x;y++){let v=m[y],w=i[v.materialIndex];for(let A=Math.max(v.start,g.start),S=Math.min(v.start+v.count,g.start+g.count);A<S;A+=3)a=$s(this,w,e,Er,h,u,d,p,f,A,A+1,A+2),a&&(a.faceIndex=Math.floor(A/3),a.face.materialIndex=v.materialIndex,t.push(a))}else for(let y=Math.max(0,g.start),x=Math.min(h.count,g.start+g.count);y<x;y+=3)a=$s(this,i,e,Er,h,u,d,p,f,y,y+1,y+2),a&&(a.faceIndex=Math.floor(y/3),t.push(a))}else n.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}function $s(s,e,t,n,i,r,a,c,h,u,d,p){Ri.fromBufferAttribute(i,u),Ci.fromBufferAttribute(i,d),Pi.fromBufferAttribute(i,p);let f=s.morphTargetInfluences;if(r&&f){js.set(0,0,0),Xs.set(0,0,0),Zs.set(0,0,0);for(let g=0,y=r.length;g<y;g++){let x=f[g],v=r[g];x!==0&&(xo.fromBufferAttribute(v,u),_o.fromBufferAttribute(v,d),bo.fromBufferAttribute(v,p),a?(js.addScaledVector(xo,x),Xs.addScaledVector(_o,x),Zs.addScaledVector(bo,x)):(js.addScaledVector(xo.sub(Ri),x),Xs.addScaledVector(_o.sub(Ci),x),Zs.addScaledVector(bo.sub(Pi),x)))}Ri.add(js),Ci.add(Xs),Pi.add(Zs)}s.isSkinnedMesh&&(s.boneTransform(u,Ri),s.boneTransform(d,Ci),s.boneTransform(p,Pi));let m=function(g,y,x,v,w,A,S,D){let F;if(F=y.side===1?v.intersectTriangle(S,A,w,!0,D):v.intersectTriangle(w,A,S,y.side!==2,D),F===null)return null;Qs.copy(D),Qs.applyMatrix4(g.matrixWorld);let q=x.ray.origin.distanceTo(Qs);return q<x.near||q>x.far?null:{distance:q,point:Qs.clone(),object:g}}(s,e,t,n,Ri,Ci,Pi,Mo);if(m){c&&(Ys.fromBufferAttribute(c,u),Js.fromBufferAttribute(c,d),Ks.fromBufferAttribute(c,p),m.uv=Yt.getUV(Mo,Ri,Ci,Pi,Ys,Js,Ks,new me)),h&&(Ys.fromBufferAttribute(h,u),Js.fromBufferAttribute(h,d),Ks.fromBufferAttribute(h,p),m.uv2=Yt.getUV(Mo,Ri,Ci,Pi,Ys,Js,Ks,new me));let g={a:u,b:d,c:p,normal:new L,materialIndex:0};Yt.getNormal(Ri,Ci,Pi,g.normal),m.face=g}return m}en.prototype.isMesh=!0;class vi extends st{constructor(e=1,t=1,n=1,i=1,r=1,a=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:n,widthSegments:i,heightSegments:r,depthSegments:a};let c=this;i=Math.floor(i),r=Math.floor(r),a=Math.floor(a);let h=[],u=[],d=[],p=[],f=0,m=0;function g(y,x,v,w,A,S,D,F,q,X,te){let J=S/q,$=D/X,Re=S/2,ye=D/2,ae=F/2,be=q+1,Ce=X+1,Ie=0,ke=0,$e=new L;for(let et=0;et<Ce;et++){let _e=et*$-ye;for(let O=0;O<be;O++){let B=O*J-Re;$e[y]=B*w,$e[x]=_e*A,$e[v]=ae,u.push($e.x,$e.y,$e.z),$e[y]=0,$e[x]=0,$e[v]=F>0?1:-1,d.push($e.x,$e.y,$e.z),p.push(O/q),p.push(1-et/X),Ie+=1}}for(let et=0;et<X;et++)for(let _e=0;_e<q;_e++){let O=f+_e+be*et,B=f+_e+be*(et+1),ce=f+(_e+1)+be*(et+1),se=f+(_e+1)+be*et;h.push(O,B,se),h.push(B,ce,se),ke+=6}c.addGroup(m,ke,te),m+=ke,f+=Ie}g("z","y","x",-1,-1,n,t,e,a,r,0),g("z","y","x",1,-1,n,t,-e,a,r,1),g("x","z","y",1,1,e,n,t,i,a,2),g("x","z","y",1,-1,e,n,-t,i,a,3),g("x","y","z",1,-1,e,t,n,i,r,4),g("x","y","z",-1,-1,e,t,-n,i,r,5),this.setIndex(h),this.setAttribute("position",new Ue(u,3)),this.setAttribute("normal",new Ue(d,3)),this.setAttribute("uv",new Ue(p,2))}static fromJSON(e){return new vi(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function Ar(s){let e={};for(let t in s){e[t]={};for(let n in s[t]){let i=s[t][n];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?e[t][n]=i.clone():Array.isArray(i)?e[t][n]=i.slice():e[t][n]=i}}return e}function un(s){let e={};for(let t=0;t<s.length;t++){let n=Ar(s[t]);for(let i in n)e[i]=n[i]}return e}let oc={clone:Ar,merge:un};class xi extends nn{constructor(e){super(),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,this.fragmentShader=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&(e.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(e))}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=Ar(e.uniforms),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){let t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(let i in this.uniforms){let r=this.uniforms[i].value;r&&r.isTexture?t.uniforms[i]={type:"t",value:r.toJSON(e).uuid}:r&&r.isColor?t.uniforms[i]={type:"c",value:r.getHex()}:r&&r.isVector2?t.uniforms[i]={type:"v2",value:r.toArray()}:r&&r.isVector3?t.uniforms[i]={type:"v3",value:r.toArray()}:r&&r.isVector4?t.uniforms[i]={type:"v4",value:r.toArray()}:r&&r.isMatrix3?t.uniforms[i]={type:"m3",value:r.toArray()}:r&&r.isMatrix4?t.uniforms[i]={type:"m4",value:r.toArray()}:t.uniforms[i]={value:r}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;let n={};for(let i in this.extensions)this.extensions[i]===!0&&(n[i]=!0);return Object.keys(n).length>0&&(t.extensions=n),t}}xi.prototype.isShaderMaterial=!0;class rs extends pt{constructor(){super(),this.type="Camera",this.matrixWorldInverse=new Xe,this.projectionMatrix=new Xe,this.projectionMatrixInverse=new Xe}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this}getWorldDirection(e){this.updateWorldMatrix(!0,!1);let t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}rs.prototype.isCamera=!0;class sn extends rs{constructor(e=50,t=1,n=.1,i=2e3){super(),this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){let t=.5*this.getFilmHeight()/e;this.fov=2*Et*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){let e=Math.tan(.5*rt*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return 2*Et*Math.atan(Math.tan(.5*rt*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(e,t,n,i,r,a){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){let e=this.near,t=e*Math.tan(.5*rt*this.fov)/this.zoom,n=2*t,i=this.aspect*n,r=-.5*i,a=this.view;if(this.view!==null&&this.view.enabled){let h=a.fullWidth,u=a.fullHeight;r+=a.offsetX*i/h,t-=a.offsetY*n/u,i*=a.width/h,n*=a.height/u}let c=this.filmOffset;c!==0&&(r+=e*c/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+i,t,t-n,e,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){let t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}sn.prototype.isPerspectiveCamera=!0;let Lr=90;class ea extends pt{constructor(e,t,n){if(super(),this.type="CubeCamera",n.isWebGLCubeRenderTarget!==!0)return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");this.renderTarget=n;let i=new sn(Lr,1,e,t);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new L(1,0,0)),this.add(i);let r=new sn(Lr,1,e,t);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new L(-1,0,0)),this.add(r);let a=new sn(Lr,1,e,t);a.layers=this.layers,a.up.set(0,0,1),a.lookAt(new L(0,1,0)),this.add(a);let c=new sn(Lr,1,e,t);c.layers=this.layers,c.up.set(0,0,-1),c.lookAt(new L(0,-1,0)),this.add(c);let h=new sn(Lr,1,e,t);h.layers=this.layers,h.up.set(0,-1,0),h.lookAt(new L(0,0,1)),this.add(h);let u=new sn(Lr,1,e,t);u.layers=this.layers,u.up.set(0,-1,0),u.lookAt(new L(0,0,-1)),this.add(u)}update(e,t){this.parent===null&&this.updateMatrixWorld();let n=this.renderTarget,[i,r,a,c,h,u]=this.children,d=e.xr.enabled,p=e.getRenderTarget();e.xr.enabled=!1;let f=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,e.setRenderTarget(n,0),e.render(t,i),e.setRenderTarget(n,1),e.render(t,r),e.setRenderTarget(n,2),e.render(t,a),e.setRenderTarget(n,3),e.render(t,c),e.setRenderTarget(n,4),e.render(t,h),n.texture.generateMipmaps=f,e.setRenderTarget(n,5),e.render(t,u),e.setRenderTarget(p),e.xr.enabled=d}}class Rr extends zt{constructor(e,t,n,i,r,a,c,h,u,d){super(e=e!==void 0?e:[],t=t!==void 0?t:301,n,i,r,a,c=c!==void 0?c:1022,h,u,d),this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}Rr.prototype.isCubeTexture=!0;class ta extends $t{constructor(e,t,n){Number.isInteger(t)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),t=n),super(e,e,t),t=t||{},this.texture=new Rr(void 0,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=t.generateMipmaps!==void 0&&t.generateMipmaps,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:1006,this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.format=1023,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;let n={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},i=new vi(5,5,5),r=new xi({name:"CubemapFromEquirect",uniforms:Ar(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:1,blending:0});r.uniforms.tEquirect.value=t;let a=new en(i,r),c=t.minFilter;return t.minFilter===1008&&(t.minFilter=1006),new ea(1,10,this).update(e,a),t.minFilter=c,a.geometry.dispose(),a.material.dispose(),this}clear(e,t,n,i){let r=e.getRenderTarget();for(let a=0;a<6;a++)e.setRenderTarget(this,a),e.clear(t,n,i);e.setRenderTarget(r)}}ta.prototype.isWebGLCubeRenderTarget=!0;let wo=new L,op=new L,lp=new Nt;class ni{constructor(e=new L(1,0,0),t=0){this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,n,i){return this.normal.set(e,t,n),this.constant=i,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,n){let i=wo.subVectors(n,t).cross(op.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(i,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){let e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)}intersectLine(e,t){let n=e.delta(wo),i=this.normal.dot(n);if(i===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;let r=-(e.start.dot(this.normal)+this.constant)/i;return r<0||r>1?null:t.copy(n).multiplyScalar(r).add(e.start)}intersectsLine(e){let t=this.distanceToPoint(e.start),n=this.distanceToPoint(e.end);return t<0&&n>0||n<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){let n=t||lp.getNormalMatrix(e),i=this.coplanarPoint(wo).applyMatrix4(e),r=this.normal.applyMatrix3(n).normalize();return this.constant=-i.dot(r),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}ni.prototype.isPlane=!0;let Cr=new Ti,na=new L;class ss{constructor(e=new ni,t=new ni,n=new ni,i=new ni,r=new ni,a=new ni){this.planes=[e,t,n,i,r,a]}set(e,t,n,i,r,a){let c=this.planes;return c[0].copy(e),c[1].copy(t),c[2].copy(n),c[3].copy(i),c[4].copy(r),c[5].copy(a),this}copy(e){let t=this.planes;for(let n=0;n<6;n++)t[n].copy(e.planes[n]);return this}setFromProjectionMatrix(e){let t=this.planes,n=e.elements,i=n[0],r=n[1],a=n[2],c=n[3],h=n[4],u=n[5],d=n[6],p=n[7],f=n[8],m=n[9],g=n[10],y=n[11],x=n[12],v=n[13],w=n[14],A=n[15];return t[0].setComponents(c-i,p-h,y-f,A-x).normalize(),t[1].setComponents(c+i,p+h,y+f,A+x).normalize(),t[2].setComponents(c+r,p+u,y+m,A+v).normalize(),t[3].setComponents(c-r,p-u,y-m,A-v).normalize(),t[4].setComponents(c-a,p-d,y-g,A-w).normalize(),t[5].setComponents(c+a,p+d,y+g,A+w).normalize(),this}intersectsObject(e){let t=e.geometry;return t.boundingSphere===null&&t.computeBoundingSphere(),Cr.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(Cr)}intersectsSprite(e){return Cr.center.set(0,0,0),Cr.radius=.7071067811865476,Cr.applyMatrix4(e.matrixWorld),this.intersectsSphere(Cr)}intersectsSphere(e){let t=this.planes,n=e.center,i=-e.radius;for(let r=0;r<6;r++)if(t[r].distanceToPoint(n)<i)return!1;return!0}intersectsBox(e){let t=this.planes;for(let n=0;n<6;n++){let i=t[n];if(na.x=i.normal.x>0?e.max.x:e.min.x,na.y=i.normal.y>0?e.max.y:e.min.y,na.z=i.normal.z>0?e.max.z:e.min.z,i.distanceToPoint(na)<0)return!1}return!0}containsPoint(e){let t=this.planes;for(let n=0;n<6;n++)if(t[n].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function lc(){let s=null,e=!1,t=null,n=null;function i(r,a){t(r,a),n=s.requestAnimationFrame(i)}return{start:function(){e!==!0&&t!==null&&(n=s.requestAnimationFrame(i),e=!0)},stop:function(){s.cancelAnimationFrame(n),e=!1},setAnimationLoop:function(r){t=r},setContext:function(r){s=r}}}function cp(s,e){let t=e.isWebGL2,n=new WeakMap;return{get:function(i){return i.isInterleavedBufferAttribute&&(i=i.data),n.get(i)},remove:function(i){i.isInterleavedBufferAttribute&&(i=i.data);let r=n.get(i);r&&(s.deleteBuffer(r.buffer),n.delete(i))},update:function(i,r){if(i.isGLBufferAttribute){let c=n.get(i);return void((!c||c.version<i.version)&&n.set(i,{buffer:i.buffer,type:i.type,bytesPerElement:i.elementSize,version:i.version}))}i.isInterleavedBufferAttribute&&(i=i.data);let a=n.get(i);a===void 0?n.set(i,function(c,h){let u=c.array,d=c.usage,p=s.createBuffer();s.bindBuffer(h,p),s.bufferData(h,u,d),c.onUploadCallback();let f=5126;return u instanceof Float32Array?f=5126:u instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):u instanceof Uint16Array?c.isFloat16BufferAttribute?t?f=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):f=5123:u instanceof Int16Array?f=5122:u instanceof Uint32Array?f=5125:u instanceof Int32Array?f=5124:u instanceof Int8Array?f=5120:(u instanceof Uint8Array||u instanceof Uint8ClampedArray)&&(f=5121),{buffer:p,type:f,bytesPerElement:u.BYTES_PER_ELEMENT,version:c.version}}(i,r)):a.version<i.version&&(function(c,h,u){let d=h.array,p=h.updateRange;s.bindBuffer(u,c),p.count===-1?s.bufferSubData(u,0,d):(t?s.bufferSubData(u,p.offset*d.BYTES_PER_ELEMENT,d,p.offset,p.count):s.bufferSubData(u,p.offset*d.BYTES_PER_ELEMENT,d.subarray(p.offset,p.offset+p.count)),p.count=-1)}(a.buffer,i,r),a.version=i.version)}}}class qi extends st{constructor(e=1,t=1,n=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:n,heightSegments:i};let r=e/2,a=t/2,c=Math.floor(n),h=Math.floor(i),u=c+1,d=h+1,p=e/c,f=t/h,m=[],g=[],y=[],x=[];for(let v=0;v<d;v++){let w=v*f-a;for(let A=0;A<u;A++){let S=A*p-r;g.push(S,-w,0),y.push(0,0,1),x.push(A/c),x.push(1-v/h)}}for(let v=0;v<h;v++)for(let w=0;w<c;w++){let A=w+u*v,S=w+u*(v+1),D=w+1+u*(v+1),F=w+1+u*v;m.push(A,S,F),m.push(S,D,F)}this.setIndex(m),this.setAttribute("position",new Ue(g,3)),this.setAttribute("normal",new Ue(y,3)),this.setAttribute("uv",new Ue(x,2))}static fromJSON(e){return new qi(e.width,e.height,e.widthSegments,e.heightSegments)}}let ft={alphamap_fragment:`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,alphamap_pars_fragment:`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,alphatest_fragment:`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,alphatest_pars_fragment:`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,aomap_fragment:`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,aomap_pars_fragment:`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,bsdfs:`vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( incidentLight.direction + viewDir );
	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotVH = saturate( dot( geometry.viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float NoH ) {
	float invAlpha = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float NoV, float NoL ) {
	return saturate( 1.0 / ( 4.0 * ( NoL + NoV - NoL * NoV ) ) );
}
vec3 BRDF_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {
	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;
	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );
	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );
}
#endif`,bumpmap_pars_fragment:`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,clipping_planes_fragment:`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,clipping_planes_pars_fragment:`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,clipping_planes_pars_vertex:`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,clipping_planes_vertex:`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,color_fragment:`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,color_pars_fragment:`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,color_pars_vertex:`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,color_vertex:`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,common:`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,cube_uv_reflection_fragment:`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
		vec2 f = fract( uv );
		uv += 0.5 - f;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x += texelSize;
		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.y += texelSize;
		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x -= texelSize;
		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		vec3 tm = mix( tl, tr, f.x );
		vec3 bm = mix( bl, br, f.x );
		return mix( tm, bm, f.y );
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,defaultnormal_vertex:`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,displacementmap_pars_vertex:`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,displacementmap_vertex:`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,emissivemap_fragment:`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,emissivemap_pars_fragment:`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:`
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}`,envmap_fragment:`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
		envColor = envMapTexelToLinear( envColor );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,envmap_common_pars_fragment:`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,envmap_pars_fragment:`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,envmap_pars_vertex:`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,envmap_physical_pars_fragment:`#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getIBLIrradiance( const in GeometricContext geometry ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec;
			#ifdef ENVMAP_MODE_REFLECTION
				reflectVec = reflect( - viewDir, normal );
				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			#else
				reflectVec = refract( - viewDir, normal, refractionRatio );
			#endif
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,envmap_vertex:`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,fog_vertex:`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,fog_pars_vertex:`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,fog_fragment:`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,fog_pars_fragment:`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,gradientmap_pars_fragment:`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,lightmap_fragment:`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		lightMapIrradiance *= PI;
	#endif
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,lightmap_pars_fragment:`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,lights_lambert_vertex:`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
		#endif
	}
	#pragma unroll_loop_end
#endif`,lights_pars_begin:`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {
	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,lights_toon_fragment:`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,lights_toon_pars_fragment:`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,lights_phong_fragment:`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,lights_phong_pars_fragment:`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,lights_physical_fragment:`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularTintFactor = specularTint;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARTINTMAP
			specularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularTintFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenTint = sheenTint;
#endif`,lights_physical_pars_fragment:`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenTint;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(		0, 1,		0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += irradiance * BRDF_Sheen( material.roughness, directLight.direction, geometry, material.sheenTint );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,lights_fragment_begin:`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,lights_fragment_maps:`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,lights_fragment_end:`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,logdepthbuf_fragment:`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,logdepthbuf_pars_fragment:`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,logdepthbuf_pars_vertex:`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,logdepthbuf_vertex:`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,map_fragment:`#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`,map_pars_fragment:`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,map_particle_fragment:`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,map_particle_pars_fragment:`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,metalnessmap_fragment:`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,metalnessmap_pars_fragment:`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,morphnormal_vertex:`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
#endif`,morphtarget_pars_vertex:`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifndef USE_MORPHNORMALS
		uniform float morphTargetInfluences[ 8 ];
	#else
		uniform float morphTargetInfluences[ 4 ];
	#endif
#endif`,morphtarget_vertex:`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];
	#ifndef USE_MORPHNORMALS
		transformed += morphTarget4 * morphTargetInfluences[ 4 ];
		transformed += morphTarget5 * morphTargetInfluences[ 5 ];
		transformed += morphTarget6 * morphTargetInfluences[ 6 ];
		transformed += morphTarget7 * morphTargetInfluences[ 7 ];
	#endif
#endif`,normal_fragment_begin:`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,normal_fragment_maps:`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,normal_pars_fragment:`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,normal_pars_vertex:`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,normal_vertex:`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,normalmap_pars_fragment:`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,clearcoat_normal_fragment_begin:`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,clearcoat_normal_fragment_maps:`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,clearcoat_pars_fragment:`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,output_fragment:`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,packing:`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,premultiplied_alpha_fragment:`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,project_vertex:`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,dithering_fragment:`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,dithering_pars_fragment:`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,roughnessmap_fragment:`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,roughnessmap_pars_fragment:`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,shadowmap_pars_fragment:`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
							texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
							f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
							texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
							f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,shadowmap_pars_vertex:`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,shadowmap_vertex:`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,shadowmask_pars_fragment:`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,skinbase_vertex:`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,skinning_pars_vertex:`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,skinning_vertex:`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,skinnormal_vertex:`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,specularmap_fragment:`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,specularmap_pars_fragment:`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,tonemapping_fragment:`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,tonemapping_pars_fragment:`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(	1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,	1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,	1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,transmission_fragment:`#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationTint, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = transmission.a;
#endif`,transmission_pars_fragment:`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationTint;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( float roughness, float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef TEXTURE_LOD_EXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,
		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,
		vec3 attenuationColor, float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,uv_pars_fragment:`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,uv_pars_vertex:`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,uv_vertex:`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,uv2_pars_fragment:`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,uv2_pars_vertex:`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,uv2_vertex:`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,worldpos_vertex:`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,background_frag:`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,background_vert:`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,cube_frag:`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,cube_vert:`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,depth_frag:`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,depth_vert:`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,distanceRGBA_frag:`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,distanceRGBA_vert:`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,equirect_frag:`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,equirect_vert:`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,linedashed_frag:`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,linedashed_vert:`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,meshbasic_frag:`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshbasic_vert:`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,meshlambert_frag:`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshlambert_vert:`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,meshmatcap_frag:`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshmatcap_vert:`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,meshnormal_frag:`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`,meshnormal_vert:`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,meshphong_frag:`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshphong_vert:`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,meshphysical_frag:`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularTint;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARTINTMAP
		uniform sampler2D specularTintMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenTint;
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshphysical_vert:`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,meshtoon_frag:`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshtoon_vert:`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,points_frag:`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,points_vert:`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,shadow_frag:`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,shadow_vert:`#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,sprite_frag:`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,sprite_vert:`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`},Pe={common:{diffuse:{value:new De(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new Nt},uv2Transform:{value:new Nt},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new me(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new De(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new De(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Nt}},sprite:{diffuse:{value:new De(16777215)},opacity:{value:1},center:{value:new me(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Nt}}},jn={basic:{uniforms:un([Pe.common,Pe.specularmap,Pe.envmap,Pe.aomap,Pe.lightmap,Pe.fog]),vertexShader:ft.meshbasic_vert,fragmentShader:ft.meshbasic_frag},lambert:{uniforms:un([Pe.common,Pe.specularmap,Pe.envmap,Pe.aomap,Pe.lightmap,Pe.emissivemap,Pe.fog,Pe.lights,{emissive:{value:new De(0)}}]),vertexShader:ft.meshlambert_vert,fragmentShader:ft.meshlambert_frag},phong:{uniforms:un([Pe.common,Pe.specularmap,Pe.envmap,Pe.aomap,Pe.lightmap,Pe.emissivemap,Pe.bumpmap,Pe.normalmap,Pe.displacementmap,Pe.fog,Pe.lights,{emissive:{value:new De(0)},specular:{value:new De(1118481)},shininess:{value:30}}]),vertexShader:ft.meshphong_vert,fragmentShader:ft.meshphong_frag},standard:{uniforms:un([Pe.common,Pe.envmap,Pe.aomap,Pe.lightmap,Pe.emissivemap,Pe.bumpmap,Pe.normalmap,Pe.displacementmap,Pe.roughnessmap,Pe.metalnessmap,Pe.fog,Pe.lights,{emissive:{value:new De(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:ft.meshphysical_vert,fragmentShader:ft.meshphysical_frag},toon:{uniforms:un([Pe.common,Pe.aomap,Pe.lightmap,Pe.emissivemap,Pe.bumpmap,Pe.normalmap,Pe.displacementmap,Pe.gradientmap,Pe.fog,Pe.lights,{emissive:{value:new De(0)}}]),vertexShader:ft.meshtoon_vert,fragmentShader:ft.meshtoon_frag},matcap:{uniforms:un([Pe.common,Pe.bumpmap,Pe.normalmap,Pe.displacementmap,Pe.fog,{matcap:{value:null}}]),vertexShader:ft.meshmatcap_vert,fragmentShader:ft.meshmatcap_frag},points:{uniforms:un([Pe.points,Pe.fog]),vertexShader:ft.points_vert,fragmentShader:ft.points_frag},dashed:{uniforms:un([Pe.common,Pe.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:ft.linedashed_vert,fragmentShader:ft.linedashed_frag},depth:{uniforms:un([Pe.common,Pe.displacementmap]),vertexShader:ft.depth_vert,fragmentShader:ft.depth_frag},normal:{uniforms:un([Pe.common,Pe.bumpmap,Pe.normalmap,Pe.displacementmap,{opacity:{value:1}}]),vertexShader:ft.meshnormal_vert,fragmentShader:ft.meshnormal_frag},sprite:{uniforms:un([Pe.sprite,Pe.fog]),vertexShader:ft.sprite_vert,fragmentShader:ft.sprite_frag},background:{uniforms:{uvTransform:{value:new Nt},t2D:{value:null}},vertexShader:ft.background_vert,fragmentShader:ft.background_frag},cube:{uniforms:un([Pe.envmap,{opacity:{value:1}}]),vertexShader:ft.cube_vert,fragmentShader:ft.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:ft.equirect_vert,fragmentShader:ft.equirect_frag},distanceRGBA:{uniforms:un([Pe.common,Pe.displacementmap,{referencePosition:{value:new L},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:ft.distanceRGBA_vert,fragmentShader:ft.distanceRGBA_frag},shadow:{uniforms:un([Pe.lights,Pe.fog,{color:{value:new De(0)},opacity:{value:1}}]),vertexShader:ft.shadow_vert,fragmentShader:ft.shadow_frag}};function hp(s,e,t,n,i){let r=new De(0),a,c,h=0,u=null,d=0,p=null;function f(m,g){t.buffers.color.setClear(m.r,m.g,m.b,g,i)}return{getClearColor:function(){return r},setClearColor:function(m,g=1){r.set(m),h=g,f(r,h)},getClearAlpha:function(){return h},setClearAlpha:function(m){h=m,f(r,h)},render:function(m,g){let y=!1,x=g.isScene===!0?g.background:null;x&&x.isTexture&&(x=e.get(x));let v=s.xr,w=v.getSession&&v.getSession();w&&w.environmentBlendMode==="additive"&&(x=null),x===null?f(r,h):x&&x.isColor&&(f(x,1),y=!0),(s.autoClear||y)&&s.clear(s.autoClearColor,s.autoClearDepth,s.autoClearStencil),x&&(x.isCubeTexture||x.mapping===306)?(c===void 0&&(c=new en(new vi(1,1,1),new xi({name:"BackgroundCubeMaterial",uniforms:Ar(jn.cube.uniforms),vertexShader:jn.cube.vertexShader,fragmentShader:jn.cube.fragmentShader,side:1,depthTest:!1,depthWrite:!1,fog:!1})),c.geometry.deleteAttribute("normal"),c.geometry.deleteAttribute("uv"),c.onBeforeRender=function(A,S,D){this.matrixWorld.copyPosition(D.matrixWorld)},Object.defineProperty(c.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),n.update(c)),c.material.uniforms.envMap.value=x,c.material.uniforms.flipEnvMap.value=x.isCubeTexture&&x.isRenderTargetTexture===!1?-1:1,u===x&&d===x.version&&p===s.toneMapping||(c.material.needsUpdate=!0,u=x,d=x.version,p=s.toneMapping),m.unshift(c,c.geometry,c.material,0,0,null)):x&&x.isTexture&&(a===void 0&&(a=new en(new qi(2,2),new xi({name:"BackgroundMaterial",uniforms:Ar(jn.background.uniforms),vertexShader:jn.background.vertexShader,fragmentShader:jn.background.fragmentShader,side:0,depthTest:!1,depthWrite:!1,fog:!1})),a.geometry.deleteAttribute("normal"),Object.defineProperty(a.material,"map",{get:function(){return this.uniforms.t2D.value}}),n.update(a)),a.material.uniforms.t2D.value=x,x.matrixAutoUpdate===!0&&x.updateMatrix(),a.material.uniforms.uvTransform.value.copy(x.matrix),u===x&&d===x.version&&p===s.toneMapping||(a.material.needsUpdate=!0,u=x,d=x.version,p=s.toneMapping),m.unshift(a,a.geometry,a.material,0,0,null))}}}function up(s,e,t,n){let i=s.getParameter(34921),r=n.isWebGL2?null:e.get("OES_vertex_array_object"),a=n.isWebGL2||r!==null,c={},h=f(null),u=h;function d(S){return n.isWebGL2?s.bindVertexArray(S):r.bindVertexArrayOES(S)}function p(S){return n.isWebGL2?s.deleteVertexArray(S):r.deleteVertexArrayOES(S)}function f(S){let D=[],F=[],q=[];for(let X=0;X<i;X++)D[X]=0,F[X]=0,q[X]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:D,enabledAttributes:F,attributeDivisors:q,object:S,attributes:{},index:null}}function m(){let S=u.newAttributes;for(let D=0,F=S.length;D<F;D++)S[D]=0}function g(S){y(S,0)}function y(S,D){let F=u.newAttributes,q=u.enabledAttributes,X=u.attributeDivisors;F[S]=1,q[S]===0&&(s.enableVertexAttribArray(S),q[S]=1),X[S]!==D&&((n.isWebGL2?s:e.get("ANGLE_instanced_arrays"))[n.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](S,D),X[S]=D)}function x(){let S=u.newAttributes,D=u.enabledAttributes;for(let F=0,q=D.length;F<q;F++)D[F]!==S[F]&&(s.disableVertexAttribArray(F),D[F]=0)}function v(S,D,F,q,X,te){n.isWebGL2!==!0||F!==5124&&F!==5125?s.vertexAttribPointer(S,D,F,q,X,te):s.vertexAttribIPointer(S,D,F,X,te)}function w(){A(),u!==h&&(u=h,d(u.object))}function A(){h.geometry=null,h.program=null,h.wireframe=!1}return{setup:function(S,D,F,q,X){let te=!1;if(a){let J=function($,Re,ye){let ae=ye.wireframe===!0,be=c[$.id];be===void 0&&(be={},c[$.id]=be);let Ce=be[Re.id];Ce===void 0&&(Ce={},be[Re.id]=Ce);let Ie=Ce[ae];return Ie===void 0&&(Ie=f(n.isWebGL2?s.createVertexArray():r.createVertexArrayOES()),Ce[ae]=Ie),Ie}(q,F,D);u!==J&&(u=J,d(u.object)),te=function($,Re){let ye=u.attributes,ae=$.attributes,be=0;for(let Ce in ae){let Ie=ye[Ce],ke=ae[Ce];if(Ie===void 0||Ie.attribute!==ke||Ie.data!==ke.data)return!0;be++}return u.attributesNum!==be||u.index!==Re}(q,X),te&&function($,Re){let ye={},ae=$.attributes,be=0;for(let Ce in ae){let Ie=ae[Ce],ke={};ke.attribute=Ie,Ie.data&&(ke.data=Ie.data),ye[Ce]=ke,be++}u.attributes=ye,u.attributesNum=be,u.index=Re}(q,X)}else{let J=D.wireframe===!0;u.geometry===q.id&&u.program===F.id&&u.wireframe===J||(u.geometry=q.id,u.program=F.id,u.wireframe=J,te=!0)}S.isInstancedMesh===!0&&(te=!0),X!==null&&t.update(X,34963),te&&(function(J,$,Re,ye){if(n.isWebGL2===!1&&(J.isInstancedMesh||ye.isInstancedBufferGeometry)&&e.get("ANGLE_instanced_arrays")===null)return;m();let ae=ye.attributes,be=Re.getAttributes(),Ce=$.defaultAttributeValues;for(let Ie in be){let ke=be[Ie];if(ke.location>=0){let $e=ae[Ie];if($e===void 0&&(Ie==="instanceMatrix"&&J.instanceMatrix&&($e=J.instanceMatrix),Ie==="instanceColor"&&J.instanceColor&&($e=J.instanceColor)),$e!==void 0){let et=$e.normalized,_e=$e.itemSize,O=t.get($e);if(O===void 0)continue;let B=O.buffer,ce=O.type,se=O.bytesPerElement;if($e.isInterleavedBufferAttribute){let ee=$e.data,Le=ee.stride,Ee=$e.offset;if(ee&&ee.isInstancedInterleavedBuffer){for(let ne=0;ne<ke.locationSize;ne++)y(ke.location+ne,ee.meshPerAttribute);J.isInstancedMesh!==!0&&ye._maxInstanceCount===void 0&&(ye._maxInstanceCount=ee.meshPerAttribute*ee.count)}else for(let ne=0;ne<ke.locationSize;ne++)g(ke.location+ne);s.bindBuffer(34962,B);for(let ne=0;ne<ke.locationSize;ne++)v(ke.location+ne,_e/ke.locationSize,ce,et,Le*se,(Ee+_e/ke.locationSize*ne)*se)}else{if($e.isInstancedBufferAttribute){for(let ee=0;ee<ke.locationSize;ee++)y(ke.location+ee,$e.meshPerAttribute);J.isInstancedMesh!==!0&&ye._maxInstanceCount===void 0&&(ye._maxInstanceCount=$e.meshPerAttribute*$e.count)}else for(let ee=0;ee<ke.locationSize;ee++)g(ke.location+ee);s.bindBuffer(34962,B);for(let ee=0;ee<ke.locationSize;ee++)v(ke.location+ee,_e/ke.locationSize,ce,et,_e*se,_e/ke.locationSize*ee*se)}}else if(Ce!==void 0){let et=Ce[Ie];if(et!==void 0)switch(et.length){case 2:s.vertexAttrib2fv(ke.location,et);break;case 3:s.vertexAttrib3fv(ke.location,et);break;case 4:s.vertexAttrib4fv(ke.location,et);break;default:s.vertexAttrib1fv(ke.location,et)}}}}x()}(S,D,F,q),X!==null&&s.bindBuffer(34963,t.get(X).buffer))},reset:w,resetDefaultState:A,dispose:function(){w();for(let S in c){let D=c[S];for(let F in D){let q=D[F];for(let X in q)p(q[X].object),delete q[X];delete D[F]}delete c[S]}},releaseStatesOfGeometry:function(S){if(c[S.id]===void 0)return;let D=c[S.id];for(let F in D){let q=D[F];for(let X in q)p(q[X].object),delete q[X];delete D[F]}delete c[S.id]},releaseStatesOfProgram:function(S){for(let D in c){let F=c[D];if(F[S.id]===void 0)continue;let q=F[S.id];for(let X in q)p(q[X].object),delete q[X];delete F[S.id]}},initAttributes:m,enableAttribute:g,disableUnusedAttributes:x}}function dp(s,e,t,n){let i=n.isWebGL2,r;this.setMode=function(a){r=a},this.render=function(a,c){s.drawArrays(r,a,c),t.update(c,r,1)},this.renderInstances=function(a,c,h){if(h===0)return;let u,d;if(i)u=s,d="drawArraysInstanced";else if(u=e.get("ANGLE_instanced_arrays"),d="drawArraysInstancedANGLE",u===null)return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");u[d](r,a,c,h),t.update(c,r,h)}}function pp(s,e,t){let n;function i(S){if(S==="highp"){if(s.getShaderPrecisionFormat(35633,36338).precision>0&&s.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";S="mediump"}return S==="mediump"&&s.getShaderPrecisionFormat(35633,36337).precision>0&&s.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}let r=typeof WebGL2RenderingContext<"u"&&s instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext<"u"&&s instanceof WebGL2ComputeRenderingContext,a=t.precision!==void 0?t.precision:"highp",c=i(a);c!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",c,"instead."),a=c);let h=r||e.has("WEBGL_draw_buffers"),u=t.logarithmicDepthBuffer===!0,d=s.getParameter(34930),p=s.getParameter(35660),f=s.getParameter(3379),m=s.getParameter(34076),g=s.getParameter(34921),y=s.getParameter(36347),x=s.getParameter(36348),v=s.getParameter(36349),w=p>0,A=r||e.has("OES_texture_float");return{isWebGL2:r,drawBuffers:h,getMaxAnisotropy:function(){if(n!==void 0)return n;if(e.has("EXT_texture_filter_anisotropic")===!0){let S=e.get("EXT_texture_filter_anisotropic");n=s.getParameter(S.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else n=0;return n},getMaxPrecision:i,precision:a,logarithmicDepthBuffer:u,maxTextures:d,maxVertexTextures:p,maxTextureSize:f,maxCubemapSize:m,maxAttributes:g,maxVertexUniforms:y,maxVaryings:x,maxFragmentUniforms:v,vertexTextures:w,floatFragmentTextures:A,floatVertexTextures:w&&A,maxSamples:r?s.getParameter(36183):0}}function fp(s){let e=this,t=null,n=0,i=!1,r=!1,a=new ni,c=new Nt,h={value:null,needsUpdate:!1};function u(){h.value!==t&&(h.value=t,h.needsUpdate=n>0),e.numPlanes=n,e.numIntersection=0}function d(p,f,m,g){let y=p!==null?p.length:0,x=null;if(y!==0){if(x=h.value,g!==!0||x===null){let v=m+4*y,w=f.matrixWorldInverse;c.getNormalMatrix(w),(x===null||x.length<v)&&(x=new Float32Array(v));for(let A=0,S=m;A!==y;++A,S+=4)a.copy(p[A]).applyMatrix4(w,c),a.normal.toArray(x,S),x[S+3]=a.constant}h.value=x,h.needsUpdate=!0}return e.numPlanes=y,e.numIntersection=0,x}this.uniform=h,this.numPlanes=0,this.numIntersection=0,this.init=function(p,f,m){let g=p.length!==0||f||n!==0||i;return i=f,t=d(p,m,0),n=p.length,g},this.beginShadows=function(){r=!0,d(null)},this.endShadows=function(){r=!1,u()},this.setState=function(p,f,m){let g=p.clippingPlanes,y=p.clipIntersection,x=p.clipShadows,v=s.get(p);if(!i||g===null||g.length===0||r&&!x)r?d(null):u();else{let w=r?0:n,A=4*w,S=v.clippingState||null;h.value=S,S=d(g,f,A,m);for(let D=0;D!==A;++D)S[D]=t[D];v.clippingState=S,this.numIntersection=y?this.numPlanes:0,this.numPlanes+=w}}}function mp(s){let e=new WeakMap;function t(i,r){return r===303?i.mapping=301:r===304&&(i.mapping=302),i}function n(i){let r=i.target;r.removeEventListener("dispose",n);let a=e.get(r);a!==void 0&&(e.delete(r),a.dispose())}return{get:function(i){if(i&&i.isTexture&&i.isRenderTargetTexture===!1){let r=i.mapping;if(r===303||r===304){if(e.has(i))return t(e.get(i).texture,i.mapping);{let a=i.image;if(a&&a.height>0){let c=s.getRenderTarget(),h=new ta(a.height/2);return h.fromEquirectangularTexture(s,i),e.set(i,h),s.setRenderTarget(c),i.addEventListener("dispose",n),t(h.texture,i.mapping)}return null}}}return i},dispose:function(){e=new WeakMap}}}jn.physical={uniforms:un([jn.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new me(1,1)},clearcoatNormalMap:{value:null},sheenTint:{value:new De(0)},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new me},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationTint:{value:new De(0)},specularIntensity:{value:0},specularIntensityMap:{value:null},specularTint:{value:new De(1,1,1)},specularTintMap:{value:null}}]),vertexShader:ft.meshphysical_vert,fragmentShader:ft.meshphysical_frag};class as extends rs{constructor(e=-1,t=1,n=1,i=-1,r=.1,a=2e3){super(),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=n,this.bottom=i,this.near=r,this.far=a,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,n,i,r,a){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){let e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,i=(this.top+this.bottom)/2,r=n-e,a=n+e,c=i+t,h=i-t;if(this.view!==null&&this.view.enabled){let u=(this.right-this.left)/this.view.fullWidth/this.zoom,d=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=u*this.view.offsetX,a=r+u*this.view.width,c-=d*this.view.offsetY,h=c-d*this.view.height}this.projectionMatrix.makeOrthographic(r,a,c,h,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){let t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}as.prototype.isOrthographicCamera=!0;class Pr extends xi{constructor(e){super(e),this.type="RawShaderMaterial"}}Pr.prototype.isRawShaderMaterial=!0;let ii=Math.pow(2,8),cc=[.125,.215,.35,.446,.526,.582],hc=5+cc.length,ia=20,ri={3e3:0,3001:1,3002:2,3004:3,3005:4,3006:5,3007:6},So=new as,{_lodPlanes:os,_sizeLods:uc,_sigmas:ra}=yp(),dc=new De,To=null,ji=(1+Math.sqrt(5))/2,Dr=1/ji,pc=[new L(1,1,1),new L(-1,1,1),new L(1,1,-1),new L(-1,1,-1),new L(0,ji,Dr),new L(0,ji,-Dr),new L(Dr,0,ji),new L(-Dr,0,ji),new L(ji,Dr,0),new L(-ji,Dr,0)];class fc{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._blurMaterial=function(t){let n=new Float32Array(t),i=new L(0,1,0);return new Pr({name:"SphericalGaussianBlur",defines:{n:t},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:n},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:i},inputEncoding:{value:ri[3e3]},outputEncoding:{value:ri[3e3]}},vertexShader:Eo(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${Ao()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:0,depthTest:!1,depthWrite:!1})}(ia),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,n=.1,i=100){To=this._renderer.getRenderTarget();let r=this._allocateTargets();return this._sceneToCubeUV(e,n,i,r),t>0&&this._blur(r,0,0,t),this._applyPMREM(r),this._cleanup(r),r}fromEquirectangular(e){return this._fromTexture(e)}fromCubemap(e){return this._fromTexture(e)}compileCubemapShader(){this._cubemapShader===null&&(this._cubemapShader=yc(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){this._equirectShader===null&&(this._equirectShader=gc(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),this._cubemapShader!==null&&this._cubemapShader.dispose(),this._equirectShader!==null&&this._equirectShader.dispose();for(let e=0;e<os.length;e++)os[e].dispose()}_cleanup(e){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(To),e.scissorTest=!1,sa(e,0,0,e.width,e.height)}_fromTexture(e){To=this._renderer.getRenderTarget();let t=this._allocateTargets(e);return this._textureToCubeUV(e,t),this._applyPMREM(t),this._cleanup(t),t}_allocateTargets(e){let t={magFilter:1003,minFilter:1003,generateMipmaps:!1,type:1009,format:1023,encoding:gp(e)?e.encoding:3002,depthBuffer:!1},n=mc(t);return n.depthBuffer=!e,this._pingPongRenderTarget=mc(t),n}_compileMaterial(e){let t=new en(os[0],e);this._renderer.compile(t,So)}_sceneToCubeUV(e,t,n,i){let r=new sn(90,1,t,n),a=[1,-1,1,1,1,1],c=[1,1,1,-1,-1,-1],h=this._renderer,u=h.autoClear,d=h.outputEncoding,p=h.toneMapping;h.getClearColor(dc),h.toneMapping=0,h.outputEncoding=3e3,h.autoClear=!1;let f=new yi({name:"PMREM.Background",side:1,depthWrite:!1,depthTest:!1}),m=new en(new vi,f),g=!1,y=e.background;y?y.isColor&&(f.color.copy(y),e.background=null,g=!0):(f.color.copy(dc),g=!0);for(let x=0;x<6;x++){let v=x%3;v==0?(r.up.set(0,a[x],0),r.lookAt(c[x],0,0)):v==1?(r.up.set(0,0,a[x]),r.lookAt(0,c[x],0)):(r.up.set(0,a[x],0),r.lookAt(0,0,c[x])),sa(i,v*ii,x>2?ii:0,ii,ii),h.setRenderTarget(i),g&&h.render(m,r),h.render(e,r)}m.geometry.dispose(),m.material.dispose(),h.toneMapping=p,h.outputEncoding=d,h.autoClear=u,e.background=y}_textureToCubeUV(e,t){let n=this._renderer;e.isCubeTexture?this._cubemapShader==null&&(this._cubemapShader=yc()):this._equirectShader==null&&(this._equirectShader=gc());let i=e.isCubeTexture?this._cubemapShader:this._equirectShader,r=new en(os[0],i),a=i.uniforms;a.envMap.value=e,e.isCubeTexture||a.texelSize.value.set(1/e.image.width,1/e.image.height),a.inputEncoding.value=ri[e.encoding],a.outputEncoding.value=ri[t.texture.encoding],sa(t,0,0,3*ii,2*ii),n.setRenderTarget(t),n.render(r,So)}_applyPMREM(e){let t=this._renderer,n=t.autoClear;t.autoClear=!1;for(let i=1;i<hc;i++){let r=Math.sqrt(ra[i]*ra[i]-ra[i-1]*ra[i-1]),a=pc[(i-1)%pc.length];this._blur(e,i-1,i,r,a)}t.autoClear=n}_blur(e,t,n,i,r){let a=this._pingPongRenderTarget;this._halfBlur(e,a,t,n,i,"latitudinal",r),this._halfBlur(a,e,n,n,i,"longitudinal",r)}_halfBlur(e,t,n,i,r,a,c){let h=this._renderer,u=this._blurMaterial;a!=="latitudinal"&&a!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");let d=new en(os[i],u),p=u.uniforms,f=uc[n]-1,m=isFinite(r)?Math.PI/(2*f):2*Math.PI/39,g=r/m,y=isFinite(r)?1+Math.floor(3*g):ia;y>ia&&console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${y} samples when the maximum is set to 20`);let x=[],v=0;for(let A=0;A<ia;++A){let S=A/g,D=Math.exp(-S*S/2);x.push(D),A==0?v+=D:A<y&&(v+=2*D)}for(let A=0;A<x.length;A++)x[A]=x[A]/v;p.envMap.value=e.texture,p.samples.value=y,p.weights.value=x,p.latitudinal.value=a==="latitudinal",c&&(p.poleAxis.value=c),p.dTheta.value=m,p.mipInt.value=8-n,p.inputEncoding.value=ri[e.texture.encoding],p.outputEncoding.value=ri[e.texture.encoding];let w=uc[i];sa(t,3*Math.max(0,ii-2*w),(i===0?0:2*ii)+2*w*(i>4?i-8+4:0),3*w,2*w),h.setRenderTarget(t),h.render(d,So)}}function gp(s){return s!==void 0&&s.type===1009&&(s.encoding===3e3||s.encoding===3001||s.encoding===3007)}function yp(){let s=[],e=[],t=[],n=8;for(let i=0;i<hc;i++){let r=Math.pow(2,n);e.push(r);let a=1/r;i>4?a=cc[i-8+4-1]:i==0&&(a=0),t.push(a);let c=1/(r-1),h=-c/2,u=1+c/2,d=[h,h,u,h,u,u,h,h,u,u,h,u],p=6,f=6,m=3,g=2,y=1,x=new Float32Array(m*f*p),v=new Float32Array(g*f*p),w=new Float32Array(y*f*p);for(let S=0;S<p;S++){let D=S%3*2/3-1,F=S>2?0:-1,q=[D,F,0,D+2/3,F,0,D+2/3,F+1,0,D,F,0,D+2/3,F+1,0,D,F+1,0];x.set(q,m*f*S),v.set(d,g*f*S);let X=[S,S,S,S,S,S];w.set(X,y*f*S)}let A=new st;A.setAttribute("position",new bt(x,m)),A.setAttribute("uv",new bt(v,g)),A.setAttribute("faceIndex",new bt(w,y)),s.push(A),n>4&&n--}return{_lodPlanes:s,_sizeLods:e,_sigmas:t}}function mc(s){let e=new $t(3*ii,3*ii,s);return e.texture.mapping=306,e.texture.name="PMREM.cubeUv",e.scissorTest=!0,e}function sa(s,e,t,n,i){s.viewport.set(e,t,n,i),s.scissor.set(e,t,n,i)}function gc(){let s=new me(1,1);return new Pr({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:s},inputEncoding:{value:ri[3e3]},outputEncoding:{value:ri[3e3]}},vertexShader:Eo(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${Ao()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:0,depthTest:!1,depthWrite:!1})}function yc(){return new Pr({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:ri[3e3]},outputEncoding:{value:ri[3e3]}},vertexShader:Eo(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${Ao()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:0,depthTest:!1,depthWrite:!1})}function Eo(){return`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function Ao(){return`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`}function vp(s){let e=new WeakMap,t=null;function n(i){let r=i.target;r.removeEventListener("dispose",n);let a=e.get(r);a!==void 0&&(e.delete(r),a.dispose())}return{get:function(i){if(i&&i.isTexture&&i.isRenderTargetTexture===!1){let r=i.mapping,a=r===303||r===304,c=r===301||r===302;if(a||c){if(e.has(i))return e.get(i).texture;{let h=i.image;if(a&&h&&h.height>0||c&&h&&function(u){let d=0,p=6;for(let f=0;f<p;f++)u[f]!==void 0&&d++;return d===p}(h)){let u=s.getRenderTarget();t===null&&(t=new fc(s));let d=a?t.fromEquirectangular(i):t.fromCubemap(i);return e.set(i,d),s.setRenderTarget(u),i.addEventListener("dispose",n),d.texture}return null}}}return i},dispose:function(){e=new WeakMap,t!==null&&(t.dispose(),t=null)}}}function xp(s){let e={};function t(n){if(e[n]!==void 0)return e[n];let i;switch(n){case"WEBGL_depth_texture":i=s.getExtension("WEBGL_depth_texture")||s.getExtension("MOZ_WEBGL_depth_texture")||s.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=s.getExtension("EXT_texture_filter_anisotropic")||s.getExtension("MOZ_EXT_texture_filter_anisotropic")||s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=s.getExtension("WEBGL_compressed_texture_s3tc")||s.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=s.getExtension("WEBGL_compressed_texture_pvrtc")||s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=s.getExtension(n)}return e[n]=i,i}return{has:function(n){return t(n)!==null},init:function(n){n.isWebGL2?t("EXT_color_buffer_float"):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float")},get:function(n){let i=t(n);return i===null&&console.warn("THREE.WebGLRenderer: "+n+" extension not supported."),i}}}function _p(s,e,t,n){let i={},r=new WeakMap;function a(h){let u=h.target;u.index!==null&&e.remove(u.index);for(let p in u.attributes)e.remove(u.attributes[p]);u.removeEventListener("dispose",a),delete i[u.id];let d=r.get(u);d&&(e.remove(d),r.delete(u)),n.releaseStatesOfGeometry(u),u.isInstancedBufferGeometry===!0&&delete u._maxInstanceCount,t.memory.geometries--}function c(h){let u=[],d=h.index,p=h.attributes.position,f=0;if(d!==null){let y=d.array;f=d.version;for(let x=0,v=y.length;x<v;x+=3){let w=y[x+0],A=y[x+1],S=y[x+2];u.push(w,A,A,S,S,w)}}else{let y=p.array;f=p.version;for(let x=0,v=y.length/3-1;x<v;x+=3){let w=x+0,A=x+1,S=x+2;u.push(w,A,A,S,S,w)}}let m=new(sc(u)>65535?qs:Ws)(u,1);m.version=f;let g=r.get(h);g&&e.remove(g),r.set(h,m)}return{get:function(h,u){return i[u.id]===!0||(u.addEventListener("dispose",a),i[u.id]=!0,t.memory.geometries++),u},update:function(h){let u=h.attributes;for(let p in u)e.update(u[p],34962);let d=h.morphAttributes;for(let p in d){let f=d[p];for(let m=0,g=f.length;m<g;m++)e.update(f[m],34962)}},getWireframeAttribute:function(h){let u=r.get(h);if(u){let d=h.index;d!==null&&u.version<d.version&&c(h)}else c(h);return r.get(h)}}}function bp(s,e,t,n){let i=n.isWebGL2,r,a,c;this.setMode=function(h){r=h},this.setIndex=function(h){a=h.type,c=h.bytesPerElement},this.render=function(h,u){s.drawElements(r,u,a,h*c),t.update(u,r,1)},this.renderInstances=function(h,u,d){if(d===0)return;let p,f;if(i)p=s,f="drawElementsInstanced";else if(p=e.get("ANGLE_instanced_arrays"),f="drawElementsInstancedANGLE",p===null)return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");p[f](r,u,a,h*c,d),t.update(u,r,d)}}function Mp(s){let e={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:e,programs:null,autoReset:!0,reset:function(){e.frame++,e.calls=0,e.triangles=0,e.points=0,e.lines=0},update:function(t,n,i){switch(e.calls++,n){case 4:e.triangles+=i*(t/3);break;case 1:e.lines+=i*(t/2);break;case 3:e.lines+=i*(t-1);break;case 2:e.lines+=i*t;break;case 0:e.points+=i*t;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",n)}}}}function wp(s,e){return s[0]-e[0]}function Sp(s,e){return Math.abs(e[1])-Math.abs(s[1])}function Tp(s){let e={},t=new Float32Array(8),n=[];for(let i=0;i<8;i++)n[i]=[i,0];return{update:function(i,r,a,c){let h=i.morphTargetInfluences,u=h===void 0?0:h.length,d=e[r.id];if(d===void 0||d.length!==u){d=[];for(let y=0;y<u;y++)d[y]=[y,0];e[r.id]=d}for(let y=0;y<u;y++){let x=d[y];x[0]=y,x[1]=h[y]}d.sort(Sp);for(let y=0;y<8;y++)y<u&&d[y][1]?(n[y][0]=d[y][0],n[y][1]=d[y][1]):(n[y][0]=Number.MAX_SAFE_INTEGER,n[y][1]=0);n.sort(wp);let p=r.morphAttributes.position,f=r.morphAttributes.normal,m=0;for(let y=0;y<8;y++){let x=n[y],v=x[0],w=x[1];v!==Number.MAX_SAFE_INTEGER&&w?(p&&r.getAttribute("morphTarget"+y)!==p[v]&&r.setAttribute("morphTarget"+y,p[v]),f&&r.getAttribute("morphNormal"+y)!==f[v]&&r.setAttribute("morphNormal"+y,f[v]),t[y]=w,m+=w):(p&&r.hasAttribute("morphTarget"+y)===!0&&r.deleteAttribute("morphTarget"+y),f&&r.hasAttribute("morphNormal"+y)===!0&&r.deleteAttribute("morphNormal"+y),t[y]=0)}let g=r.morphTargetsRelative?1:1-m;c.getUniforms().setValue(s,"morphTargetBaseInfluence",g),c.getUniforms().setValue(s,"morphTargetInfluences",t)}}}function Ep(s,e,t,n){let i=new WeakMap;function r(a){let c=a.target;c.removeEventListener("dispose",r),t.remove(c.instanceMatrix),c.instanceColor!==null&&t.remove(c.instanceColor)}return{update:function(a){let c=n.render.frame,h=a.geometry,u=e.get(a,h);return i.get(u)!==c&&(e.update(u),i.set(u,c)),a.isInstancedMesh&&(a.hasEventListener("dispose",r)===!1&&a.addEventListener("dispose",r),t.update(a.instanceMatrix,34962),a.instanceColor!==null&&t.update(a.instanceColor,34962)),u},dispose:function(){i=new WeakMap}}}class Lo extends zt{constructor(e=null,t=1,n=1,i=1){super(null),this.image={data:e,width:t,height:n,depth:i},this.magFilter=1003,this.minFilter=1003,this.wrapR=1001,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Lo.prototype.isDataTexture2DArray=!0;class Ro extends zt{constructor(e=null,t=1,n=1,i=1){super(null),this.image={data:e,width:t,height:n,depth:i},this.magFilter=1003,this.minFilter=1003,this.wrapR=1001,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Ro.prototype.isDataTexture3D=!0;let vc=new zt,Ap=new Lo,Lp=new Ro,xc=new Rr,_c=[],bc=[],Mc=new Float32Array(16),wc=new Float32Array(9),Sc=new Float32Array(4);function Ir(s,e,t){let n=s[0];if(n<=0||n>0)return s;let i=e*t,r=_c[i];if(r===void 0&&(r=new Float32Array(i),_c[i]=r),e!==0){n.toArray(r,0);for(let a=1,c=0;a!==e;++a)c+=t,s[a].toArray(r,c)}return r}function _n(s,e){if(s.length!==e.length)return!1;for(let t=0,n=s.length;t<n;t++)if(s[t]!==e[t])return!1;return!0}function dn(s,e){for(let t=0,n=e.length;t<n;t++)s[t]=e[t]}function Tc(s,e){let t=bc[e];t===void 0&&(t=new Int32Array(e),bc[e]=t);for(let n=0;n!==e;++n)t[n]=s.allocateTextureUnit();return t}function Rp(s,e){let t=this.cache;t[0]!==e&&(s.uniform1f(this.addr,e),t[0]=e)}function Cp(s,e){let t=this.cache;if(e.x!==void 0)t[0]===e.x&&t[1]===e.y||(s.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(_n(t,e))return;s.uniform2fv(this.addr,e),dn(t,e)}}function Pp(s,e){let t=this.cache;if(e.x!==void 0)t[0]===e.x&&t[1]===e.y&&t[2]===e.z||(s.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)t[0]===e.r&&t[1]===e.g&&t[2]===e.b||(s.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(_n(t,e))return;s.uniform3fv(this.addr,e),dn(t,e)}}function Dp(s,e){let t=this.cache;if(e.x!==void 0)t[0]===e.x&&t[1]===e.y&&t[2]===e.z&&t[3]===e.w||(s.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(_n(t,e))return;s.uniform4fv(this.addr,e),dn(t,e)}}function Ip(s,e){let t=this.cache,n=e.elements;if(n===void 0){if(_n(t,e))return;s.uniformMatrix2fv(this.addr,!1,e),dn(t,e)}else{if(_n(t,n))return;Sc.set(n),s.uniformMatrix2fv(this.addr,!1,Sc),dn(t,n)}}function Op(s,e){let t=this.cache,n=e.elements;if(n===void 0){if(_n(t,e))return;s.uniformMatrix3fv(this.addr,!1,e),dn(t,e)}else{if(_n(t,n))return;wc.set(n),s.uniformMatrix3fv(this.addr,!1,wc),dn(t,n)}}function Fp(s,e){let t=this.cache,n=e.elements;if(n===void 0){if(_n(t,e))return;s.uniformMatrix4fv(this.addr,!1,e),dn(t,e)}else{if(_n(t,n))return;Mc.set(n),s.uniformMatrix4fv(this.addr,!1,Mc),dn(t,n)}}function Np(s,e){let t=this.cache;t[0]!==e&&(s.uniform1i(this.addr,e),t[0]=e)}function zp(s,e){let t=this.cache;_n(t,e)||(s.uniform2iv(this.addr,e),dn(t,e))}function Bp(s,e){let t=this.cache;_n(t,e)||(s.uniform3iv(this.addr,e),dn(t,e))}function Hp(s,e){let t=this.cache;_n(t,e)||(s.uniform4iv(this.addr,e),dn(t,e))}function Up(s,e){let t=this.cache;t[0]!==e&&(s.uniform1ui(this.addr,e),t[0]=e)}function Gp(s,e){let t=this.cache;_n(t,e)||(s.uniform2uiv(this.addr,e),dn(t,e))}function kp(s,e){let t=this.cache;_n(t,e)||(s.uniform3uiv(this.addr,e),dn(t,e))}function Vp(s,e){let t=this.cache;_n(t,e)||(s.uniform4uiv(this.addr,e),dn(t,e))}function Wp(s,e,t){let n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(s.uniform1i(this.addr,i),n[0]=i),t.safeSetTexture2D(e||vc,i)}function qp(s,e,t){let n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(s.uniform1i(this.addr,i),n[0]=i),t.setTexture3D(e||Lp,i)}function jp(s,e,t){let n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(s.uniform1i(this.addr,i),n[0]=i),t.safeSetTextureCube(e||xc,i)}function Xp(s,e,t){let n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(s.uniform1i(this.addr,i),n[0]=i),t.setTexture2DArray(e||Ap,i)}function Zp(s,e){s.uniform1fv(this.addr,e)}function Yp(s,e){let t=Ir(e,this.size,2);s.uniform2fv(this.addr,t)}function Jp(s,e){let t=Ir(e,this.size,3);s.uniform3fv(this.addr,t)}function Kp(s,e){let t=Ir(e,this.size,4);s.uniform4fv(this.addr,t)}function Qp(s,e){let t=Ir(e,this.size,4);s.uniformMatrix2fv(this.addr,!1,t)}function $p(s,e){let t=Ir(e,this.size,9);s.uniformMatrix3fv(this.addr,!1,t)}function ef(s,e){let t=Ir(e,this.size,16);s.uniformMatrix4fv(this.addr,!1,t)}function tf(s,e){s.uniform1iv(this.addr,e)}function nf(s,e){s.uniform2iv(this.addr,e)}function rf(s,e){s.uniform3iv(this.addr,e)}function sf(s,e){s.uniform4iv(this.addr,e)}function af(s,e){s.uniform1uiv(this.addr,e)}function of(s,e){s.uniform2uiv(this.addr,e)}function lf(s,e){s.uniform3uiv(this.addr,e)}function cf(s,e){s.uniform4uiv(this.addr,e)}function hf(s,e,t){let n=e.length,i=Tc(t,n);s.uniform1iv(this.addr,i);for(let r=0;r!==n;++r)t.safeSetTexture2D(e[r]||vc,i[r])}function uf(s,e,t){let n=e.length,i=Tc(t,n);s.uniform1iv(this.addr,i);for(let r=0;r!==n;++r)t.safeSetTextureCube(e[r]||xc,i[r])}function df(s,e,t){this.id=s,this.addr=t,this.cache=[],this.setValue=function(n){switch(n){case 5126:return Rp;case 35664:return Cp;case 35665:return Pp;case 35666:return Dp;case 35674:return Ip;case 35675:return Op;case 35676:return Fp;case 5124:case 35670:return Np;case 35667:case 35671:return zp;case 35668:case 35672:return Bp;case 35669:case 35673:return Hp;case 5125:return Up;case 36294:return Gp;case 36295:return kp;case 36296:return Vp;case 35678:case 36198:case 36298:case 36306:case 35682:return Wp;case 35679:case 36299:case 36307:return qp;case 35680:case 36300:case 36308:case 36293:return jp;case 36289:case 36303:case 36311:case 36292:return Xp}}(e.type)}function Ec(s,e,t){this.id=s,this.addr=t,this.cache=[],this.size=e.size,this.setValue=function(n){switch(n){case 5126:return Zp;case 35664:return Yp;case 35665:return Jp;case 35666:return Kp;case 35674:return Qp;case 35675:return $p;case 35676:return ef;case 5124:case 35670:return tf;case 35667:case 35671:return nf;case 35668:case 35672:return rf;case 35669:case 35673:return sf;case 5125:return af;case 36294:return of;case 36295:return lf;case 36296:return cf;case 35678:case 36198:case 36298:case 36306:case 35682:return hf;case 35680:case 36300:case 36308:case 36293:return uf}}(e.type)}function Ac(s){this.id=s,this.seq=[],this.map={}}Ec.prototype.updateCache=function(s){let e=this.cache;s instanceof Float32Array&&e.length!==s.length&&(this.cache=new Float32Array(s.length)),dn(e,s)},Ac.prototype.setValue=function(s,e,t){let n=this.seq;for(let i=0,r=n.length;i!==r;++i){let a=n[i];a.setValue(s,e[a.id],t)}};let Co=/(\w+)(\])?(\[|\.)?/g;function Lc(s,e){s.seq.push(e),s.map[e.id]=e}function pf(s,e,t){let n=s.name,i=n.length;for(Co.lastIndex=0;;){let r=Co.exec(n),a=Co.lastIndex,c=r[1],h=r[2]==="]",u=r[3];if(h&&(c|=0),u===void 0||u==="["&&a+2===i){Lc(t,u===void 0?new df(c,s,e):new Ec(c,s,e));break}{let d=t.map[c];d===void 0&&(d=new Ac(c),Lc(t,d)),t=d}}}function Di(s,e){this.seq=[],this.map={};let t=s.getProgramParameter(e,35718);for(let n=0;n<t;++n){let i=s.getActiveUniform(e,n);pf(i,s.getUniformLocation(e,i.name),this)}}function Rc(s,e,t){let n=s.createShader(e);return s.shaderSource(n,t),s.compileShader(n),n}Di.prototype.setValue=function(s,e,t,n){let i=this.map[e];i!==void 0&&i.setValue(s,t,n)},Di.prototype.setOptional=function(s,e,t){let n=e[t];n!==void 0&&this.setValue(s,t,n)},Di.upload=function(s,e,t,n){for(let i=0,r=e.length;i!==r;++i){let a=e[i],c=t[a.id];c.needsUpdate!==!1&&a.setValue(s,c.value,n)}},Di.seqWithValue=function(s,e){let t=[];for(let n=0,i=s.length;n!==i;++n){let r=s[n];r.id in e&&t.push(r)}return t};let ff=0;function Cc(s){switch(s){case 3e3:return["Linear","( value )"];case 3001:return["sRGB","( value )"];case 3002:return["RGBE","( value )"];case 3004:return["RGBM","( value, 7.0 )"];case 3005:return["RGBM","( value, 16.0 )"];case 3006:return["RGBD","( value, 256.0 )"];case 3007:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case 3003:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",s),["Linear","( value )"]}}function Pc(s,e,t){let n=s.getShaderParameter(e,35713),i=s.getShaderInfoLog(e).trim();return n&&i===""?"":t.toUpperCase()+`

`+i+`

`+function(r){let a=r.split(`
`);for(let c=0;c<a.length;c++)a[c]=c+1+": "+a[c];return a.join(`
`)}(s.getShaderSource(e))}function Or(s,e){let t=Cc(e);return"vec4 "+s+"( vec4 value ) { return "+t[0]+"ToLinear"+t[1]+"; }"}function mf(s,e){let t=Cc(e);return"vec4 "+s+"( vec4 value ) { return LinearTo"+t[0]+t[1]+"; }"}function gf(s,e){let t;switch(e){case 1:t="Linear";break;case 2:t="Reinhard";break;case 3:t="OptimizedCineon";break;case 4:t="ACESFilmic";break;case 5:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+s+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function ls(s){return s!==""}function Dc(s,e){return s.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function Ic(s,e){return s.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}let yf=/^[ \t]*#include +<([\w\d./]+)>/gm;function Po(s){return s.replace(yf,vf)}function vf(s,e){let t=ft[e];if(t===void 0)throw new Error("Can not resolve #include <"+e+">");return Po(t)}let xf=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,_f=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function Oc(s){return s.replace(_f,Fc).replace(xf,bf)}function bf(s,e,t,n){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),Fc(s,e,t,n)}function Fc(s,e,t,n){let i="";for(let r=parseInt(e);r<parseInt(t);r++)i+=n.replace(/\[\s*i\s*\]/g,"[ "+r+" ]").replace(/UNROLLED_LOOP_INDEX/g,r);return i}function Nc(s){let e="precision "+s.precision+` float;
precision `+s.precision+" int;";return s.precision==="highp"?e+=`
#define HIGH_PRECISION`:s.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:s.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function Mf(s,e,t,n){let i=s.getContext(),r=t.defines,a=t.vertexShader,c=t.fragmentShader,h=function(X){let te="SHADOWMAP_TYPE_BASIC";return X.shadowMapType===1?te="SHADOWMAP_TYPE_PCF":X.shadowMapType===2?te="SHADOWMAP_TYPE_PCF_SOFT":X.shadowMapType===3&&(te="SHADOWMAP_TYPE_VSM"),te}(t),u=function(X){let te="ENVMAP_TYPE_CUBE";if(X.envMap)switch(X.envMapMode){case 301:case 302:te="ENVMAP_TYPE_CUBE";break;case 306:case 307:te="ENVMAP_TYPE_CUBE_UV"}return te}(t),d=function(X){let te="ENVMAP_MODE_REFLECTION";if(X.envMap)switch(X.envMapMode){case 302:case 307:te="ENVMAP_MODE_REFRACTION"}return te}(t),p=function(X){let te="ENVMAP_BLENDING_NONE";if(X.envMap)switch(X.combine){case 0:te="ENVMAP_BLENDING_MULTIPLY";break;case 1:te="ENVMAP_BLENDING_MIX";break;case 2:te="ENVMAP_BLENDING_ADD"}return te}(t),f=s.gammaFactor>0?s.gammaFactor:1,m=t.isWebGL2?"":function(X){return[X.extensionDerivatives||X.envMapCubeUV||X.bumpMap||X.tangentSpaceNormalMap||X.clearcoatNormalMap||X.flatShading||X.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(X.extensionFragDepth||X.logarithmicDepthBuffer)&&X.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",X.extensionDrawBuffers&&X.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(X.extensionShaderTextureLOD||X.envMap||X.transmission)&&X.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(ls).join(`
`)}(t),g=function(X){let te=[];for(let J in X){let $=X[J];$!==!1&&te.push("#define "+J+" "+$)}return te.join(`
`)}(r),y=i.createProgram(),x,v,w=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(x=[g].filter(ls).join(`
`),x.length>0&&(x+=`
`),v=[m,g].filter(ls).join(`
`),v.length>0&&(v+=`
`)):(x=[Nc(t),"#define SHADER_NAME "+t.shaderName,g,t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+f,"#define MAX_BONES "+t.maxBones,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+d:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.displacementMap&&t.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularTintMap?"#define USE_SPECULARTINTMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.useVertexTexture?"#define BONE_TEXTURE":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+h:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(ls).join(`
`),v=[m,Nc(t),"#define SHADER_NAME "+t.shaderName,g,"#define GAMMA_FACTOR "+f,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+u:"",t.envMap?"#define "+d:"",t.envMap?"#define "+p:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularTintMap?"#define USE_SPECULARTINTMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.sheenTint?"#define USE_SHEEN":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+h:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(t.extensionShaderTextureLOD||t.envMap)&&t.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==0?"#define TONE_MAPPING":"",t.toneMapping!==0?ft.tonemapping_pars_fragment:"",t.toneMapping!==0?gf("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.format===1022?"#define OPAQUE":"",ft.encodings_pars_fragment,t.map?Or("mapTexelToLinear",t.mapEncoding):"",t.matcap?Or("matcapTexelToLinear",t.matcapEncoding):"",t.envMap?Or("envMapTexelToLinear",t.envMapEncoding):"",t.emissiveMap?Or("emissiveMapTexelToLinear",t.emissiveMapEncoding):"",t.specularTintMap?Or("specularTintMapTexelToLinear",t.specularTintMapEncoding):"",t.lightMap?Or("lightMapTexelToLinear",t.lightMapEncoding):"",mf("linearToOutputTexel",t.outputEncoding),t.depthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(ls).join(`
`)),a=Po(a),a=Dc(a,t),a=Ic(a,t),c=Po(c),c=Dc(c,t),c=Ic(c,t),a=Oc(a),c=Oc(c),t.isWebGL2&&t.isRawShaderMaterial!==!0&&(w=`#version 300 es
`,x=["#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+x,v=["#define varying in",t.glslVersion===re?"":"out highp vec4 pc_fragColor;",t.glslVersion===re?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+v);let A=w+v+c,S=Rc(i,35633,w+x+a),D=Rc(i,35632,A);if(i.attachShader(y,S),i.attachShader(y,D),t.index0AttributeName!==void 0?i.bindAttribLocation(y,0,t.index0AttributeName):t.morphTargets===!0&&i.bindAttribLocation(y,0,"position"),i.linkProgram(y),s.debug.checkShaderErrors){let X=i.getProgramInfoLog(y).trim(),te=i.getShaderInfoLog(S).trim(),J=i.getShaderInfoLog(D).trim(),$=!0,Re=!0;if(i.getProgramParameter(y,35714)===!1){$=!1;let ye=Pc(i,S,"vertex"),ae=Pc(i,D,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(y,35715)+`

Program Info Log: `+X+`
`+ye+`
`+ae)}else X!==""?console.warn("THREE.WebGLProgram: Program Info Log:",X):te!==""&&J!==""||(Re=!1);Re&&(this.diagnostics={runnable:$,programLog:X,vertexShader:{log:te,prefix:x},fragmentShader:{log:J,prefix:v}})}let F,q;return i.deleteShader(S),i.deleteShader(D),this.getUniforms=function(){return F===void 0&&(F=new Di(i,y)),F},this.getAttributes=function(){return q===void 0&&(q=function(X,te){let J={},$=X.getProgramParameter(te,35721);for(let Re=0;Re<$;Re++){let ye=X.getActiveAttrib(te,Re),ae=ye.name,be=1;ye.type===35674&&(be=2),ye.type===35675&&(be=3),ye.type===35676&&(be=4),J[ae]={type:ye.type,location:X.getAttribLocation(te,ae),locationSize:be}}return J}(i,y)),q},this.destroy=function(){n.releaseStatesOfProgram(this),i.deleteProgram(y),this.program=void 0},this.name=t.shaderName,this.id=ff++,this.cacheKey=e,this.usedTimes=1,this.program=y,this.vertexShader=S,this.fragmentShader=D,this}function wf(s,e,t,n,i,r,a){let c=[],h=i.isWebGL2,u=i.logarithmicDepthBuffer,d=i.floatVertexTextures,p=i.maxVertexUniforms,f=i.vertexTextures,m=i.precision,g={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},y=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoat","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","specularIntensityMap","specularTintMap","specularTintMapEncoding","roughnessMap","metalnessMap","gradientMap","alphaMap","alphaTest","combine","vertexColors","vertexAlphas","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","format","sheenTint","transmission","transmissionMap","thicknessMap"];function x(v){let w;return v&&v.isTexture?w=v.encoding:v&&v.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),w=v.texture.encoding):w=3e3,w}return{getParameters:function(v,w,A,S,D){let F=S.fog,q=v.isMeshStandardMaterial?S.environment:null,X=(v.isMeshStandardMaterial?t:e).get(v.envMap||q),te=g[v.type],J=D.isSkinnedMesh?function(Ce){let Ie=Ce.skeleton.bones;if(d)return 1024;{let ke=p,$e=Math.floor((ke-20)/4),et=Math.min($e,Ie.length);return et<Ie.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+Ie.length+" bones. This GPU supports "+et+"."),0):et}}(D):0,$,Re;if(v.precision!==null&&(m=i.getMaxPrecision(v.precision),m!==v.precision&&console.warn("THREE.WebGLProgram.getParameters:",v.precision,"not supported, using",m,"instead.")),te){let Ce=jn[te];$=Ce.vertexShader,Re=Ce.fragmentShader}else $=v.vertexShader,Re=v.fragmentShader;let ye=s.getRenderTarget(),ae=v.alphaTest>0,be=v.clearcoat>0;return{isWebGL2:h,shaderID:te,shaderName:v.type,vertexShader:$,fragmentShader:Re,defines:v.defines,isRawShaderMaterial:v.isRawShaderMaterial===!0,glslVersion:v.glslVersion,precision:m,instancing:D.isInstancedMesh===!0,instancingColor:D.isInstancedMesh===!0&&D.instanceColor!==null,supportsVertexTextures:f,outputEncoding:ye!==null?x(ye.texture):s.outputEncoding,map:!!v.map,mapEncoding:x(v.map),matcap:!!v.matcap,matcapEncoding:x(v.matcap),envMap:!!X,envMapMode:X&&X.mapping,envMapEncoding:x(X),envMapCubeUV:!!X&&(X.mapping===306||X.mapping===307),lightMap:!!v.lightMap,lightMapEncoding:x(v.lightMap),aoMap:!!v.aoMap,emissiveMap:!!v.emissiveMap,emissiveMapEncoding:x(v.emissiveMap),bumpMap:!!v.bumpMap,normalMap:!!v.normalMap,objectSpaceNormalMap:v.normalMapType===1,tangentSpaceNormalMap:v.normalMapType===0,clearcoat:be,clearcoatMap:be&&!!v.clearcoatMap,clearcoatRoughnessMap:be&&!!v.clearcoatRoughnessMap,clearcoatNormalMap:be&&!!v.clearcoatNormalMap,displacementMap:!!v.displacementMap,roughnessMap:!!v.roughnessMap,metalnessMap:!!v.metalnessMap,specularMap:!!v.specularMap,specularIntensityMap:!!v.specularIntensityMap,specularTintMap:!!v.specularTintMap,specularTintMapEncoding:x(v.specularTintMap),alphaMap:!!v.alphaMap,alphaTest:ae,gradientMap:!!v.gradientMap,sheenTint:!!v.sheenTint&&(v.sheenTint.r>0||v.sheenTint.g>0||v.sheenTint.b>0),transmission:v.transmission>0,transmissionMap:!!v.transmissionMap,thicknessMap:!!v.thicknessMap,combine:v.combine,vertexTangents:!!v.normalMap&&!!D.geometry&&!!D.geometry.attributes.tangent,vertexColors:v.vertexColors,vertexAlphas:v.vertexColors===!0&&!!D.geometry&&!!D.geometry.attributes.color&&D.geometry.attributes.color.itemSize===4,vertexUvs:!!(v.map||v.bumpMap||v.normalMap||v.specularMap||v.alphaMap||v.emissiveMap||v.roughnessMap||v.metalnessMap||v.clearcoatMap||v.clearcoatRoughnessMap||v.clearcoatNormalMap||v.displacementMap||v.transmissionMap||v.thicknessMap||v.specularIntensityMap||v.specularTintMap),uvsVertexOnly:!(v.map||v.bumpMap||v.normalMap||v.specularMap||v.alphaMap||v.emissiveMap||v.roughnessMap||v.metalnessMap||v.clearcoatNormalMap||v.transmission>0||v.transmissionMap||v.thicknessMap||v.specularIntensityMap||v.specularTintMap||!v.displacementMap),fog:!!F,useFog:v.fog,fogExp2:F&&F.isFogExp2,flatShading:!!v.flatShading,sizeAttenuation:v.sizeAttenuation,logarithmicDepthBuffer:u,skinning:D.isSkinnedMesh===!0&&J>0,maxBones:J,useVertexTexture:d,morphTargets:!!D.geometry&&!!D.geometry.morphAttributes.position,morphNormals:!!D.geometry&&!!D.geometry.morphAttributes.normal,numDirLights:w.directional.length,numPointLights:w.point.length,numSpotLights:w.spot.length,numRectAreaLights:w.rectArea.length,numHemiLights:w.hemi.length,numDirLightShadows:w.directionalShadowMap.length,numPointLightShadows:w.pointShadowMap.length,numSpotLightShadows:w.spotShadowMap.length,numClippingPlanes:a.numPlanes,numClipIntersection:a.numIntersection,format:v.format,dithering:v.dithering,shadowMapEnabled:s.shadowMap.enabled&&A.length>0,shadowMapType:s.shadowMap.type,toneMapping:v.toneMapped?s.toneMapping:0,physicallyCorrectLights:s.physicallyCorrectLights,premultipliedAlpha:v.premultipliedAlpha,doubleSided:v.side===2,flipSided:v.side===1,depthPacking:v.depthPacking!==void 0&&v.depthPacking,index0AttributeName:v.index0AttributeName,extensionDerivatives:v.extensions&&v.extensions.derivatives,extensionFragDepth:v.extensions&&v.extensions.fragDepth,extensionDrawBuffers:v.extensions&&v.extensions.drawBuffers,extensionShaderTextureLOD:v.extensions&&v.extensions.shaderTextureLOD,rendererExtensionFragDepth:h||n.has("EXT_frag_depth"),rendererExtensionDrawBuffers:h||n.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:h||n.has("EXT_shader_texture_lod"),customProgramCacheKey:v.customProgramCacheKey()}},getProgramCacheKey:function(v){let w=[];if(v.shaderID?w.push(v.shaderID):(w.push(v.fragmentShader),w.push(v.vertexShader)),v.defines!==void 0)for(let A in v.defines)w.push(A),w.push(v.defines[A]);if(v.isRawShaderMaterial===!1){for(let A=0;A<y.length;A++)w.push(v[y[A]]);w.push(s.outputEncoding),w.push(s.gammaFactor)}return w.push(v.customProgramCacheKey),w.join()},getUniforms:function(v){let w=g[v.type],A;if(w){let S=jn[w];A=oc.clone(S.uniforms)}else A=v.uniforms;return A},acquireProgram:function(v,w){let A;for(let S=0,D=c.length;S<D;S++){let F=c[S];if(F.cacheKey===w){A=F,++A.usedTimes;break}}return A===void 0&&(A=new Mf(s,w,v,r),c.push(A)),A},releaseProgram:function(v){if(--v.usedTimes==0){let w=c.indexOf(v);c[w]=c[c.length-1],c.pop(),v.destroy()}},programs:c}}function Sf(){let s=new WeakMap;return{get:function(e){let t=s.get(e);return t===void 0&&(t={},s.set(e,t)),t},remove:function(e){s.delete(e)},update:function(e,t,n){s.get(e)[t]=n},dispose:function(){s=new WeakMap}}}function Tf(s,e){return s.groupOrder!==e.groupOrder?s.groupOrder-e.groupOrder:s.renderOrder!==e.renderOrder?s.renderOrder-e.renderOrder:s.program!==e.program?s.program.id-e.program.id:s.material.id!==e.material.id?s.material.id-e.material.id:s.z!==e.z?s.z-e.z:s.id-e.id}function zc(s,e){return s.groupOrder!==e.groupOrder?s.groupOrder-e.groupOrder:s.renderOrder!==e.renderOrder?s.renderOrder-e.renderOrder:s.z!==e.z?e.z-s.z:s.id-e.id}function Bc(s){let e=[],t=0,n=[],i=[],r=[],a={id:-1};function c(h,u,d,p,f,m){let g=e[t],y=s.get(d);return g===void 0?(g={id:h.id,object:h,geometry:u,material:d,program:y.program||a,groupOrder:p,renderOrder:h.renderOrder,z:f,group:m},e[t]=g):(g.id=h.id,g.object=h,g.geometry=u,g.material=d,g.program=y.program||a,g.groupOrder=p,g.renderOrder=h.renderOrder,g.z=f,g.group=m),t++,g}return{opaque:n,transmissive:i,transparent:r,init:function(){t=0,n.length=0,i.length=0,r.length=0},push:function(h,u,d,p,f,m){let g=c(h,u,d,p,f,m);d.transmission>0?i.push(g):d.transparent===!0?r.push(g):n.push(g)},unshift:function(h,u,d,p,f,m){let g=c(h,u,d,p,f,m);d.transmission>0?i.unshift(g):d.transparent===!0?r.unshift(g):n.unshift(g)},finish:function(){for(let h=t,u=e.length;h<u;h++){let d=e[h];if(d.id===null)break;d.id=null,d.object=null,d.geometry=null,d.material=null,d.program=null,d.group=null}},sort:function(h,u){n.length>1&&n.sort(h||Tf),i.length>1&&i.sort(u||zc),r.length>1&&r.sort(u||zc)}}}function Ef(s){let e=new WeakMap;return{get:function(t,n){let i;return e.has(t)===!1?(i=new Bc(s),e.set(t,[i])):n>=e.get(t).length?(i=new Bc(s),e.get(t).push(i)):i=e.get(t)[n],i},dispose:function(){e=new WeakMap}}}function Af(){let s={};return{get:function(e){if(s[e.id]!==void 0)return s[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new L,color:new De};break;case"SpotLight":t={position:new L,direction:new L,color:new De,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new L,color:new De,distance:0,decay:0};break;case"HemisphereLight":t={direction:new L,skyColor:new De,groundColor:new De};break;case"RectAreaLight":t={color:new De,position:new L,halfWidth:new L,halfHeight:new L}}return s[e.id]=t,t}}}let Lf=0;function Rf(s,e){return(e.castShadow?1:0)-(s.castShadow?1:0)}function Cf(s,e){let t=new Af,n=function(){let h={};return{get:function(u){if(h[u.id]!==void 0)return h[u.id];let d;switch(u.type){case"DirectionalLight":case"SpotLight":d={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new me};break;case"PointLight":d={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new me,shadowCameraNear:1,shadowCameraFar:1e3}}return h[u.id]=d,d}}}(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let h=0;h<9;h++)i.probe.push(new L);let r=new L,a=new Xe,c=new Xe;return{setup:function(h,u){let d=0,p=0,f=0;for(let q=0;q<9;q++)i.probe[q].set(0,0,0);let m=0,g=0,y=0,x=0,v=0,w=0,A=0,S=0;h.sort(Rf);let D=u!==!0?Math.PI:1;for(let q=0,X=h.length;q<X;q++){let te=h[q],J=te.color,$=te.intensity,Re=te.distance,ye=te.shadow&&te.shadow.map?te.shadow.map.texture:null;if(te.isAmbientLight)d+=J.r*$*D,p+=J.g*$*D,f+=J.b*$*D;else if(te.isLightProbe)for(let ae=0;ae<9;ae++)i.probe[ae].addScaledVector(te.sh.coefficients[ae],$);else if(te.isDirectionalLight){let ae=t.get(te);if(ae.color.copy(te.color).multiplyScalar(te.intensity*D),te.castShadow){let be=te.shadow,Ce=n.get(te);Ce.shadowBias=be.bias,Ce.shadowNormalBias=be.normalBias,Ce.shadowRadius=be.radius,Ce.shadowMapSize=be.mapSize,i.directionalShadow[m]=Ce,i.directionalShadowMap[m]=ye,i.directionalShadowMatrix[m]=te.shadow.matrix,w++}i.directional[m]=ae,m++}else if(te.isSpotLight){let ae=t.get(te);if(ae.position.setFromMatrixPosition(te.matrixWorld),ae.color.copy(J).multiplyScalar($*D),ae.distance=Re,ae.coneCos=Math.cos(te.angle),ae.penumbraCos=Math.cos(te.angle*(1-te.penumbra)),ae.decay=te.decay,te.castShadow){let be=te.shadow,Ce=n.get(te);Ce.shadowBias=be.bias,Ce.shadowNormalBias=be.normalBias,Ce.shadowRadius=be.radius,Ce.shadowMapSize=be.mapSize,i.spotShadow[y]=Ce,i.spotShadowMap[y]=ye,i.spotShadowMatrix[y]=te.shadow.matrix,S++}i.spot[y]=ae,y++}else if(te.isRectAreaLight){let ae=t.get(te);ae.color.copy(J).multiplyScalar($),ae.halfWidth.set(.5*te.width,0,0),ae.halfHeight.set(0,.5*te.height,0),i.rectArea[x]=ae,x++}else if(te.isPointLight){let ae=t.get(te);if(ae.color.copy(te.color).multiplyScalar(te.intensity*D),ae.distance=te.distance,ae.decay=te.decay,te.castShadow){let be=te.shadow,Ce=n.get(te);Ce.shadowBias=be.bias,Ce.shadowNormalBias=be.normalBias,Ce.shadowRadius=be.radius,Ce.shadowMapSize=be.mapSize,Ce.shadowCameraNear=be.camera.near,Ce.shadowCameraFar=be.camera.far,i.pointShadow[g]=Ce,i.pointShadowMap[g]=ye,i.pointShadowMatrix[g]=te.shadow.matrix,A++}i.point[g]=ae,g++}else if(te.isHemisphereLight){let ae=t.get(te);ae.skyColor.copy(te.color).multiplyScalar($*D),ae.groundColor.copy(te.groundColor).multiplyScalar($*D),i.hemi[v]=ae,v++}}x>0&&(e.isWebGL2||s.has("OES_texture_float_linear")===!0?(i.rectAreaLTC1=Pe.LTC_FLOAT_1,i.rectAreaLTC2=Pe.LTC_FLOAT_2):s.has("OES_texture_half_float_linear")===!0?(i.rectAreaLTC1=Pe.LTC_HALF_1,i.rectAreaLTC2=Pe.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),i.ambient[0]=d,i.ambient[1]=p,i.ambient[2]=f;let F=i.hash;F.directionalLength===m&&F.pointLength===g&&F.spotLength===y&&F.rectAreaLength===x&&F.hemiLength===v&&F.numDirectionalShadows===w&&F.numPointShadows===A&&F.numSpotShadows===S||(i.directional.length=m,i.spot.length=y,i.rectArea.length=x,i.point.length=g,i.hemi.length=v,i.directionalShadow.length=w,i.directionalShadowMap.length=w,i.pointShadow.length=A,i.pointShadowMap.length=A,i.spotShadow.length=S,i.spotShadowMap.length=S,i.directionalShadowMatrix.length=w,i.pointShadowMatrix.length=A,i.spotShadowMatrix.length=S,F.directionalLength=m,F.pointLength=g,F.spotLength=y,F.rectAreaLength=x,F.hemiLength=v,F.numDirectionalShadows=w,F.numPointShadows=A,F.numSpotShadows=S,i.version=Lf++)},setupView:function(h,u){let d=0,p=0,f=0,m=0,g=0,y=u.matrixWorldInverse;for(let x=0,v=h.length;x<v;x++){let w=h[x];if(w.isDirectionalLight){let A=i.directional[d];A.direction.setFromMatrixPosition(w.matrixWorld),r.setFromMatrixPosition(w.target.matrixWorld),A.direction.sub(r),A.direction.transformDirection(y),d++}else if(w.isSpotLight){let A=i.spot[f];A.position.setFromMatrixPosition(w.matrixWorld),A.position.applyMatrix4(y),A.direction.setFromMatrixPosition(w.matrixWorld),r.setFromMatrixPosition(w.target.matrixWorld),A.direction.sub(r),A.direction.transformDirection(y),f++}else if(w.isRectAreaLight){let A=i.rectArea[m];A.position.setFromMatrixPosition(w.matrixWorld),A.position.applyMatrix4(y),c.identity(),a.copy(w.matrixWorld),a.premultiply(y),c.extractRotation(a),A.halfWidth.set(.5*w.width,0,0),A.halfHeight.set(0,.5*w.height,0),A.halfWidth.applyMatrix4(c),A.halfHeight.applyMatrix4(c),m++}else if(w.isPointLight){let A=i.point[p];A.position.setFromMatrixPosition(w.matrixWorld),A.position.applyMatrix4(y),p++}else if(w.isHemisphereLight){let A=i.hemi[g];A.direction.setFromMatrixPosition(w.matrixWorld),A.direction.transformDirection(y),A.direction.normalize(),g++}}},state:i}}function Hc(s,e){let t=new Cf(s,e),n=[],i=[];return{init:function(){n.length=0,i.length=0},state:{lightsArray:n,shadowsArray:i,lights:t},setupLights:function(r){t.setup(n,r)},setupLightsView:function(r){t.setupView(n,r)},pushLight:function(r){n.push(r)},pushShadow:function(r){i.push(r)}}}function Pf(s,e){let t=new WeakMap;return{get:function(n,i=0){let r;return t.has(n)===!1?(r=new Hc(s,e),t.set(n,[r])):i>=t.get(n).length?(r=new Hc(s,e),t.get(n).push(r)):r=t.get(n)[i],r},dispose:function(){t=new WeakMap}}}class aa extends nn{constructor(e){super(),this.type="MeshDepthMaterial",this.depthPacking=3200,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}aa.prototype.isMeshDepthMaterial=!0;class oa extends nn{constructor(e){super(),this.type="MeshDistanceMaterial",this.referencePosition=new L,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(e)}copy(e){return super.copy(e),this.referencePosition.copy(e.referencePosition),this.nearDistance=e.nearDistance,this.farDistance=e.farDistance,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}oa.prototype.isMeshDistanceMaterial=!0;function Uc(s,e,t){let n=new ss,i=new me,r=new me,a=new _t,c=new aa({depthPacking:3201}),h=new oa,u={},d=t.maxTextureSize,p={0:1,1:0,2:2},f=new xi({uniforms:{shadow_pass:{value:null},resolution:{value:new me},radius:{value:4},samples:{value:8}},vertexShader:`void main() {
	gl_Position = vec4( position, 1.0 );
}`,fragmentShader:`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
uniform float samples;
#include <packing>
void main() {
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`}),m=f.clone();m.defines.HORIZONTAL_PASS=1;let g=new st;g.setAttribute("position",new bt(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));let y=new en(g,f),x=this;function v(S,D){let F=e.update(y);f.uniforms.shadow_pass.value=S.map.texture,f.uniforms.resolution.value=S.mapSize,f.uniforms.radius.value=S.radius,f.uniforms.samples.value=S.blurSamples,s.setRenderTarget(S.mapPass),s.clear(),s.renderBufferDirect(D,null,F,f,y,null),m.uniforms.shadow_pass.value=S.mapPass.texture,m.uniforms.resolution.value=S.mapSize,m.uniforms.radius.value=S.radius,m.uniforms.samples.value=S.blurSamples,s.setRenderTarget(S.map),s.clear(),s.renderBufferDirect(D,null,F,m,y,null)}function w(S,D,F,q,X,te,J){let $=null,Re=q.isPointLight===!0?S.customDistanceMaterial:S.customDepthMaterial;if($=Re!==void 0?Re:q.isPointLight===!0?h:c,s.localClippingEnabled&&F.clipShadows===!0&&F.clippingPlanes.length!==0||F.displacementMap&&F.displacementScale!==0||F.alphaMap&&F.alphaTest>0){let ye=$.uuid,ae=F.uuid,be=u[ye];be===void 0&&(be={},u[ye]=be);let Ce=be[ae];Ce===void 0&&(Ce=$.clone(),be[ae]=Ce),$=Ce}return $.visible=F.visible,$.wireframe=F.wireframe,$.side=J===3?F.shadowSide!==null?F.shadowSide:F.side:F.shadowSide!==null?F.shadowSide:p[F.side],$.alphaMap=F.alphaMap,$.alphaTest=F.alphaTest,$.clipShadows=F.clipShadows,$.clippingPlanes=F.clippingPlanes,$.clipIntersection=F.clipIntersection,$.displacementMap=F.displacementMap,$.displacementScale=F.displacementScale,$.displacementBias=F.displacementBias,$.wireframeLinewidth=F.wireframeLinewidth,$.linewidth=F.linewidth,q.isPointLight===!0&&$.isMeshDistanceMaterial===!0&&($.referencePosition.setFromMatrixPosition(q.matrixWorld),$.nearDistance=X,$.farDistance=te),$}function A(S,D,F,q,X){if(S.visible===!1)return;if(S.layers.test(D.layers)&&(S.isMesh||S.isLine||S.isPoints)&&(S.castShadow||S.receiveShadow&&X===3)&&(!S.frustumCulled||n.intersectsObject(S))){S.modelViewMatrix.multiplyMatrices(F.matrixWorldInverse,S.matrixWorld);let J=e.update(S),$=S.material;if(Array.isArray($)){let Re=J.groups;for(let ye=0,ae=Re.length;ye<ae;ye++){let be=Re[ye],Ce=$[be.materialIndex];if(Ce&&Ce.visible){let Ie=w(S,0,Ce,q,F.near,F.far,X);s.renderBufferDirect(F,null,J,Ie,S,be)}}}else if($.visible){let Re=w(S,0,$,q,F.near,F.far,X);s.renderBufferDirect(F,null,J,Re,S,null)}}let te=S.children;for(let J=0,$=te.length;J<$;J++)A(te[J],D,F,q,X)}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=1,this.render=function(S,D,F){if(x.enabled===!1||x.autoUpdate===!1&&x.needsUpdate===!1||S.length===0)return;let q=s.getRenderTarget(),X=s.getActiveCubeFace(),te=s.getActiveMipmapLevel(),J=s.state;J.setBlending(0),J.buffers.color.setClear(1,1,1,1),J.buffers.depth.setTest(!0),J.setScissorTest(!1);for(let $=0,Re=S.length;$<Re;$++){let ye=S[$],ae=ye.shadow;if(ae===void 0){console.warn("THREE.WebGLShadowMap:",ye,"has no shadow.");continue}if(ae.autoUpdate===!1&&ae.needsUpdate===!1)continue;i.copy(ae.mapSize);let be=ae.getFrameExtents();if(i.multiply(be),r.copy(ae.mapSize),(i.x>d||i.y>d)&&(i.x>d&&(r.x=Math.floor(d/be.x),i.x=r.x*be.x,ae.mapSize.x=r.x),i.y>d&&(r.y=Math.floor(d/be.y),i.y=r.y*be.y,ae.mapSize.y=r.y)),ae.map===null&&!ae.isPointLightShadow&&this.type===3){let Ie={minFilter:1006,magFilter:1006,format:1023};ae.map=new $t(i.x,i.y,Ie),ae.map.texture.name=ye.name+".shadowMap",ae.mapPass=new $t(i.x,i.y,Ie),ae.camera.updateProjectionMatrix()}if(ae.map===null){let Ie={minFilter:1003,magFilter:1003,format:1023};ae.map=new $t(i.x,i.y,Ie),ae.map.texture.name=ye.name+".shadowMap",ae.camera.updateProjectionMatrix()}s.setRenderTarget(ae.map),s.clear();let Ce=ae.getViewportCount();for(let Ie=0;Ie<Ce;Ie++){let ke=ae.getViewport(Ie);a.set(r.x*ke.x,r.y*ke.y,r.x*ke.z,r.y*ke.w),J.viewport(a),ae.updateMatrices(ye,Ie),n=ae.getFrustum(),A(D,F,ae.camera,ye,this.type)}ae.isPointLightShadow||this.type!==3||v(ae,F),ae.needsUpdate=!1}x.needsUpdate=!1,s.setRenderTarget(q,X,te)}}function Df(s,e,t){let n=t.isWebGL2,i=new function(){let C=!1,K=new _t,de=null,pe=new _t(0,0,0,0);return{setMask:function(ue){de===ue||C||(s.colorMask(ue,ue,ue,ue),de=ue)},setLocked:function(ue){C=ue},setClear:function(ue,Ne,Je,Be,ut){ut===!0&&(ue*=Be,Ne*=Be,Je*=Be),K.set(ue,Ne,Je,Be),pe.equals(K)===!1&&(s.clearColor(ue,Ne,Je,Be),pe.copy(K))},reset:function(){C=!1,de=null,pe.set(-1,0,0,0)}}},r=new function(){let C=!1,K=null,de=null,pe=null;return{setTest:function(ue){ue?_e(2929):O(2929)},setMask:function(ue){K===ue||C||(s.depthMask(ue),K=ue)},setFunc:function(ue){if(de!==ue){if(ue)switch(ue){case 0:s.depthFunc(512);break;case 1:s.depthFunc(519);break;case 2:s.depthFunc(513);break;case 3:s.depthFunc(515);break;case 4:s.depthFunc(514);break;case 5:s.depthFunc(518);break;case 6:s.depthFunc(516);break;case 7:s.depthFunc(517);break;default:s.depthFunc(515)}else s.depthFunc(515);de=ue}},setLocked:function(ue){C=ue},setClear:function(ue){pe!==ue&&(s.clearDepth(ue),pe=ue)},reset:function(){C=!1,K=null,de=null,pe=null}}},a=new function(){let C=!1,K=null,de=null,pe=null,ue=null,Ne=null,Je=null,Be=null,ut=null;return{setTest:function(lt){C||(lt?_e(2960):O(2960))},setMask:function(lt){K===lt||C||(s.stencilMask(lt),K=lt)},setFunc:function(lt,on,Pt){de===lt&&pe===on&&ue===Pt||(s.stencilFunc(lt,on,Pt),de=lt,pe=on,ue=Pt)},setOp:function(lt,on,Pt){Ne===lt&&Je===on&&Be===Pt||(s.stencilOp(lt,on,Pt),Ne=lt,Je=on,Be=Pt)},setLocked:function(lt){C=lt},setClear:function(lt){ut!==lt&&(s.clearStencil(lt),ut=lt)},reset:function(){C=!1,K=null,de=null,pe=null,ue=null,Ne=null,Je=null,Be=null,ut=null}}},c={},h=null,u={},d=null,p=!1,f=null,m=null,g=null,y=null,x=null,v=null,w=null,A=!1,S=null,D=null,F=null,q=null,X=null,te=s.getParameter(35661),J=!1,$=0,Re=s.getParameter(7938);Re.indexOf("WebGL")!==-1?($=parseFloat(/^WebGL (\d)/.exec(Re)[1]),J=$>=1):Re.indexOf("OpenGL ES")!==-1&&($=parseFloat(/^OpenGL ES (\d)/.exec(Re)[1]),J=$>=2);let ye=null,ae={},be=s.getParameter(3088),Ce=s.getParameter(2978),Ie=new _t().fromArray(be),ke=new _t().fromArray(Ce);function $e(C,K,de){let pe=new Uint8Array(4),ue=s.createTexture();s.bindTexture(C,ue),s.texParameteri(C,10241,9728),s.texParameteri(C,10240,9728);for(let Ne=0;Ne<de;Ne++)s.texImage2D(K+Ne,0,6408,1,1,0,6408,5121,pe);return ue}let et={};function _e(C){c[C]!==!0&&(s.enable(C),c[C]=!0)}function O(C){c[C]!==!1&&(s.disable(C),c[C]=!1)}et[3553]=$e(3553,3553,1),et[34067]=$e(34067,34069,6),i.setClear(0,0,0,1),r.setClear(1),a.setClear(0),_e(2929),r.setFunc(3),ee(!1),Le(1),_e(2884),se(0);let B={100:32774,101:32778,102:32779};if(n)B[103]=32775,B[104]=32776;else{let C=e.get("EXT_blend_minmax");C!==null&&(B[103]=C.MIN_EXT,B[104]=C.MAX_EXT)}let ce={200:0,201:1,202:768,204:770,210:776,208:774,206:772,203:769,205:771,209:775,207:773};function se(C,K,de,pe,ue,Ne,Je,Be){if(C!==0){if(p===!1&&(_e(3042),p=!0),C===5)ue=ue||K,Ne=Ne||de,Je=Je||pe,K===m&&ue===x||(s.blendEquationSeparate(B[K],B[ue]),m=K,x=ue),de===g&&pe===y&&Ne===v&&Je===w||(s.blendFuncSeparate(ce[de],ce[pe],ce[Ne],ce[Je]),g=de,y=pe,v=Ne,w=Je),f=C,A=null;else if(C!==f||Be!==A){if(m===100&&x===100||(s.blendEquation(32774),m=100,x=100),Be)switch(C){case 1:s.blendFuncSeparate(1,771,1,771);break;case 2:s.blendFunc(1,1);break;case 3:s.blendFuncSeparate(0,0,769,771);break;case 4:s.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",C)}else switch(C){case 1:s.blendFuncSeparate(770,771,1,771);break;case 2:s.blendFunc(770,1);break;case 3:s.blendFunc(0,769);break;case 4:s.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",C)}g=null,y=null,v=null,w=null,f=C,A=Be}}else p===!0&&(O(3042),p=!1)}function ee(C){S!==C&&(C?s.frontFace(2304):s.frontFace(2305),S=C)}function Le(C){C!==0?(_e(2884),C!==D&&(C===1?s.cullFace(1029):C===2?s.cullFace(1028):s.cullFace(1032))):O(2884),D=C}function Ee(C,K,de){C?(_e(32823),q===K&&X===de||(s.polygonOffset(K,de),q=K,X=de)):O(32823)}function ne(C){C===void 0&&(C=33984+te-1),ye!==C&&(s.activeTexture(C),ye=C)}return{buffers:{color:i,depth:r,stencil:a},enable:_e,disable:O,bindFramebuffer:function(C,K){return K===null&&h!==null&&(K=h),u[C]!==K&&(s.bindFramebuffer(C,K),u[C]=K,n&&(C===36009&&(u[36160]=K),C===36160&&(u[36009]=K)),!0)},bindXRFramebuffer:function(C){C!==h&&(s.bindFramebuffer(36160,C),h=C)},useProgram:function(C){return d!==C&&(s.useProgram(C),d=C,!0)},setBlending:se,setMaterial:function(C,K){C.side===2?O(2884):_e(2884);let de=C.side===1;K&&(de=!de),ee(de),C.blending===1&&C.transparent===!1?se(0):se(C.blending,C.blendEquation,C.blendSrc,C.blendDst,C.blendEquationAlpha,C.blendSrcAlpha,C.blendDstAlpha,C.premultipliedAlpha),r.setFunc(C.depthFunc),r.setTest(C.depthTest),r.setMask(C.depthWrite),i.setMask(C.colorWrite);let pe=C.stencilWrite;a.setTest(pe),pe&&(a.setMask(C.stencilWriteMask),a.setFunc(C.stencilFunc,C.stencilRef,C.stencilFuncMask),a.setOp(C.stencilFail,C.stencilZFail,C.stencilZPass)),Ee(C.polygonOffset,C.polygonOffsetFactor,C.polygonOffsetUnits),C.alphaToCoverage===!0?_e(32926):O(32926)},setFlipSided:ee,setCullFace:Le,setLineWidth:function(C){C!==F&&(J&&s.lineWidth(C),F=C)},setPolygonOffset:Ee,setScissorTest:function(C){C?_e(3089):O(3089)},activeTexture:ne,bindTexture:function(C,K){ye===null&&ne();let de=ae[ye];de===void 0&&(de={type:void 0,texture:void 0},ae[ye]=de),de.type===C&&de.texture===K||(s.bindTexture(C,K||et[C]),de.type=C,de.texture=K)},unbindTexture:function(){let C=ae[ye];C!==void 0&&C.type!==void 0&&(s.bindTexture(C.type,null),C.type=void 0,C.texture=void 0)},compressedTexImage2D:function(){try{s.compressedTexImage2D.apply(s,arguments)}catch(C){console.error("THREE.WebGLState:",C)}},texImage2D:function(){try{s.texImage2D.apply(s,arguments)}catch(C){console.error("THREE.WebGLState:",C)}},texImage3D:function(){try{s.texImage3D.apply(s,arguments)}catch(C){console.error("THREE.WebGLState:",C)}},scissor:function(C){Ie.equals(C)===!1&&(s.scissor(C.x,C.y,C.z,C.w),Ie.copy(C))},viewport:function(C){ke.equals(C)===!1&&(s.viewport(C.x,C.y,C.z,C.w),ke.copy(C))},reset:function(){s.disable(3042),s.disable(2884),s.disable(2929),s.disable(32823),s.disable(3089),s.disable(2960),s.disable(32926),s.blendEquation(32774),s.blendFunc(1,0),s.blendFuncSeparate(1,0,1,0),s.colorMask(!0,!0,!0,!0),s.clearColor(0,0,0,0),s.depthMask(!0),s.depthFunc(513),s.clearDepth(1),s.stencilMask(4294967295),s.stencilFunc(519,0,4294967295),s.stencilOp(7680,7680,7680),s.clearStencil(0),s.cullFace(1029),s.frontFace(2305),s.polygonOffset(0,0),s.activeTexture(33984),s.bindFramebuffer(36160,null),n===!0&&(s.bindFramebuffer(36009,null),s.bindFramebuffer(36008,null)),s.useProgram(null),s.lineWidth(1),s.scissor(0,0,s.canvas.width,s.canvas.height),s.viewport(0,0,s.canvas.width,s.canvas.height),c={},ye=null,ae={},h=null,u={},d=null,p=!1,f=null,m=null,g=null,y=null,x=null,v=null,w=null,A=!1,S=null,D=null,F=null,q=null,X=null,Ie.set(0,0,s.canvas.width,s.canvas.height),ke.set(0,0,s.canvas.width,s.canvas.height),i.reset(),r.reset(),a.reset()}}}function If(s,e,t,n,i,r,a){let c=i.isWebGL2,h=i.maxTextures,u=i.maxCubemapSize,d=i.maxTextureSize,p=i.maxSamples,f=new WeakMap,m,g=!1;try{g=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function y(O,B){return g?new OffscreenCanvas(O,B):document.createElementNS("http://www.w3.org/1999/xhtml","canvas")}function x(O,B,ce,se){let ee=1;if((O.width>se||O.height>se)&&(ee=se/Math.max(O.width,O.height)),ee<1||B===!0){if(typeof HTMLImageElement<"u"&&O instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&O instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&O instanceof ImageBitmap){let Le=B?ti:Math.floor,Ee=Le(ee*O.width),ne=Le(ee*O.height);m===void 0&&(m=y(Ee,ne));let C=ce?y(Ee,ne):m;return C.width=Ee,C.height=ne,C.getContext("2d").drawImage(O,0,0,Ee,ne),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+O.width+"x"+O.height+") to ("+Ee+"x"+ne+")."),C}return"data"in O&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+O.width+"x"+O.height+")."),O}return O}function v(O){return Dt(O.width)&&Dt(O.height)}function w(O,B){return O.generateMipmaps&&B&&O.minFilter!==1003&&O.minFilter!==1006}function A(O,B,ce,se,ee=1){s.generateMipmap(O),n.get(B).__maxMipLevel=Math.log2(Math.max(ce,se,ee))}function S(O,B,ce){if(c===!1)return B;if(O!==null){if(s[O]!==void 0)return s[O];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+O+"'")}let se=B;return B===6403&&(ce===5126&&(se=33326),ce===5131&&(se=33325),ce===5121&&(se=33321)),B===6407&&(ce===5126&&(se=34837),ce===5131&&(se=34843),ce===5121&&(se=32849)),B===6408&&(ce===5126&&(se=34836),ce===5131&&(se=34842),ce===5121&&(se=32856)),se!==33325&&se!==33326&&se!==34842&&se!==34836||e.get("EXT_color_buffer_float"),se}function D(O){return O===1003||O===1004||O===1005?9728:9729}function F(O){let B=O.target;B.removeEventListener("dispose",F),function(ce){let se=n.get(ce);se.__webglInit!==void 0&&(s.deleteTexture(se.__webglTexture),n.remove(ce))}(B),B.isVideoTexture&&f.delete(B),a.memory.textures--}function q(O){let B=O.target;B.removeEventListener("dispose",q),function(ce){let se=ce.texture,ee=n.get(ce),Le=n.get(se);if(ce){if(Le.__webglTexture!==void 0&&(s.deleteTexture(Le.__webglTexture),a.memory.textures--),ce.depthTexture&&ce.depthTexture.dispose(),ce.isWebGLCubeRenderTarget)for(let Ee=0;Ee<6;Ee++)s.deleteFramebuffer(ee.__webglFramebuffer[Ee]),ee.__webglDepthbuffer&&s.deleteRenderbuffer(ee.__webglDepthbuffer[Ee]);else s.deleteFramebuffer(ee.__webglFramebuffer),ee.__webglDepthbuffer&&s.deleteRenderbuffer(ee.__webglDepthbuffer),ee.__webglMultisampledFramebuffer&&s.deleteFramebuffer(ee.__webglMultisampledFramebuffer),ee.__webglColorRenderbuffer&&s.deleteRenderbuffer(ee.__webglColorRenderbuffer),ee.__webglDepthRenderbuffer&&s.deleteRenderbuffer(ee.__webglDepthRenderbuffer);if(ce.isWebGLMultipleRenderTargets)for(let Ee=0,ne=se.length;Ee<ne;Ee++){let C=n.get(se[Ee]);C.__webglTexture&&(s.deleteTexture(C.__webglTexture),a.memory.textures--),n.remove(se[Ee])}n.remove(se),n.remove(ce)}}(B)}let X=0;function te(O,B){let ce=n.get(O);if(O.isVideoTexture&&function(se){let ee=a.render.frame;f.get(se)!==ee&&(f.set(se,ee),se.update())}(O),O.version>0&&ce.__version!==O.version){let se=O.image;if(se===void 0)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else{if(se.complete!==!1)return void be(ce,O,B);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}t.activeTexture(33984+B),t.bindTexture(3553,ce.__webglTexture)}function J(O,B){let ce=n.get(O);O.version>0&&ce.__version!==O.version?function(se,ee,Le){if(ee.image.length!==6)return;ae(se,ee),t.activeTexture(33984+Le),t.bindTexture(34067,se.__webglTexture),s.pixelStorei(37440,ee.flipY),s.pixelStorei(37441,ee.premultiplyAlpha),s.pixelStorei(3317,ee.unpackAlignment),s.pixelStorei(37443,0);let Ee=ee&&(ee.isCompressedTexture||ee.image[0].isCompressedTexture),ne=ee.image[0]&&ee.image[0].isDataTexture,C=[];for(let Be=0;Be<6;Be++)C[Be]=Ee||ne?ne?ee.image[Be].image:ee.image[Be]:x(ee.image[Be],!1,!0,u);let K=C[0],de=v(K)||c,pe=r.convert(ee.format),ue=r.convert(ee.type),Ne=S(ee.internalFormat,pe,ue),Je;if(ye(34067,ee,de),Ee){for(let Be=0;Be<6;Be++){Je=C[Be].mipmaps;for(let ut=0;ut<Je.length;ut++){let lt=Je[ut];ee.format!==1023&&ee.format!==1022?pe!==null?t.compressedTexImage2D(34069+Be,ut,Ne,lt.width,lt.height,0,lt.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):t.texImage2D(34069+Be,ut,Ne,lt.width,lt.height,0,pe,ue,lt.data)}}se.__maxMipLevel=Je.length-1}else{Je=ee.mipmaps;for(let Be=0;Be<6;Be++)if(ne){t.texImage2D(34069+Be,0,Ne,C[Be].width,C[Be].height,0,pe,ue,C[Be].data);for(let ut=0;ut<Je.length;ut++){let lt=Je[ut].image[Be].image;t.texImage2D(34069+Be,ut+1,Ne,lt.width,lt.height,0,pe,ue,lt.data)}}else{t.texImage2D(34069+Be,0,Ne,pe,ue,C[Be]);for(let ut=0;ut<Je.length;ut++){let lt=Je[ut];t.texImage2D(34069+Be,ut+1,Ne,pe,ue,lt.image[Be])}}se.__maxMipLevel=Je.length}w(ee,de)&&A(34067,ee,K.width,K.height),se.__version=ee.version,ee.onUpdate&&ee.onUpdate(ee)}(ce,O,B):(t.activeTexture(33984+B),t.bindTexture(34067,ce.__webglTexture))}let $={1e3:10497,1001:33071,1002:33648},Re={1003:9728,1004:9984,1005:9986,1006:9729,1007:9985,1008:9987};function ye(O,B,ce){if(ce?(s.texParameteri(O,10242,$[B.wrapS]),s.texParameteri(O,10243,$[B.wrapT]),O!==32879&&O!==35866||s.texParameteri(O,32882,$[B.wrapR]),s.texParameteri(O,10240,Re[B.magFilter]),s.texParameteri(O,10241,Re[B.minFilter])):(s.texParameteri(O,10242,33071),s.texParameteri(O,10243,33071),O!==32879&&O!==35866||s.texParameteri(O,32882,33071),B.wrapS===1001&&B.wrapT===1001||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),s.texParameteri(O,10240,D(B.magFilter)),s.texParameteri(O,10241,D(B.minFilter)),B.minFilter!==1003&&B.minFilter!==1006&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),e.has("EXT_texture_filter_anisotropic")===!0){let se=e.get("EXT_texture_filter_anisotropic");if(B.type===1015&&e.has("OES_texture_float_linear")===!1||c===!1&&B.type===1016&&e.has("OES_texture_half_float_linear")===!1)return;(B.anisotropy>1||n.get(B).__currentAnisotropy)&&(s.texParameterf(O,se.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(B.anisotropy,i.getMaxAnisotropy())),n.get(B).__currentAnisotropy=B.anisotropy)}}function ae(O,B){O.__webglInit===void 0&&(O.__webglInit=!0,B.addEventListener("dispose",F),O.__webglTexture=s.createTexture(),a.memory.textures++)}function be(O,B,ce){let se=3553;B.isDataTexture2DArray&&(se=35866),B.isDataTexture3D&&(se=32879),ae(O,B),t.activeTexture(33984+ce),t.bindTexture(se,O.__webglTexture),s.pixelStorei(37440,B.flipY),s.pixelStorei(37441,B.premultiplyAlpha),s.pixelStorei(3317,B.unpackAlignment),s.pixelStorei(37443,0);let ee=function(ue){return!c&&(ue.wrapS!==1001||ue.wrapT!==1001||ue.minFilter!==1003&&ue.minFilter!==1006)}(B)&&v(B.image)===!1,Le=x(B.image,ee,!1,d),Ee=v(Le)||c,ne=r.convert(B.format),C,K=r.convert(B.type),de=S(B.internalFormat,ne,K);ye(se,B,Ee);let pe=B.mipmaps;if(B.isDepthTexture)de=6402,c?de=B.type===1015?36012:B.type===1014?33190:B.type===1020?35056:33189:B.type===1015&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),B.format===1026&&de===6402&&B.type!==1012&&B.type!==1014&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),B.type=1012,K=r.convert(B.type)),B.format===1027&&de===6402&&(de=34041,B.type!==1020&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),B.type=1020,K=r.convert(B.type))),t.texImage2D(3553,0,de,Le.width,Le.height,0,ne,K,null);else if(B.isDataTexture)if(pe.length>0&&Ee){for(let ue=0,Ne=pe.length;ue<Ne;ue++)C=pe[ue],t.texImage2D(3553,ue,de,C.width,C.height,0,ne,K,C.data);B.generateMipmaps=!1,O.__maxMipLevel=pe.length-1}else t.texImage2D(3553,0,de,Le.width,Le.height,0,ne,K,Le.data),O.__maxMipLevel=0;else if(B.isCompressedTexture){for(let ue=0,Ne=pe.length;ue<Ne;ue++)C=pe[ue],B.format!==1023&&B.format!==1022?ne!==null?t.compressedTexImage2D(3553,ue,de,C.width,C.height,0,C.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):t.texImage2D(3553,ue,de,C.width,C.height,0,ne,K,C.data);O.__maxMipLevel=pe.length-1}else if(B.isDataTexture2DArray)t.texImage3D(35866,0,de,Le.width,Le.height,Le.depth,0,ne,K,Le.data),O.__maxMipLevel=0;else if(B.isDataTexture3D)t.texImage3D(32879,0,de,Le.width,Le.height,Le.depth,0,ne,K,Le.data),O.__maxMipLevel=0;else if(pe.length>0&&Ee){for(let ue=0,Ne=pe.length;ue<Ne;ue++)C=pe[ue],t.texImage2D(3553,ue,de,ne,K,C);B.generateMipmaps=!1,O.__maxMipLevel=pe.length-1}else t.texImage2D(3553,0,de,ne,K,Le),O.__maxMipLevel=0;w(B,Ee)&&A(se,B,Le.width,Le.height),O.__version=B.version,B.onUpdate&&B.onUpdate(B)}function Ce(O,B,ce,se,ee){let Le=r.convert(ce.format),Ee=r.convert(ce.type),ne=S(ce.internalFormat,Le,Ee);ee===32879||ee===35866?t.texImage3D(ee,0,ne,B.width,B.height,B.depth,0,Le,Ee,null):t.texImage2D(ee,0,ne,B.width,B.height,0,Le,Ee,null),t.bindFramebuffer(36160,O),s.framebufferTexture2D(36160,se,ee,n.get(ce).__webglTexture,0),t.bindFramebuffer(36160,null)}function Ie(O,B,ce){if(s.bindRenderbuffer(36161,O),B.depthBuffer&&!B.stencilBuffer){let se=33189;if(ce){let ee=B.depthTexture;ee&&ee.isDepthTexture&&(ee.type===1015?se=36012:ee.type===1014&&(se=33190));let Le=$e(B);s.renderbufferStorageMultisample(36161,Le,se,B.width,B.height)}else s.renderbufferStorage(36161,se,B.width,B.height);s.framebufferRenderbuffer(36160,36096,36161,O)}else if(B.depthBuffer&&B.stencilBuffer){if(ce){let se=$e(B);s.renderbufferStorageMultisample(36161,se,35056,B.width,B.height)}else s.renderbufferStorage(36161,34041,B.width,B.height);s.framebufferRenderbuffer(36160,33306,36161,O)}else{let se=B.isWebGLMultipleRenderTargets===!0?B.texture[0]:B.texture,ee=r.convert(se.format),Le=r.convert(se.type),Ee=S(se.internalFormat,ee,Le);if(ce){let ne=$e(B);s.renderbufferStorageMultisample(36161,ne,Ee,B.width,B.height)}else s.renderbufferStorage(36161,Ee,B.width,B.height)}s.bindRenderbuffer(36161,null)}function ke(O){let B=n.get(O),ce=O.isWebGLCubeRenderTarget===!0;if(O.depthTexture){if(ce)throw new Error("target.depthTexture not supported in Cube render targets");(function(se,ee){if(ee&&ee.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(36160,se),!ee.depthTexture||!ee.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");n.get(ee.depthTexture).__webglTexture&&ee.depthTexture.image.width===ee.width&&ee.depthTexture.image.height===ee.height||(ee.depthTexture.image.width=ee.width,ee.depthTexture.image.height=ee.height,ee.depthTexture.needsUpdate=!0),te(ee.depthTexture,0);let Le=n.get(ee.depthTexture).__webglTexture;if(ee.depthTexture.format===1026)s.framebufferTexture2D(36160,36096,3553,Le,0);else{if(ee.depthTexture.format!==1027)throw new Error("Unknown depthTexture format");s.framebufferTexture2D(36160,33306,3553,Le,0)}})(B.__webglFramebuffer,O)}else if(ce){B.__webglDepthbuffer=[];for(let se=0;se<6;se++)t.bindFramebuffer(36160,B.__webglFramebuffer[se]),B.__webglDepthbuffer[se]=s.createRenderbuffer(),Ie(B.__webglDepthbuffer[se],O,!1)}else t.bindFramebuffer(36160,B.__webglFramebuffer),B.__webglDepthbuffer=s.createRenderbuffer(),Ie(B.__webglDepthbuffer,O,!1);t.bindFramebuffer(36160,null)}function $e(O){return c&&O.isWebGLMultisampleRenderTarget?Math.min(p,O.samples):0}let et=!1,_e=!1;this.allocateTextureUnit=function(){let O=X;return O>=h&&console.warn("THREE.WebGLTextures: Trying to use "+O+" texture units while this GPU supports only "+h),X+=1,O},this.resetTextureUnits=function(){X=0},this.setTexture2D=te,this.setTexture2DArray=function(O,B){let ce=n.get(O);O.version>0&&ce.__version!==O.version?be(ce,O,B):(t.activeTexture(33984+B),t.bindTexture(35866,ce.__webglTexture))},this.setTexture3D=function(O,B){let ce=n.get(O);O.version>0&&ce.__version!==O.version?be(ce,O,B):(t.activeTexture(33984+B),t.bindTexture(32879,ce.__webglTexture))},this.setTextureCube=J,this.setupRenderTarget=function(O){let B=O.texture,ce=n.get(O),se=n.get(B);O.addEventListener("dispose",q),O.isWebGLMultipleRenderTargets!==!0&&(se.__webglTexture=s.createTexture(),se.__version=B.version,a.memory.textures++);let ee=O.isWebGLCubeRenderTarget===!0,Le=O.isWebGLMultipleRenderTargets===!0,Ee=O.isWebGLMultisampleRenderTarget===!0,ne=B.isDataTexture3D||B.isDataTexture2DArray,C=v(O)||c;if(!c||B.format!==1022||B.type!==1015&&B.type!==1016||(B.format=1023,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),ee){ce.__webglFramebuffer=[];for(let K=0;K<6;K++)ce.__webglFramebuffer[K]=s.createFramebuffer()}else if(ce.__webglFramebuffer=s.createFramebuffer(),Le)if(i.drawBuffers){let K=O.texture;for(let de=0,pe=K.length;de<pe;de++){let ue=n.get(K[de]);ue.__webglTexture===void 0&&(ue.__webglTexture=s.createTexture(),a.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");else if(Ee)if(c){ce.__webglMultisampledFramebuffer=s.createFramebuffer(),ce.__webglColorRenderbuffer=s.createRenderbuffer(),s.bindRenderbuffer(36161,ce.__webglColorRenderbuffer);let K=r.convert(B.format),de=r.convert(B.type),pe=S(B.internalFormat,K,de),ue=$e(O);s.renderbufferStorageMultisample(36161,ue,pe,O.width,O.height),t.bindFramebuffer(36160,ce.__webglMultisampledFramebuffer),s.framebufferRenderbuffer(36160,36064,36161,ce.__webglColorRenderbuffer),s.bindRenderbuffer(36161,null),O.depthBuffer&&(ce.__webglDepthRenderbuffer=s.createRenderbuffer(),Ie(ce.__webglDepthRenderbuffer,O,!0)),t.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(ee){t.bindTexture(34067,se.__webglTexture),ye(34067,B,C);for(let K=0;K<6;K++)Ce(ce.__webglFramebuffer[K],O,B,36064,34069+K);w(B,C)&&A(34067,B,O.width,O.height),t.unbindTexture()}else if(Le){let K=O.texture;for(let de=0,pe=K.length;de<pe;de++){let ue=K[de],Ne=n.get(ue);t.bindTexture(3553,Ne.__webglTexture),ye(3553,ue,C),Ce(ce.__webglFramebuffer,O,ue,36064+de,3553),w(ue,C)&&A(3553,ue,O.width,O.height)}t.unbindTexture()}else{let K=3553;ne&&(c?K=B.isDataTexture3D?32879:35866:console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")),t.bindTexture(K,se.__webglTexture),ye(K,B,C),Ce(ce.__webglFramebuffer,O,B,36064,K),w(B,C)&&A(K,B,O.width,O.height,O.depth),t.unbindTexture()}O.depthBuffer&&ke(O)},this.updateRenderTargetMipmap=function(O){let B=v(O)||c,ce=O.isWebGLMultipleRenderTargets===!0?O.texture:[O.texture];for(let se=0,ee=ce.length;se<ee;se++){let Le=ce[se];if(w(Le,B)){let Ee=O.isWebGLCubeRenderTarget?34067:3553,ne=n.get(Le).__webglTexture;t.bindTexture(Ee,ne),A(Ee,Le,O.width,O.height),t.unbindTexture()}}},this.updateMultisampleRenderTarget=function(O){if(O.isWebGLMultisampleRenderTarget)if(c){let B=O.width,ce=O.height,se=16384;O.depthBuffer&&(se|=256),O.stencilBuffer&&(se|=1024);let ee=n.get(O);t.bindFramebuffer(36008,ee.__webglMultisampledFramebuffer),t.bindFramebuffer(36009,ee.__webglFramebuffer),s.blitFramebuffer(0,0,B,ce,0,0,B,ce,se,9728),t.bindFramebuffer(36008,null),t.bindFramebuffer(36009,ee.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")},this.safeSetTexture2D=function(O,B){O&&O.isWebGLRenderTarget&&(et===!1&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),et=!0),O=O.texture),te(O,B)},this.safeSetTextureCube=function(O,B){O&&O.isWebGLCubeRenderTarget&&(_e===!1&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),_e=!0),O=O.texture),J(O,B)}}function Gc(s,e,t){let n=t.isWebGL2;return{convert:function(i){let r;if(i===1009)return 5121;if(i===1017)return 32819;if(i===1018)return 32820;if(i===1019)return 33635;if(i===1010)return 5120;if(i===1011)return 5122;if(i===1012)return 5123;if(i===1013)return 5124;if(i===1014)return 5125;if(i===1015)return 5126;if(i===1016)return n?5131:(r=e.get("OES_texture_half_float"),r!==null?r.HALF_FLOAT_OES:null);if(i===1021)return 6406;if(i===1022)return 6407;if(i===1023)return 6408;if(i===1024)return 6409;if(i===1025)return 6410;if(i===1026)return 6402;if(i===1027)return 34041;if(i===1028)return 6403;if(i===1029)return 36244;if(i===1030)return 33319;if(i===1031)return 33320;if(i===1032)return 36248;if(i===1033)return 36249;if(i===33776||i===33777||i===33778||i===33779){if(r=e.get("WEBGL_compressed_texture_s3tc"),r===null)return null;if(i===33776)return r.COMPRESSED_RGB_S3TC_DXT1_EXT;if(i===33777)return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(i===33778)return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(i===33779)return r.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(i===35840||i===35841||i===35842||i===35843){if(r=e.get("WEBGL_compressed_texture_pvrtc"),r===null)return null;if(i===35840)return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(i===35841)return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(i===35842)return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(i===35843)return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(i===36196)return r=e.get("WEBGL_compressed_texture_etc1"),r!==null?r.COMPRESSED_RGB_ETC1_WEBGL:null;if((i===37492||i===37496)&&(r=e.get("WEBGL_compressed_texture_etc"),r!==null)){if(i===37492)return r.COMPRESSED_RGB8_ETC2;if(i===37496)return r.COMPRESSED_RGBA8_ETC2_EAC}return i===37808||i===37809||i===37810||i===37811||i===37812||i===37813||i===37814||i===37815||i===37816||i===37817||i===37818||i===37819||i===37820||i===37821||i===37840||i===37841||i===37842||i===37843||i===37844||i===37845||i===37846||i===37847||i===37848||i===37849||i===37850||i===37851||i===37852||i===37853?(r=e.get("WEBGL_compressed_texture_astc"),r!==null?i:null):i===36492?(r=e.get("EXT_texture_compression_bptc"),r!==null?i:null):i===1020?n?34042:(r=e.get("WEBGL_depth_texture"),r!==null?r.UNSIGNED_INT_24_8_WEBGL:null):void 0}}}class Do extends sn{constructor(e=[]){super(),this.cameras=e}}Do.prototype.isArrayCamera=!0;class Xi extends pt{constructor(){super(),this.type="Group"}}Xi.prototype.isGroup=!0;let Of={type:"move"};class Io{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Xi,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Xi,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new L,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new L),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Xi,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new L,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new L),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,n){let i=null,r=null,a=null,c=this._targetRay,h=this._grip,u=this._hand;if(e&&t.session.visibilityState!=="visible-blurred")if(c!==null&&(i=t.getPose(e.targetRaySpace,n),i!==null&&(c.matrix.fromArray(i.transform.matrix),c.matrix.decompose(c.position,c.rotation,c.scale),i.linearVelocity?(c.hasLinearVelocity=!0,c.linearVelocity.copy(i.linearVelocity)):c.hasLinearVelocity=!1,i.angularVelocity?(c.hasAngularVelocity=!0,c.angularVelocity.copy(i.angularVelocity)):c.hasAngularVelocity=!1,this.dispatchEvent(Of))),u&&e.hand){a=!0;for(let y of e.hand.values()){let x=t.getJointPose(y,n);if(u.joints[y.jointName]===void 0){let w=new Xi;w.matrixAutoUpdate=!1,w.visible=!1,u.joints[y.jointName]=w,u.add(w)}let v=u.joints[y.jointName];x!==null&&(v.matrix.fromArray(x.transform.matrix),v.matrix.decompose(v.position,v.rotation,v.scale),v.jointRadius=x.radius),v.visible=x!==null}let d=u.joints["index-finger-tip"],p=u.joints["thumb-tip"],f=d.position.distanceTo(p.position),m=.02,g=.005;u.inputState.pinching&&f>m+g?(u.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!u.inputState.pinching&&f<=m-g&&(u.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else h!==null&&e.gripSpace&&(r=t.getPose(e.gripSpace,n),r!==null&&(h.matrix.fromArray(r.transform.matrix),h.matrix.decompose(h.position,h.rotation,h.scale),r.linearVelocity?(h.hasLinearVelocity=!0,h.linearVelocity.copy(r.linearVelocity)):h.hasLinearVelocity=!1,r.angularVelocity?(h.hasAngularVelocity=!0,h.angularVelocity.copy(r.angularVelocity)):h.hasAngularVelocity=!1));return c!==null&&(c.visible=i!==null),h!==null&&(h.visible=r!==null),u!==null&&(u.visible=a!==null),this}}class Ff extends Me{constructor(e,t){super();let n=this,i=e.state,r=null,a=1,c=null,h="local-floor",u=null,d=null,p=null,f=null,m=null,g=!1,y=null,x=null,v=null,w=null,A=null,S=null,D=[],F=new Map,q=new sn;q.layers.enable(1),q.viewport=new _t;let X=new sn;X.layers.enable(2),X.viewport=new _t;let te=[q,X],J=new Do;J.layers.enable(1),J.layers.enable(2);let $=null,Re=null;function ye(_e){let O=F.get(_e.inputSource);O&&O.dispatchEvent({type:_e.type,data:_e.inputSource})}function ae(){F.forEach(function(_e,O){_e.disconnect(O)}),F.clear(),$=null,Re=null,i.bindXRFramebuffer(null),e.setRenderTarget(e.getRenderTarget()),p&&t.deleteFramebuffer(p),y&&t.deleteFramebuffer(y),x&&t.deleteRenderbuffer(x),v&&t.deleteRenderbuffer(v),p=null,y=null,x=null,v=null,m=null,f=null,d=null,r=null,et.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}function be(_e){let O=r.inputSources;for(let B=0;B<D.length;B++)F.set(O[B],D[B]);for(let B=0;B<_e.removed.length;B++){let ce=_e.removed[B],se=F.get(ce);se&&(se.dispatchEvent({type:"disconnected",data:ce}),F.delete(ce))}for(let B=0;B<_e.added.length;B++){let ce=_e.added[B],se=F.get(ce);se&&se.dispatchEvent({type:"connected",data:ce})}}this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(_e){let O=D[_e];return O===void 0&&(O=new Io,D[_e]=O),O.getTargetRaySpace()},this.getControllerGrip=function(_e){let O=D[_e];return O===void 0&&(O=new Io,D[_e]=O),O.getGripSpace()},this.getHand=function(_e){let O=D[_e];return O===void 0&&(O=new Io,D[_e]=O),O.getHandSpace()},this.setFramebufferScaleFactor=function(_e){a=_e,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(_e){h=_e,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return c},this.getBaseLayer=function(){return f!==null?f:m},this.getBinding=function(){return d},this.getFrame=function(){return w},this.getSession=function(){return r},this.setSession=async function(_e){if(r=_e,r!==null){r.addEventListener("select",ye),r.addEventListener("selectstart",ye),r.addEventListener("selectend",ye),r.addEventListener("squeeze",ye),r.addEventListener("squeezestart",ye),r.addEventListener("squeezeend",ye),r.addEventListener("end",ae),r.addEventListener("inputsourceschange",be);let O=t.getContextAttributes();if(O.xrCompatible!==!0&&await t.makeXRCompatible(),r.renderState.layers===void 0){let B={antialias:O.antialias,alpha:O.alpha,depth:O.depth,stencil:O.stencil,framebufferScaleFactor:a};m=new XRWebGLLayer(r,t,B),r.updateRenderState({baseLayer:m})}else if(t instanceof WebGLRenderingContext){let B={antialias:!0,alpha:O.alpha,depth:O.depth,stencil:O.stencil,framebufferScaleFactor:a};m=new XRWebGLLayer(r,t,B),r.updateRenderState({layers:[m]})}else{g=O.antialias;let B=null;O.depth&&(S=256,O.stencil&&(S|=1024),A=O.stencil?33306:36096,B=O.stencil?35056:33190);let ce={colorFormat:O.alpha?32856:32849,depthFormat:B,scaleFactor:a};d=new XRWebGLBinding(r,t),f=d.createProjectionLayer(ce),p=t.createFramebuffer(),r.updateRenderState({layers:[f]}),g&&(y=t.createFramebuffer(),x=t.createRenderbuffer(),t.bindRenderbuffer(36161,x),t.renderbufferStorageMultisample(36161,4,32856,f.textureWidth,f.textureHeight),i.bindFramebuffer(36160,y),t.framebufferRenderbuffer(36160,36064,36161,x),t.bindRenderbuffer(36161,null),B!==null&&(v=t.createRenderbuffer(),t.bindRenderbuffer(36161,v),t.renderbufferStorageMultisample(36161,4,B,f.textureWidth,f.textureHeight),t.framebufferRenderbuffer(36160,A,36161,v),t.bindRenderbuffer(36161,null)),i.bindFramebuffer(36160,null))}c=await r.requestReferenceSpace(h),et.setContext(r),et.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};let Ce=new L,Ie=new L;function ke(_e,O){O===null?_e.matrixWorld.copy(_e.matrix):_e.matrixWorld.multiplyMatrices(O.matrixWorld,_e.matrix),_e.matrixWorldInverse.copy(_e.matrixWorld).invert()}this.updateCamera=function(_e){if(r===null)return;J.near=X.near=q.near=_e.near,J.far=X.far=q.far=_e.far,$===J.near&&Re===J.far||(r.updateRenderState({depthNear:J.near,depthFar:J.far}),$=J.near,Re=J.far);let O=_e.parent,B=J.cameras;ke(J,O);for(let se=0;se<B.length;se++)ke(B[se],O);J.matrixWorld.decompose(J.position,J.quaternion,J.scale),_e.position.copy(J.position),_e.quaternion.copy(J.quaternion),_e.scale.copy(J.scale),_e.matrix.copy(J.matrix),_e.matrixWorld.copy(J.matrixWorld);let ce=_e.children;for(let se=0,ee=ce.length;se<ee;se++)ce[se].updateMatrixWorld(!0);B.length===2?function(se,ee,Le){Ce.setFromMatrixPosition(ee.matrixWorld),Ie.setFromMatrixPosition(Le.matrixWorld);let Ee=Ce.distanceTo(Ie),ne=ee.projectionMatrix.elements,C=Le.projectionMatrix.elements,K=ne[14]/(ne[10]-1),de=ne[14]/(ne[10]+1),pe=(ne[9]+1)/ne[5],ue=(ne[9]-1)/ne[5],Ne=(ne[8]-1)/ne[0],Je=(C[8]+1)/C[0],Be=K*Ne,ut=K*Je,lt=Ee/(-Ne+Je),on=lt*-Ne;ee.matrixWorld.decompose(se.position,se.quaternion,se.scale),se.translateX(on),se.translateZ(lt),se.matrixWorld.compose(se.position,se.quaternion,se.scale),se.matrixWorldInverse.copy(se.matrixWorld).invert();let Pt=K+lt,ln=de+lt,On=Be-on,lr=ut+(Ee-on),cr=pe*de/ln*Pt,hr=ue*de/ln*Pt;se.projectionMatrix.makePerspective(On,lr,cr,hr,Pt,ln)}(J,q,X):J.projectionMatrix.copy(q.projectionMatrix)},this.getCamera=function(){return J},this.getFoveation=function(){return f!==null?f.fixedFoveation:m!==null?m.fixedFoveation:void 0},this.setFoveation=function(_e){f!==null&&(f.fixedFoveation=_e),m!==null&&m.fixedFoveation!==void 0&&(m.fixedFoveation=_e)};let $e=null,et=new lc;et.setAnimationLoop(function(_e,O){if(u=O.getViewerPose(c),w=O,u!==null){let ce=u.views;m!==null&&i.bindXRFramebuffer(m.framebuffer);let se=!1;ce.length!==J.cameras.length&&(J.cameras.length=0,se=!0);for(let ee=0;ee<ce.length;ee++){let Le=ce[ee],Ee=null;if(m!==null)Ee=m.getViewport(Le);else{let C=d.getViewSubImage(f,Le);i.bindXRFramebuffer(p),C.depthStencilTexture!==void 0&&t.framebufferTexture2D(36160,A,3553,C.depthStencilTexture,0),t.framebufferTexture2D(36160,36064,3553,C.colorTexture,0),Ee=C.viewport}let ne=te[ee];ne.matrix.fromArray(Le.transform.matrix),ne.projectionMatrix.fromArray(Le.projectionMatrix),ne.viewport.set(Ee.x,Ee.y,Ee.width,Ee.height),ee===0&&J.matrix.copy(ne.matrix),se===!0&&J.cameras.push(ne)}g&&(i.bindXRFramebuffer(y),S!==null&&t.clear(S))}let B=r.inputSources;for(let ce=0;ce<D.length;ce++){let se=D[ce],ee=B[ce];se.update(ee,O,c)}if($e&&$e(_e,O),g){let ce=f.textureWidth,se=f.textureHeight;i.bindFramebuffer(36008,y),i.bindFramebuffer(36009,p),t.invalidateFramebuffer(36008,[A]),t.invalidateFramebuffer(36009,[A]),t.blitFramebuffer(0,0,ce,se,0,0,ce,se,16384,9728),t.invalidateFramebuffer(36008,[36064]),i.bindFramebuffer(36008,null),i.bindFramebuffer(36009,null),i.bindFramebuffer(36160,y)}w=null}),this.setAnimationLoop=function(_e){$e=_e},this.dispose=function(){}}}function Nf(s){function e(n,i){n.opacity.value=i.opacity,i.color&&n.diffuse.value.copy(i.color),i.emissive&&n.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity),i.map&&(n.map.value=i.map),i.alphaMap&&(n.alphaMap.value=i.alphaMap),i.specularMap&&(n.specularMap.value=i.specularMap),i.alphaTest>0&&(n.alphaTest.value=i.alphaTest);let r=s.get(i).envMap;if(r){n.envMap.value=r,n.flipEnvMap.value=r.isCubeTexture&&r.isRenderTargetTexture===!1?-1:1,n.reflectivity.value=i.reflectivity,n.ior.value=i.ior,n.refractionRatio.value=i.refractionRatio;let h=s.get(r).__maxMipLevel;h!==void 0&&(n.maxMipLevel.value=h)}let a,c;i.lightMap&&(n.lightMap.value=i.lightMap,n.lightMapIntensity.value=i.lightMapIntensity),i.aoMap&&(n.aoMap.value=i.aoMap,n.aoMapIntensity.value=i.aoMapIntensity),i.map?a=i.map:i.specularMap?a=i.specularMap:i.displacementMap?a=i.displacementMap:i.normalMap?a=i.normalMap:i.bumpMap?a=i.bumpMap:i.roughnessMap?a=i.roughnessMap:i.metalnessMap?a=i.metalnessMap:i.alphaMap?a=i.alphaMap:i.emissiveMap?a=i.emissiveMap:i.clearcoatMap?a=i.clearcoatMap:i.clearcoatNormalMap?a=i.clearcoatNormalMap:i.clearcoatRoughnessMap?a=i.clearcoatRoughnessMap:i.specularIntensityMap?a=i.specularIntensityMap:i.specularTintMap?a=i.specularTintMap:i.transmissionMap?a=i.transmissionMap:i.thicknessMap&&(a=i.thicknessMap),a!==void 0&&(a.isWebGLRenderTarget&&(a=a.texture),a.matrixAutoUpdate===!0&&a.updateMatrix(),n.uvTransform.value.copy(a.matrix)),i.aoMap?c=i.aoMap:i.lightMap&&(c=i.lightMap),c!==void 0&&(c.isWebGLRenderTarget&&(c=c.texture),c.matrixAutoUpdate===!0&&c.updateMatrix(),n.uv2Transform.value.copy(c.matrix))}function t(n,i){n.roughness.value=i.roughness,n.metalness.value=i.metalness,i.roughnessMap&&(n.roughnessMap.value=i.roughnessMap),i.metalnessMap&&(n.metalnessMap.value=i.metalnessMap),i.emissiveMap&&(n.emissiveMap.value=i.emissiveMap),i.bumpMap&&(n.bumpMap.value=i.bumpMap,n.bumpScale.value=i.bumpScale,i.side===1&&(n.bumpScale.value*=-1)),i.normalMap&&(n.normalMap.value=i.normalMap,n.normalScale.value.copy(i.normalScale),i.side===1&&n.normalScale.value.negate()),i.displacementMap&&(n.displacementMap.value=i.displacementMap,n.displacementScale.value=i.displacementScale,n.displacementBias.value=i.displacementBias),s.get(i).envMap&&(n.envMapIntensity.value=i.envMapIntensity)}return{refreshFogUniforms:function(n,i){n.fogColor.value.copy(i.color),i.isFog?(n.fogNear.value=i.near,n.fogFar.value=i.far):i.isFogExp2&&(n.fogDensity.value=i.density)},refreshMaterialUniforms:function(n,i,r,a,c){i.isMeshBasicMaterial?e(n,i):i.isMeshLambertMaterial?(e(n,i),function(h,u){u.emissiveMap&&(h.emissiveMap.value=u.emissiveMap)}(n,i)):i.isMeshToonMaterial?(e(n,i),function(h,u){u.gradientMap&&(h.gradientMap.value=u.gradientMap),u.emissiveMap&&(h.emissiveMap.value=u.emissiveMap),u.bumpMap&&(h.bumpMap.value=u.bumpMap,h.bumpScale.value=u.bumpScale,u.side===1&&(h.bumpScale.value*=-1)),u.normalMap&&(h.normalMap.value=u.normalMap,h.normalScale.value.copy(u.normalScale),u.side===1&&h.normalScale.value.negate()),u.displacementMap&&(h.displacementMap.value=u.displacementMap,h.displacementScale.value=u.displacementScale,h.displacementBias.value=u.displacementBias)}(n,i)):i.isMeshPhongMaterial?(e(n,i),function(h,u){h.specular.value.copy(u.specular),h.shininess.value=Math.max(u.shininess,1e-4),u.emissiveMap&&(h.emissiveMap.value=u.emissiveMap),u.bumpMap&&(h.bumpMap.value=u.bumpMap,h.bumpScale.value=u.bumpScale,u.side===1&&(h.bumpScale.value*=-1)),u.normalMap&&(h.normalMap.value=u.normalMap,h.normalScale.value.copy(u.normalScale),u.side===1&&h.normalScale.value.negate()),u.displacementMap&&(h.displacementMap.value=u.displacementMap,h.displacementScale.value=u.displacementScale,h.displacementBias.value=u.displacementBias)}(n,i)):i.isMeshStandardMaterial?(e(n,i),i.isMeshPhysicalMaterial?function(h,u,d){t(h,u),h.ior.value=u.ior,u.sheenTint&&h.sheenTint.value.copy(u.sheenTint),u.clearcoat>0&&(h.clearcoat.value=u.clearcoat,h.clearcoatRoughness.value=u.clearcoatRoughness,u.clearcoatMap&&(h.clearcoatMap.value=u.clearcoatMap),u.clearcoatRoughnessMap&&(h.clearcoatRoughnessMap.value=u.clearcoatRoughnessMap),u.clearcoatNormalMap&&(h.clearcoatNormalScale.value.copy(u.clearcoatNormalScale),h.clearcoatNormalMap.value=u.clearcoatNormalMap,u.side===1&&h.clearcoatNormalScale.value.negate())),u.transmission>0&&(h.transmission.value=u.transmission,h.transmissionSamplerMap.value=d.texture,h.transmissionSamplerSize.value.set(d.width,d.height),u.transmissionMap&&(h.transmissionMap.value=u.transmissionMap),h.thickness.value=u.thickness,u.thicknessMap&&(h.thicknessMap.value=u.thicknessMap),h.attenuationDistance.value=u.attenuationDistance,h.attenuationTint.value.copy(u.attenuationTint)),h.specularIntensity.value=u.specularIntensity,h.specularTint.value.copy(u.specularTint),u.specularIntensityMap&&(h.specularIntensityMap.value=u.specularIntensityMap),u.specularTintMap&&(h.specularTintMap.value=u.specularTintMap)}(n,i,c):t(n,i)):i.isMeshMatcapMaterial?(e(n,i),function(h,u){u.matcap&&(h.matcap.value=u.matcap),u.bumpMap&&(h.bumpMap.value=u.bumpMap,h.bumpScale.value=u.bumpScale,u.side===1&&(h.bumpScale.value*=-1)),u.normalMap&&(h.normalMap.value=u.normalMap,h.normalScale.value.copy(u.normalScale),u.side===1&&h.normalScale.value.negate()),u.displacementMap&&(h.displacementMap.value=u.displacementMap,h.displacementScale.value=u.displacementScale,h.displacementBias.value=u.displacementBias)}(n,i)):i.isMeshDepthMaterial?(e(n,i),function(h,u){u.displacementMap&&(h.displacementMap.value=u.displacementMap,h.displacementScale.value=u.displacementScale,h.displacementBias.value=u.displacementBias)}(n,i)):i.isMeshDistanceMaterial?(e(n,i),function(h,u){u.displacementMap&&(h.displacementMap.value=u.displacementMap,h.displacementScale.value=u.displacementScale,h.displacementBias.value=u.displacementBias),h.referencePosition.value.copy(u.referencePosition),h.nearDistance.value=u.nearDistance,h.farDistance.value=u.farDistance}(n,i)):i.isMeshNormalMaterial?(e(n,i),function(h,u){u.bumpMap&&(h.bumpMap.value=u.bumpMap,h.bumpScale.value=u.bumpScale,u.side===1&&(h.bumpScale.value*=-1)),u.normalMap&&(h.normalMap.value=u.normalMap,h.normalScale.value.copy(u.normalScale),u.side===1&&h.normalScale.value.negate()),u.displacementMap&&(h.displacementMap.value=u.displacementMap,h.displacementScale.value=u.displacementScale,h.displacementBias.value=u.displacementBias)}(n,i)):i.isLineBasicMaterial?(function(h,u){h.diffuse.value.copy(u.color),h.opacity.value=u.opacity}(n,i),i.isLineDashedMaterial&&function(h,u){h.dashSize.value=u.dashSize,h.totalSize.value=u.dashSize+u.gapSize,h.scale.value=u.scale}(n,i)):i.isPointsMaterial?function(h,u,d,p){h.diffuse.value.copy(u.color),h.opacity.value=u.opacity,h.size.value=u.size*d,h.scale.value=.5*p,u.map&&(h.map.value=u.map),u.alphaMap&&(h.alphaMap.value=u.alphaMap),u.alphaTest>0&&(h.alphaTest.value=u.alphaTest);let f;u.map?f=u.map:u.alphaMap&&(f=u.alphaMap),f!==void 0&&(f.matrixAutoUpdate===!0&&f.updateMatrix(),h.uvTransform.value.copy(f.matrix))}(n,i,r,a):i.isSpriteMaterial?function(h,u){h.diffuse.value.copy(u.color),h.opacity.value=u.opacity,h.rotation.value=u.rotation,u.map&&(h.map.value=u.map),u.alphaMap&&(h.alphaMap.value=u.alphaMap),u.alphaTest>0&&(h.alphaTest.value=u.alphaTest);let d;u.map?d=u.map:u.alphaMap&&(d=u.alphaMap),d!==void 0&&(d.matrixAutoUpdate===!0&&d.updateMatrix(),h.uvTransform.value.copy(d.matrix))}(n,i):i.isShadowMaterial?(n.color.value.copy(i.color),n.opacity.value=i.opacity):i.isShaderMaterial&&(i.uniformsNeedUpdate=!1)}}}function It(s={}){let e=s.canvas!==void 0?s.canvas:function(){let I=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return I.style.display="block",I}(),t=s.context!==void 0?s.context:null,n=s.alpha!==void 0&&s.alpha,i=s.depth===void 0||s.depth,r=s.stencil===void 0||s.stencil,a=s.antialias!==void 0&&s.antialias,c=s.premultipliedAlpha===void 0||s.premultipliedAlpha,h=s.preserveDrawingBuffer!==void 0&&s.preserveDrawingBuffer,u=s.powerPreference!==void 0?s.powerPreference:"default",d=s.failIfMajorPerformanceCaveat!==void 0&&s.failIfMajorPerformanceCaveat,p=null,f=null,m=[],g=[];this.domElement=e,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=3e3,this.physicallyCorrectLights=!1,this.toneMapping=0,this.toneMappingExposure=1;let y=this,x=!1,v=0,w=0,A=null,S=-1,D=null,F=new _t,q=new _t,X=null,te=e.width,J=e.height,$=1,Re=null,ye=null,ae=new _t(0,0,te,J),be=new _t(0,0,te,J),Ce=!1,Ie=[],ke=new ss,$e=!1,et=!1,_e=null,O=new Xe,B=new L,ce={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function se(){return A===null?$:1}let ee,Le,Ee,ne,C,K,de,pe,ue,Ne,Je,Be,ut,lt,on,Pt,ln,On,lr,cr,hr,Un,Sn,Te=t;function _u(I,oe){for(let Q=0;Q<I.length;Q++){let le=I[Q],we=e.getContext(le,oe);if(we!==null)return we}return null}try{let I={alpha:n,depth:i,stencil:r,antialias:a,premultipliedAlpha:c,preserveDrawingBuffer:h,powerPreference:u,failIfMajorPerformanceCaveat:d};if(e.addEventListener("webglcontextlost",Mu,!1),e.addEventListener("webglcontextrestored",wu,!1),Te===null){let oe=["webgl2","webgl","experimental-webgl"];if(y.isWebGL1Renderer===!0&&oe.shift(),Te=_u(oe,I),Te===null)throw _u(oe)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}Te.getShaderPrecisionFormat===void 0&&(Te.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(I){throw console.error("THREE.WebGLRenderer: "+I.message),I}function bu(){ee=new xp(Te),Le=new pp(Te,ee,s),ee.init(Le),Un=new Gc(Te,ee,Le),Ee=new Df(Te,ee,Le),Ie[0]=1029,ne=new Mp(Te),C=new Sf,K=new If(Te,ee,Ee,C,Le,Un,ne),de=new mp(y),pe=new vp(y),ue=new cp(Te,Le),Sn=new up(Te,ee,ue,Le),Ne=new _p(Te,ue,ne,Sn),Je=new Ep(Te,Ne,ue,ne),lr=new Tp(Te),Pt=new fp(C),Be=new wf(y,de,pe,ee,Le,Sn,Pt),ut=new Nf(C),lt=new Ef(C),on=new Pf(ee,Le),On=new hp(y,de,Ee,Je,c),ln=new Uc(y,Je,Le),cr=new dp(Te,ee,ne,Le),hr=new bp(Te,ee,ne,Le),ne.programs=Be.programs,y.capabilities=Le,y.extensions=ee,y.properties=C,y.renderLists=lt,y.shadowMap=ln,y.state=Ee,y.info=ne}bu();let Fn=new Ff(y,Te);function Mu(I){I.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),x=!0}function wu(){console.log("THREE.WebGLRenderer: Context Restored."),x=!1;let I=ne.autoReset,oe=ln.enabled,Q=ln.autoUpdate,le=ln.needsUpdate,we=ln.type;bu(),ne.autoReset=I,ln.enabled=oe,ln.autoUpdate=Q,ln.needsUpdate=le,ln.type=we}function Su(I){let oe=I.target;oe.removeEventListener("dispose",Su),function(Q){(function(le){let we=C.get(le).programs;we!==void 0&&we.forEach(function(ot){Be.releaseProgram(ot)})})(Q),C.remove(Q)}(oe)}this.xr=Fn,this.getContext=function(){return Te},this.getContextAttributes=function(){return Te.getContextAttributes()},this.forceContextLoss=function(){let I=ee.get("WEBGL_lose_context");I&&I.loseContext()},this.forceContextRestore=function(){let I=ee.get("WEBGL_lose_context");I&&I.restoreContext()},this.getPixelRatio=function(){return $},this.setPixelRatio=function(I){I!==void 0&&($=I,this.setSize(te,J,!1))},this.getSize=function(I){return I.set(te,J)},this.setSize=function(I,oe,Q){Fn.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(te=I,J=oe,e.width=Math.floor(I*$),e.height=Math.floor(oe*$),Q!==!1&&(e.style.width=I+"px",e.style.height=oe+"px"),this.setViewport(0,0,I,oe))},this.getDrawingBufferSize=function(I){return I.set(te*$,J*$).floor()},this.setDrawingBufferSize=function(I,oe,Q){te=I,J=oe,$=Q,e.width=Math.floor(I*Q),e.height=Math.floor(oe*Q),this.setViewport(0,0,I,oe)},this.getCurrentViewport=function(I){return I.copy(F)},this.getViewport=function(I){return I.copy(ae)},this.setViewport=function(I,oe,Q,le){I.isVector4?ae.set(I.x,I.y,I.z,I.w):ae.set(I,oe,Q,le),Ee.viewport(F.copy(ae).multiplyScalar($).floor())},this.getScissor=function(I){return I.copy(be)},this.setScissor=function(I,oe,Q,le){I.isVector4?be.set(I.x,I.y,I.z,I.w):be.set(I,oe,Q,le),Ee.scissor(q.copy(be).multiplyScalar($).floor())},this.getScissorTest=function(){return Ce},this.setScissorTest=function(I){Ee.setScissorTest(Ce=I)},this.setOpaqueSort=function(I){Re=I},this.setTransparentSort=function(I){ye=I},this.getClearColor=function(I){return I.copy(On.getClearColor())},this.setClearColor=function(){On.setClearColor.apply(On,arguments)},this.getClearAlpha=function(){return On.getClearAlpha()},this.setClearAlpha=function(){On.setClearAlpha.apply(On,arguments)},this.clear=function(I,oe,Q){let le=0;(I===void 0||I)&&(le|=16384),(oe===void 0||oe)&&(le|=256),(Q===void 0||Q)&&(le|=1024),Te.clear(le)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",Mu,!1),e.removeEventListener("webglcontextrestored",wu,!1),lt.dispose(),on.dispose(),C.dispose(),de.dispose(),pe.dispose(),Je.dispose(),Sn.dispose(),Fn.dispose(),Fn.removeEventListener("sessionstart",Tu),Fn.removeEventListener("sessionend",Eu),_e&&(_e.dispose(),_e=null),ur.stop()},this.renderBufferImmediate=function(I,oe){Sn.initAttributes();let Q=C.get(I);I.hasPositions&&!Q.position&&(Q.position=Te.createBuffer()),I.hasNormals&&!Q.normal&&(Q.normal=Te.createBuffer()),I.hasUvs&&!Q.uv&&(Q.uv=Te.createBuffer()),I.hasColors&&!Q.color&&(Q.color=Te.createBuffer());let le=oe.getAttributes();I.hasPositions&&(Te.bindBuffer(34962,Q.position),Te.bufferData(34962,I.positionArray,35048),Sn.enableAttribute(le.position.location),Te.vertexAttribPointer(le.position.location,3,5126,!1,0,0)),I.hasNormals&&(Te.bindBuffer(34962,Q.normal),Te.bufferData(34962,I.normalArray,35048),Sn.enableAttribute(le.normal.location),Te.vertexAttribPointer(le.normal.location,3,5126,!1,0,0)),I.hasUvs&&(Te.bindBuffer(34962,Q.uv),Te.bufferData(34962,I.uvArray,35048),Sn.enableAttribute(le.uv.location),Te.vertexAttribPointer(le.uv.location,2,5126,!1,0,0)),I.hasColors&&(Te.bindBuffer(34962,Q.color),Te.bufferData(34962,I.colorArray,35048),Sn.enableAttribute(le.color.location),Te.vertexAttribPointer(le.color.location,3,5126,!1,0,0)),Sn.disableUnusedAttributes(),Te.drawArrays(4,0,I.count),I.count=0},this.renderBufferDirect=function(I,oe,Q,le,we,ot){oe===null&&(oe=ce);let Ye=we.isMesh&&we.matrixWorld.determinant()<0,ct=Cu(I,oe,le,we);Ee.setMaterial(le,Ye);let mt=Q.index,Ot=Q.attributes.position;if(mt===null){if(Ot===void 0||Ot.count===0)return}else if(mt.count===0)return;let wt,gt=1;le.wireframe===!0&&(mt=Ne.getWireframeAttribute(Q),gt=2),Q.morphAttributes.position===void 0&&Q.morphAttributes.normal===void 0||lr.update(we,Q,le,ct),Sn.setup(we,le,ct,Q,mt);let ht=cr;mt!==null&&(wt=ue.get(mt),ht=hr,ht.setIndex(wt));let dr=mt!==null?mt.count:Ot.count,Xt=Q.drawRange.start*gt,Bi=Q.drawRange.count*gt,Qn=ot!==null?ot.start*gt:0,pr=ot!==null?ot.count*gt:1/0,Hi=Math.max(Xt,Qn),cn=Math.min(dr,Xt+Bi,Qn+pr)-1,oi=Math.max(0,cn-Hi+1);if(oi!==0){if(we.isMesh)le.wireframe===!0?(Ee.setLineWidth(le.wireframeLinewidth*se()),ht.setMode(1)):ht.setMode(4);else if(we.isLine){let fn=le.linewidth;fn===void 0&&(fn=1),Ee.setLineWidth(fn*se()),we.isLineSegments?ht.setMode(1):we.isLineLoop?ht.setMode(2):ht.setMode(3)}else we.isPoints?ht.setMode(0):we.isSprite&&ht.setMode(4);if(we.isInstancedMesh)ht.renderInstances(Hi,oi,we.count);else if(Q.isInstancedBufferGeometry){let fn=Math.min(Q.instanceCount,Q._maxInstanceCount);ht.renderInstances(Hi,oi,fn)}else ht.render(Hi,oi)}},this.compile=function(I,oe){f=on.get(I),f.init(),g.push(f),I.traverseVisible(function(Q){Q.isLight&&Q.layers.test(oe.layers)&&(f.pushLight(Q),Q.castShadow&&f.pushShadow(Q))}),f.setupLights(y.physicallyCorrectLights),I.traverse(function(Q){let le=Q.material;if(le)if(Array.isArray(le))for(let we=0;we<le.length;we++)Rl(le[we],I,Q);else Rl(le,I,Q)}),g.pop(),f=null};let Ll=null;function Tu(){ur.stop()}function Eu(){ur.start()}let ur=new lc;function Au(I,oe,Q,le){if(I.visible===!1)return;if(I.layers.test(oe.layers)){if(I.isGroup)Q=I.renderOrder;else if(I.isLOD)I.autoUpdate===!0&&I.update(oe);else if(I.isLight)f.pushLight(I),I.castShadow&&f.pushShadow(I);else if(I.isSprite){if(!I.frustumCulled||ke.intersectsSprite(I)){le&&B.setFromMatrixPosition(I.matrixWorld).applyMatrix4(O);let ot=Je.update(I),Ye=I.material;Ye.visible&&p.push(I,ot,Ye,Q,B.z,null)}}else if(I.isImmediateRenderObject)le&&B.setFromMatrixPosition(I.matrixWorld).applyMatrix4(O),p.push(I,null,I.material,Q,B.z,null);else if((I.isMesh||I.isLine||I.isPoints)&&(I.isSkinnedMesh&&I.skeleton.frame!==ne.render.frame&&(I.skeleton.update(),I.skeleton.frame=ne.render.frame),!I.frustumCulled||ke.intersectsObject(I))){le&&B.setFromMatrixPosition(I.matrixWorld).applyMatrix4(O);let ot=Je.update(I),Ye=I.material;if(Array.isArray(Ye)){let ct=ot.groups;for(let mt=0,Ot=ct.length;mt<Ot;mt++){let wt=ct[mt],gt=Ye[wt.materialIndex];gt&&gt.visible&&p.push(I,ot,gt,Q,B.z,wt)}}else Ye.visible&&p.push(I,ot,Ye,Q,B.z,null)}}let we=I.children;for(let ot=0,Ye=we.length;ot<Ye;ot++)Au(we[ot],oe,Q,le)}function Lu(I,oe,Q,le){let we=I.opaque,ot=I.transmissive,Ye=I.transparent;f.setupLightsView(Q),ot.length>0&&function(ct,mt,Ot){if(_e===null){let ht=a===!0&&Le.isWebGL2===!0;_e=new(ht?$r:$t)(1024,1024,{generateMipmaps:!0,type:Un.convert(1016)!==null?1016:1009,minFilter:1008,magFilter:1003,wrapS:1001,wrapT:1001})}let wt=y.getRenderTarget();y.setRenderTarget(_e),y.clear();let gt=y.toneMapping;y.toneMapping=0,Wa(ct,mt,Ot),y.toneMapping=gt,K.updateMultisampleRenderTarget(_e),K.updateRenderTargetMipmap(_e),y.setRenderTarget(wt)}(we,oe,Q),le&&Ee.viewport(F.copy(le)),we.length>0&&Wa(we,oe,Q),ot.length>0&&Wa(ot,oe,Q),Ye.length>0&&Wa(Ye,oe,Q)}function Wa(I,oe,Q){let le=oe.isScene===!0?oe.overrideMaterial:null;for(let we=0,ot=I.length;we<ot;we++){let Ye=I[we],ct=Ye.object,mt=Ye.geometry,Ot=le===null?Ye.material:le,wt=Ye.group;ct.layers.test(Q.layers)&&mm(ct,oe,Q,mt,Ot,wt)}}function mm(I,oe,Q,le,we,ot){if(I.onBeforeRender(y,oe,Q,le,we,ot),I.modelViewMatrix.multiplyMatrices(Q.matrixWorldInverse,I.matrixWorld),I.normalMatrix.getNormalMatrix(I.modelViewMatrix),I.isImmediateRenderObject){let Ye=Cu(Q,oe,we,I);Ee.setMaterial(we),Sn.reset(),function(ct,mt){ct.render(function(Ot){y.renderBufferImmediate(Ot,mt)})}(I,Ye)}else we.transparent===!0&&we.side===2?(we.side=1,we.needsUpdate=!0,y.renderBufferDirect(Q,oe,le,we,I,ot),we.side=0,we.needsUpdate=!0,y.renderBufferDirect(Q,oe,le,we,I,ot),we.side=2):y.renderBufferDirect(Q,oe,le,we,I,ot);I.onAfterRender(y,oe,Q,le,we,ot)}function Rl(I,oe,Q){oe.isScene!==!0&&(oe=ce);let le=C.get(I),we=f.state.lights,ot=f.state.shadowsArray,Ye=we.state.version,ct=Be.getParameters(I,we.state,ot,oe,Q),mt=Be.getProgramCacheKey(ct),Ot=le.programs;le.environment=I.isMeshStandardMaterial?oe.environment:null,le.fog=oe.fog,le.envMap=(I.isMeshStandardMaterial?pe:de).get(I.envMap||le.environment),Ot===void 0&&(I.addEventListener("dispose",Su),Ot=new Map,le.programs=Ot);let wt=Ot.get(mt);if(wt!==void 0){if(le.currentProgram===wt&&le.lightsStateVersion===Ye)return Ru(I,ct),wt}else ct.uniforms=Be.getUniforms(I),I.onBuild(ct,y),I.onBeforeCompile(ct,y),wt=Be.acquireProgram(ct,mt),Ot.set(mt,wt),le.uniforms=ct.uniforms;let gt=le.uniforms;(I.isShaderMaterial||I.isRawShaderMaterial)&&I.clipping!==!0||(gt.clippingPlanes=Pt.uniform),Ru(I,ct),le.needsLights=function(Xt){return Xt.isMeshLambertMaterial||Xt.isMeshToonMaterial||Xt.isMeshPhongMaterial||Xt.isMeshStandardMaterial||Xt.isShadowMaterial||Xt.isShaderMaterial&&Xt.lights===!0}(I),le.lightsStateVersion=Ye,le.needsLights&&(gt.ambientLightColor.value=we.state.ambient,gt.lightProbe.value=we.state.probe,gt.directionalLights.value=we.state.directional,gt.directionalLightShadows.value=we.state.directionalShadow,gt.spotLights.value=we.state.spot,gt.spotLightShadows.value=we.state.spotShadow,gt.rectAreaLights.value=we.state.rectArea,gt.ltc_1.value=we.state.rectAreaLTC1,gt.ltc_2.value=we.state.rectAreaLTC2,gt.pointLights.value=we.state.point,gt.pointLightShadows.value=we.state.pointShadow,gt.hemisphereLights.value=we.state.hemi,gt.directionalShadowMap.value=we.state.directionalShadowMap,gt.directionalShadowMatrix.value=we.state.directionalShadowMatrix,gt.spotShadowMap.value=we.state.spotShadowMap,gt.spotShadowMatrix.value=we.state.spotShadowMatrix,gt.pointShadowMap.value=we.state.pointShadowMap,gt.pointShadowMatrix.value=we.state.pointShadowMatrix);let ht=wt.getUniforms(),dr=Di.seqWithValue(ht.seq,gt);return le.currentProgram=wt,le.uniformsList=dr,wt}function Ru(I,oe){let Q=C.get(I);Q.outputEncoding=oe.outputEncoding,Q.instancing=oe.instancing,Q.skinning=oe.skinning,Q.morphTargets=oe.morphTargets,Q.morphNormals=oe.morphNormals,Q.numClippingPlanes=oe.numClippingPlanes,Q.numIntersection=oe.numClipIntersection,Q.vertexAlphas=oe.vertexAlphas,Q.vertexTangents=oe.vertexTangents}function Cu(I,oe,Q,le){oe.isScene!==!0&&(oe=ce),K.resetTextureUnits();let we=oe.fog,ot=Q.isMeshStandardMaterial?oe.environment:null,Ye=A===null?y.outputEncoding:A.texture.encoding,ct=(Q.isMeshStandardMaterial?pe:de).get(Q.envMap||ot),mt=Q.vertexColors===!0&&!!le.geometry&&!!le.geometry.attributes.color&&le.geometry.attributes.color.itemSize===4,Ot=!!le.geometry&&!!le.geometry.attributes.tangent,wt=!!le.geometry&&!!le.geometry.morphAttributes.position,gt=!!le.geometry&&!!le.geometry.morphAttributes.normal,ht=C.get(Q),dr=f.state.lights;if($e===!0&&(et===!0||I!==D)){let ei=I===D&&Q.id===S;Pt.setState(Q,I,ei)}let Xt=!1;Q.version===ht.__version?ht.needsLights&&ht.lightsStateVersion!==dr.state.version||ht.outputEncoding!==Ye||le.isInstancedMesh&&ht.instancing===!1?Xt=!0:le.isInstancedMesh||ht.instancing!==!0?le.isSkinnedMesh&&ht.skinning===!1?Xt=!0:le.isSkinnedMesh||ht.skinning!==!0?ht.envMap!==ct||Q.fog&&ht.fog!==we?Xt=!0:ht.numClippingPlanes===void 0||ht.numClippingPlanes===Pt.numPlanes&&ht.numIntersection===Pt.numIntersection?(ht.vertexAlphas!==mt||ht.vertexTangents!==Ot||ht.morphTargets!==wt||ht.morphNormals!==gt)&&(Xt=!0):Xt=!0:Xt=!0:Xt=!0:(Xt=!0,ht.__version=Q.version);let Bi=ht.currentProgram;Xt===!0&&(Bi=Rl(Q,oe,le));let Qn=!1,pr=!1,Hi=!1,cn=Bi.getUniforms(),oi=ht.uniforms;if(Ee.useProgram(Bi.program)&&(Qn=!0,pr=!0,Hi=!0),Q.id!==S&&(S=Q.id,pr=!0),Qn||D!==I){if(cn.setValue(Te,"projectionMatrix",I.projectionMatrix),Le.logarithmicDepthBuffer&&cn.setValue(Te,"logDepthBufFC",2/(Math.log(I.far+1)/Math.LN2)),D!==I&&(D=I,pr=!0,Hi=!0),Q.isShaderMaterial||Q.isMeshPhongMaterial||Q.isMeshToonMaterial||Q.isMeshStandardMaterial||Q.envMap){let ei=cn.map.cameraPosition;ei!==void 0&&ei.setValue(Te,B.setFromMatrixPosition(I.matrixWorld))}(Q.isMeshPhongMaterial||Q.isMeshToonMaterial||Q.isMeshLambertMaterial||Q.isMeshBasicMaterial||Q.isMeshStandardMaterial||Q.isShaderMaterial)&&cn.setValue(Te,"isOrthographic",I.isOrthographicCamera===!0),(Q.isMeshPhongMaterial||Q.isMeshToonMaterial||Q.isMeshLambertMaterial||Q.isMeshBasicMaterial||Q.isMeshStandardMaterial||Q.isShaderMaterial||Q.isShadowMaterial||le.isSkinnedMesh)&&cn.setValue(Te,"viewMatrix",I.matrixWorldInverse)}if(le.isSkinnedMesh){cn.setOptional(Te,le,"bindMatrix"),cn.setOptional(Te,le,"bindMatrixInverse");let ei=le.skeleton;ei&&(Le.floatVertexTextures?(ei.boneTexture===null&&ei.computeBoneTexture(),cn.setValue(Te,"boneTexture",ei.boneTexture,K),cn.setValue(Te,"boneTextureSize",ei.boneTextureSize)):cn.setOptional(Te,ei,"boneMatrices"))}var fn,$n;return(pr||ht.receiveShadow!==le.receiveShadow)&&(ht.receiveShadow=le.receiveShadow,cn.setValue(Te,"receiveShadow",le.receiveShadow)),pr&&(cn.setValue(Te,"toneMappingExposure",y.toneMappingExposure),ht.needsLights&&($n=Hi,(fn=oi).ambientLightColor.needsUpdate=$n,fn.lightProbe.needsUpdate=$n,fn.directionalLights.needsUpdate=$n,fn.directionalLightShadows.needsUpdate=$n,fn.pointLights.needsUpdate=$n,fn.pointLightShadows.needsUpdate=$n,fn.spotLights.needsUpdate=$n,fn.spotLightShadows.needsUpdate=$n,fn.rectAreaLights.needsUpdate=$n,fn.hemisphereLights.needsUpdate=$n),we&&Q.fog&&ut.refreshFogUniforms(oi,we),ut.refreshMaterialUniforms(oi,Q,$,J,_e),Di.upload(Te,ht.uniformsList,oi,K)),Q.isShaderMaterial&&Q.uniformsNeedUpdate===!0&&(Di.upload(Te,ht.uniformsList,oi,K),Q.uniformsNeedUpdate=!1),Q.isSpriteMaterial&&cn.setValue(Te,"center",le.center),cn.setValue(Te,"modelViewMatrix",le.modelViewMatrix),cn.setValue(Te,"normalMatrix",le.normalMatrix),cn.setValue(Te,"modelMatrix",le.matrixWorld),Bi}ur.setAnimationLoop(function(I){Ll&&Ll(I)}),typeof window<"u"&&ur.setContext(window),this.setAnimationLoop=function(I){Ll=I,Fn.setAnimationLoop(I),I===null?ur.stop():ur.start()},Fn.addEventListener("sessionstart",Tu),Fn.addEventListener("sessionend",Eu),this.render=function(I,oe){if(oe!==void 0&&oe.isCamera!==!0)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(x===!0)return;I.autoUpdate===!0&&I.updateMatrixWorld(),oe.parent===null&&oe.updateMatrixWorld(),Fn.enabled===!0&&Fn.isPresenting===!0&&(Fn.cameraAutoUpdate===!0&&Fn.updateCamera(oe),oe=Fn.getCamera()),I.isScene===!0&&I.onBeforeRender(y,I,oe,A),f=on.get(I,g.length),f.init(),g.push(f),O.multiplyMatrices(oe.projectionMatrix,oe.matrixWorldInverse),ke.setFromProjectionMatrix(O),et=this.localClippingEnabled,$e=Pt.init(this.clippingPlanes,et,oe),p=lt.get(I,m.length),p.init(),m.push(p),Au(I,oe,0,y.sortObjects),p.finish(),y.sortObjects===!0&&p.sort(Re,ye),$e===!0&&Pt.beginShadows();let Q=f.state.shadowsArray;if(ln.render(Q,I,oe),$e===!0&&Pt.endShadows(),this.info.autoReset===!0&&this.info.reset(),On.render(p,I),f.setupLights(y.physicallyCorrectLights),oe.isArrayCamera){let le=oe.cameras;for(let we=0,ot=le.length;we<ot;we++){let Ye=le[we];Lu(p,I,Ye,Ye.viewport)}}else Lu(p,I,oe);A!==null&&(K.updateMultisampleRenderTarget(A),K.updateRenderTargetMipmap(A)),I.isScene===!0&&I.onAfterRender(y,I,oe),Ee.buffers.depth.setTest(!0),Ee.buffers.depth.setMask(!0),Ee.buffers.color.setMask(!0),Ee.setPolygonOffset(!1),Sn.resetDefaultState(),S=-1,D=null,g.pop(),f=g.length>0?g[g.length-1]:null,m.pop(),p=m.length>0?m[m.length-1]:null},this.getActiveCubeFace=function(){return v},this.getActiveMipmapLevel=function(){return w},this.getRenderTarget=function(){return A},this.setRenderTarget=function(I,oe=0,Q=0){A=I,v=oe,w=Q,I&&C.get(I).__webglFramebuffer===void 0&&K.setupRenderTarget(I);let le=null,we=!1,ot=!1;if(I){let Ye=I.texture;(Ye.isDataTexture3D||Ye.isDataTexture2DArray)&&(ot=!0);let ct=C.get(I).__webglFramebuffer;I.isWebGLCubeRenderTarget?(le=ct[oe],we=!0):le=I.isWebGLMultisampleRenderTarget?C.get(I).__webglMultisampledFramebuffer:ct,F.copy(I.viewport),q.copy(I.scissor),X=I.scissorTest}else F.copy(ae).multiplyScalar($).floor(),q.copy(be).multiplyScalar($).floor(),X=Ce;if(Ee.bindFramebuffer(36160,le)&&Le.drawBuffers){let Ye=!1;if(I)if(I.isWebGLMultipleRenderTargets){let ct=I.texture;if(Ie.length!==ct.length||Ie[0]!==36064){for(let mt=0,Ot=ct.length;mt<Ot;mt++)Ie[mt]=36064+mt;Ie.length=ct.length,Ye=!0}}else Ie.length===1&&Ie[0]===36064||(Ie[0]=36064,Ie.length=1,Ye=!0);else Ie.length===1&&Ie[0]===1029||(Ie[0]=1029,Ie.length=1,Ye=!0);Ye&&(Le.isWebGL2?Te.drawBuffers(Ie):ee.get("WEBGL_draw_buffers").drawBuffersWEBGL(Ie))}if(Ee.viewport(F),Ee.scissor(q),Ee.setScissorTest(X),we){let Ye=C.get(I.texture);Te.framebufferTexture2D(36160,36064,34069+oe,Ye.__webglTexture,Q)}else if(ot){let Ye=C.get(I.texture),ct=oe||0;Te.framebufferTextureLayer(36160,36064,Ye.__webglTexture,Q||0,ct)}S=-1},this.readRenderTargetPixels=function(I,oe,Q,le,we,ot,Ye){if(!I||!I.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let ct=C.get(I).__webglFramebuffer;if(I.isWebGLCubeRenderTarget&&Ye!==void 0&&(ct=ct[Ye]),ct){Ee.bindFramebuffer(36160,ct);try{let mt=I.texture,Ot=mt.format,wt=mt.type;if(Ot!==1023&&Un.convert(Ot)!==Te.getParameter(35739))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");let gt=wt===1016&&(ee.has("EXT_color_buffer_half_float")||Le.isWebGL2&&ee.has("EXT_color_buffer_float"));if(!(wt===1009||Un.convert(wt)===Te.getParameter(35738)||wt===1015&&(Le.isWebGL2||ee.has("OES_texture_float")||ee.has("WEBGL_color_buffer_float"))||gt))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");Te.checkFramebufferStatus(36160)===36053?oe>=0&&oe<=I.width-le&&Q>=0&&Q<=I.height-we&&Te.readPixels(oe,Q,le,we,Un.convert(Ot),Un.convert(wt),ot):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{let mt=A!==null?C.get(A).__webglFramebuffer:null;Ee.bindFramebuffer(36160,mt)}}},this.copyFramebufferToTexture=function(I,oe,Q=0){let le=Math.pow(2,-Q),we=Math.floor(oe.image.width*le),ot=Math.floor(oe.image.height*le),Ye=Un.convert(oe.format);Le.isWebGL2&&(Ye===6407&&(Ye=32849),Ye===6408&&(Ye=32856)),K.setTexture2D(oe,0),Te.copyTexImage2D(3553,Q,Ye,I.x,I.y,we,ot,0),Ee.unbindTexture()},this.copyTextureToTexture=function(I,oe,Q,le=0){let we=oe.image.width,ot=oe.image.height,Ye=Un.convert(Q.format),ct=Un.convert(Q.type);K.setTexture2D(Q,0),Te.pixelStorei(37440,Q.flipY),Te.pixelStorei(37441,Q.premultiplyAlpha),Te.pixelStorei(3317,Q.unpackAlignment),oe.isDataTexture?Te.texSubImage2D(3553,le,I.x,I.y,we,ot,Ye,ct,oe.image.data):oe.isCompressedTexture?Te.compressedTexSubImage2D(3553,le,I.x,I.y,oe.mipmaps[0].width,oe.mipmaps[0].height,Ye,oe.mipmaps[0].data):Te.texSubImage2D(3553,le,I.x,I.y,Ye,ct,oe.image),le===0&&Q.generateMipmaps&&Te.generateMipmap(3553),Ee.unbindTexture()},this.copyTextureToTexture3D=function(I,oe,Q,le,we=0){if(y.isWebGL1Renderer)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");let ot=I.max.x-I.min.x+1,Ye=I.max.y-I.min.y+1,ct=I.max.z-I.min.z+1,mt=Un.convert(le.format),Ot=Un.convert(le.type),wt;if(le.isDataTexture3D)K.setTexture3D(le,0),wt=32879;else{if(!le.isDataTexture2DArray)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");K.setTexture2DArray(le,0),wt=35866}Te.pixelStorei(37440,le.flipY),Te.pixelStorei(37441,le.premultiplyAlpha),Te.pixelStorei(3317,le.unpackAlignment);let gt=Te.getParameter(3314),ht=Te.getParameter(32878),dr=Te.getParameter(3316),Xt=Te.getParameter(3315),Bi=Te.getParameter(32877),Qn=Q.isCompressedTexture?Q.mipmaps[0]:Q.image;Te.pixelStorei(3314,Qn.width),Te.pixelStorei(32878,Qn.height),Te.pixelStorei(3316,I.min.x),Te.pixelStorei(3315,I.min.y),Te.pixelStorei(32877,I.min.z),Q.isDataTexture||Q.isDataTexture3D?Te.texSubImage3D(wt,we,oe.x,oe.y,oe.z,ot,Ye,ct,mt,Ot,Qn.data):Q.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),Te.compressedTexSubImage3D(wt,we,oe.x,oe.y,oe.z,ot,Ye,ct,mt,Qn.data)):Te.texSubImage3D(wt,we,oe.x,oe.y,oe.z,ot,Ye,ct,mt,Ot,Qn),Te.pixelStorei(3314,gt),Te.pixelStorei(32878,ht),Te.pixelStorei(3316,dr),Te.pixelStorei(3315,Xt),Te.pixelStorei(32877,Bi),we===0&&le.generateMipmaps&&Te.generateMipmap(wt),Ee.unbindTexture()},this.initTexture=function(I){K.setTexture2D(I,0),Ee.unbindTexture()},this.resetState=function(){v=0,w=0,A=null,Ee.reset(),Sn.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}class kc extends It{}kc.prototype.isWebGL1Renderer=!0;class cs{constructor(e,t=25e-5){this.name="",this.color=new De(e),this.density=t}clone(){return new cs(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}cs.prototype.isFogExp2=!0;class hs{constructor(e,t=1,n=1e3){this.name="",this.color=new De(e),this.near=t,this.far=n}clone(){return new hs(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}hs.prototype.isFog=!0;class la extends pt{constructor(){super(),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.autoUpdate=e.autoUpdate,this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){let t=super.toJSON(e);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),t}}la.prototype.isScene=!0;class Zi{constructor(e,t){this.array=e,this.stride=t,this.count=e!==void 0?e.length/t:0,this.usage=35044,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=nt()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,n){e*=this.stride,n*=t.stride;for(let i=0,r=this.stride;i<r;i++)this.array[e+i]=t.array[n+i];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=nt()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);let t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),n=new this.constructor(t,this.stride);return n.setUsage(this.usage),n}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=nt()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}Zi.prototype.isInterleavedBuffer=!0;let Jt=new L;class Ii{constructor(e,t,n,i=!1){this.name="",this.data=e,this.itemSize=t,this.offset=n,this.normalized=i===!0}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,n=this.data.count;t<n;t++)Jt.x=this.getX(t),Jt.y=this.getY(t),Jt.z=this.getZ(t),Jt.applyMatrix4(e),this.setXYZ(t,Jt.x,Jt.y,Jt.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)Jt.x=this.getX(t),Jt.y=this.getY(t),Jt.z=this.getZ(t),Jt.applyNormalMatrix(e),this.setXYZ(t,Jt.x,Jt.y,Jt.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)Jt.x=this.getX(t),Jt.y=this.getY(t),Jt.z=this.getZ(t),Jt.transformDirection(e),this.setXYZ(t,Jt.x,Jt.y,Jt.z);return this}setX(e,t){return this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){return this.data.array[e*this.data.stride+this.offset]}getY(e){return this.data.array[e*this.data.stride+this.offset+1]}getZ(e){return this.data.array[e*this.data.stride+this.offset+2]}getW(e){return this.data.array[e*this.data.stride+this.offset+3]}setXY(e,t,n){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this}setXYZ(e,t,n,i){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=i,this}setXYZW(e,t,n,i,r){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=i,this.data.array[e+3]=r,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");let t=[];for(let n=0;n<this.count;n++){let i=n*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)t.push(this.data.array[i+r])}return new bt(new this.array.constructor(t),this.itemSize,this.normalized)}return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new Ii(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");let t=[];for(let n=0;n<this.count;n++){let i=n*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)t.push(this.data.array[i+r])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}Ii.prototype.isInterleavedBufferAttribute=!0;class ca extends nn{constructor(e){super(),this.type="SpriteMaterial",this.color=new De(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this}}let Fr;ca.prototype.isSpriteMaterial=!0;let us=new L,Nr=new L,zr=new L,Br=new me,ds=new me,Vc=new Xe,ha=new L,ps=new L,ua=new L,Wc=new me,Oo=new me,qc=new me;class da extends pt{constructor(e){if(super(),this.type="Sprite",Fr===void 0){Fr=new st;let t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),n=new Zi(t,5);Fr.setIndex([0,1,2,0,2,3]),Fr.setAttribute("position",new Ii(n,3,0,!1)),Fr.setAttribute("uv",new Ii(n,2,3,!1))}this.geometry=Fr,this.material=e!==void 0?e:new ca,this.center=new me(.5,.5)}raycast(e,t){e.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Nr.setFromMatrixScale(this.matrixWorld),Vc.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),zr.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&Nr.multiplyScalar(-zr.z);let n=this.material.rotation,i,r;n!==0&&(r=Math.cos(n),i=Math.sin(n));let a=this.center;pa(ha.set(-.5,-.5,0),zr,a,Nr,i,r),pa(ps.set(.5,-.5,0),zr,a,Nr,i,r),pa(ua.set(.5,.5,0),zr,a,Nr,i,r),Wc.set(0,0),Oo.set(1,0),qc.set(1,1);let c=e.ray.intersectTriangle(ha,ps,ua,!1,us);if(c===null&&(pa(ps.set(-.5,.5,0),zr,a,Nr,i,r),Oo.set(0,1),c=e.ray.intersectTriangle(ha,ua,ps,!1,us),c===null))return;let h=e.ray.origin.distanceTo(us);h<e.near||h>e.far||t.push({distance:h,point:us.clone(),uv:Yt.getUV(us,ha,ps,ua,Wc,Oo,qc,new me),face:null,object:this})}copy(e){return super.copy(e),e.center!==void 0&&this.center.copy(e.center),this.material=e.material,this}}function pa(s,e,t,n,i,r){Br.subVectors(s,t).addScalar(.5).multiply(n),i!==void 0?(ds.x=r*Br.x-i*Br.y,ds.y=i*Br.x+r*Br.y):ds.copy(Br),s.copy(e),s.x+=ds.x,s.y+=ds.y,s.applyMatrix4(Vc)}da.prototype.isSprite=!0;let fa=new L,jc=new L;class Xc extends pt{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(e){super.copy(e,!1);let t=e.levels;for(let n=0,i=t.length;n<i;n++){let r=t[n];this.addLevel(r.object.clone(),r.distance)}return this.autoUpdate=e.autoUpdate,this}addLevel(e,t=0){t=Math.abs(t);let n=this.levels,i;for(i=0;i<n.length&&!(t<n[i].distance);i++);return n.splice(i,0,{distance:t,object:e}),this.add(e),this}getCurrentLevel(){return this._currentLevel}getObjectForDistance(e){let t=this.levels;if(t.length>0){let n,i;for(n=1,i=t.length;n<i&&!(e<t[n].distance);n++);return t[n-1].object}return null}raycast(e,t){if(this.levels.length>0){fa.setFromMatrixPosition(this.matrixWorld);let n=e.ray.origin.distanceTo(fa);this.getObjectForDistance(n).raycast(e,t)}}update(e){let t=this.levels;if(t.length>1){fa.setFromMatrixPosition(e.matrixWorld),jc.setFromMatrixPosition(this.matrixWorld);let n=fa.distanceTo(jc)/e.zoom,i,r;for(t[0].object.visible=!0,i=1,r=t.length;i<r&&n>=t[i].distance;i++)t[i-1].object.visible=!1,t[i].object.visible=!0;for(this._currentLevel=i-1;i<r;i++)t[i].object.visible=!1}}toJSON(e){let t=super.toJSON(e);this.autoUpdate===!1&&(t.object.autoUpdate=!1),t.object.levels=[];let n=this.levels;for(let i=0,r=n.length;i<r;i++){let a=n[i];t.object.levels.push({object:a.object.uuid,distance:a.distance})}return t}}let Zc=new L,Yc=new _t,Jc=new _t,zf=new L,Kc=new Xe;class ma extends en{constructor(e,t){super(e,t),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Xe,this.bindMatrixInverse=new Xe}copy(e){return super.copy(e),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,this}bind(e,t){this.skeleton=e,t===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){let e=new _t,t=this.geometry.attributes.skinWeight;for(let n=0,i=t.count;n<i;n++){e.x=t.getX(n),e.y=t.getY(n),e.z=t.getZ(n),e.w=t.getW(n);let r=1/e.manhattanLength();r!==1/0?e.multiplyScalar(r):e.set(1,0,0,0),t.setXYZW(n,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(e,t){let n=this.skeleton,i=this.geometry;Yc.fromBufferAttribute(i.attributes.skinIndex,e),Jc.fromBufferAttribute(i.attributes.skinWeight,e),Zc.fromBufferAttribute(i.attributes.position,e).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let r=0;r<4;r++){let a=Jc.getComponent(r);if(a!==0){let c=Yc.getComponent(r);Kc.multiplyMatrices(n.bones[c].matrixWorld,n.boneInverses[c]),t.addScaledVector(zf.copy(Zc).applyMatrix4(Kc),a)}}return t.applyMatrix4(this.bindMatrixInverse)}}ma.prototype.isSkinnedMesh=!0;class ga extends pt{constructor(){super(),this.type="Bone"}}ga.prototype.isBone=!0;class Yi extends zt{constructor(e=null,t=1,n=1,i,r,a,c,h,u=1003,d=1003,p,f){super(null,a,c,h,u,d,i,r,p,f),this.image={data:e,width:t,height:n},this.magFilter=u,this.minFilter=d,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Yi.prototype.isDataTexture=!0;let Qc=new Xe,Bf=new Xe;class ya{constructor(e=[],t=[]){this.uuid=nt(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}init(){let e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(16*e.length),t.length===0)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let n=0,i=this.bones.length;n<i;n++)this.boneInverses.push(new Xe)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){let n=new Xe;this.bones[e]&&n.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(n)}}pose(){for(let e=0,t=this.bones.length;e<t;e++){let n=this.bones[e];n&&n.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){let n=this.bones[e];n&&(n.parent&&n.parent.isBone?(n.matrix.copy(n.parent.matrixWorld).invert(),n.matrix.multiply(n.matrixWorld)):n.matrix.copy(n.matrixWorld),n.matrix.decompose(n.position,n.quaternion,n.scale))}}update(){let e=this.bones,t=this.boneInverses,n=this.boneMatrices,i=this.boneTexture;for(let r=0,a=e.length;r<a;r++){let c=e[r]?e[r].matrixWorld:Bf;Qc.multiplyMatrices(c,t[r]),Qc.toArray(n,16*r)}i!==null&&(i.needsUpdate=!0)}clone(){return new ya(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(4*this.bones.length);e=kn(e),e=Math.max(e,4);let t=new Float32Array(e*e*4);t.set(this.boneMatrices);let n=new Yi(t,e,e,1023,1015);return this.boneMatrices=t,this.boneTexture=n,this.boneTextureSize=e,this}getBoneByName(e){for(let t=0,n=this.bones.length;t<n;t++){let i=this.bones[t];if(i.name===e)return i}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,t){this.uuid=e.uuid;for(let n=0,i=e.bones.length;n<i;n++){let r=e.bones[n],a=t[r];a===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",r),a=new ga),this.bones.push(a),this.boneInverses.push(new Xe().fromArray(e.boneInverses[n]))}return this.init(),this}toJSON(){let e={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;let t=this.bones,n=this.boneInverses;for(let i=0,r=t.length;i<r;i++){let a=t[i];e.bones.push(a.uuid);let c=n[i];e.boneInverses.push(c.toArray())}return e}}class Ji extends bt{constructor(e,t,n,i=1){typeof n=="number"&&(i=n,n=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),super(e,t,n),this.meshPerAttribute=i}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){let e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}Ji.prototype.isInstancedBufferAttribute=!0;let $c=new Xe,eh=new Xe,va=[],fs=new en;class Fo extends en{constructor(e,t,n){super(e,t),this.instanceMatrix=new Ji(new Float32Array(16*n),16),this.instanceColor=null,this.count=n,this.frustumCulled=!1}copy(e){return super.copy(e),this.instanceMatrix.copy(e.instanceMatrix),e.instanceColor!==null&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,this}getColorAt(e,t){t.fromArray(this.instanceColor.array,3*e)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,16*e)}raycast(e,t){let n=this.matrixWorld,i=this.count;if(fs.geometry=this.geometry,fs.material=this.material,fs.material!==void 0)for(let r=0;r<i;r++){this.getMatrixAt(r,$c),eh.multiplyMatrices(n,$c),fs.matrixWorld=eh,fs.raycast(e,va);for(let a=0,c=va.length;a<c;a++){let h=va[a];h.instanceId=r,h.object=this,t.push(h)}va.length=0}}setColorAt(e,t){this.instanceColor===null&&(this.instanceColor=new Ji(new Float32Array(3*this.instanceMatrix.count),3)),t.toArray(this.instanceColor.array,3*e)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,16*e)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}Fo.prototype.isInstancedMesh=!0;class an extends nn{constructor(e){super(),this.type="LineBasicMaterial",this.color=new De(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this}}an.prototype.isLineBasicMaterial=!0;let th=new L,nh=new L,ih=new Xe,No=new Ai,xa=new Ti;class _i extends pt{constructor(e=new st,t=new an){super(),this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),this.material=e.material,this.geometry=e.geometry,this}computeLineDistances(){let e=this.geometry;if(e.isBufferGeometry)if(e.index===null){let t=e.attributes.position,n=[0];for(let i=1,r=t.count;i<r;i++)th.fromBufferAttribute(t,i-1),nh.fromBufferAttribute(t,i),n[i]=n[i-1],n[i]+=th.distanceTo(nh);e.setAttribute("lineDistance",new Ue(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else e.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}raycast(e,t){let n=this.geometry,i=this.matrixWorld,r=e.params.Line.threshold,a=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),xa.copy(n.boundingSphere),xa.applyMatrix4(i),xa.radius+=r,e.ray.intersectsSphere(xa)===!1)return;ih.copy(i).invert(),No.copy(e.ray).applyMatrix4(ih);let c=r/((this.scale.x+this.scale.y+this.scale.z)/3),h=c*c,u=new L,d=new L,p=new L,f=new L,m=this.isLineSegments?2:1;if(n.isBufferGeometry){let g=n.index,y=n.attributes.position;if(g!==null)for(let x=Math.max(0,a.start),v=Math.min(g.count,a.start+a.count)-1;x<v;x+=m){let w=g.getX(x),A=g.getX(x+1);if(u.fromBufferAttribute(y,w),d.fromBufferAttribute(y,A),No.distanceSqToSegment(u,d,f,p)>h)continue;f.applyMatrix4(this.matrixWorld);let S=e.ray.origin.distanceTo(f);S<e.near||S>e.far||t.push({distance:S,point:p.clone().applyMatrix4(this.matrixWorld),index:x,face:null,faceIndex:null,object:this})}else for(let x=Math.max(0,a.start),v=Math.min(y.count,a.start+a.count)-1;x<v;x+=m){if(u.fromBufferAttribute(y,x),d.fromBufferAttribute(y,x+1),No.distanceSqToSegment(u,d,f,p)>h)continue;f.applyMatrix4(this.matrixWorld);let w=e.ray.origin.distanceTo(f);w<e.near||w>e.far||t.push({distance:w,point:p.clone().applyMatrix4(this.matrixWorld),index:x,face:null,faceIndex:null,object:this})}}else n.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){let e=this.geometry;if(e.isBufferGeometry){let t=e.morphAttributes,n=Object.keys(t);if(n.length>0){let i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,a=i.length;r<a;r++){let c=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[c]=r}}}}else{let t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}_i.prototype.isLine=!0;let rh=new L,sh=new L;class wn extends _i{constructor(e,t){super(e,t),this.type="LineSegments"}computeLineDistances(){let e=this.geometry;if(e.isBufferGeometry)if(e.index===null){let t=e.attributes.position,n=[];for(let i=0,r=t.count;i<r;i+=2)rh.fromBufferAttribute(t,i),sh.fromBufferAttribute(t,i+1),n[i]=i===0?0:n[i-1],n[i+1]=n[i]+rh.distanceTo(sh);e.setAttribute("lineDistance",new Ue(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else e.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}wn.prototype.isLineSegments=!0;class zo extends _i{constructor(e,t){super(e,t),this.type="LineLoop"}}zo.prototype.isLineLoop=!0;class Ki extends nn{constructor(e){super(),this.type="PointsMaterial",this.color=new De(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this}}Ki.prototype.isPointsMaterial=!0;let ah=new Xe,Bo=new Ai,_a=new Ti,ba=new L;class ms extends pt{constructor(e=new st,t=new Ki){super(),this.type="Points",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),this.material=e.material,this.geometry=e.geometry,this}raycast(e,t){let n=this.geometry,i=this.matrixWorld,r=e.params.Points.threshold,a=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),_a.copy(n.boundingSphere),_a.applyMatrix4(i),_a.radius+=r,e.ray.intersectsSphere(_a)===!1)return;ah.copy(i).invert(),Bo.copy(e.ray).applyMatrix4(ah);let c=r/((this.scale.x+this.scale.y+this.scale.z)/3),h=c*c;if(n.isBufferGeometry){let u=n.index,d=n.attributes.position;if(u!==null)for(let p=Math.max(0,a.start),f=Math.min(u.count,a.start+a.count);p<f;p++){let m=u.getX(p);ba.fromBufferAttribute(d,m),oh(ba,m,h,i,e,t,this)}else for(let p=Math.max(0,a.start),f=Math.min(d.count,a.start+a.count);p<f;p++)ba.fromBufferAttribute(d,p),oh(ba,p,h,i,e,t,this)}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){let e=this.geometry;if(e.isBufferGeometry){let t=e.morphAttributes,n=Object.keys(t);if(n.length>0){let i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,a=i.length;r<a;r++){let c=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[c]=r}}}}else{let t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}function oh(s,e,t,n,i,r,a){let c=Bo.distanceSqToPoint(s);if(c<t){let h=new L;Bo.closestPointToPoint(s,h),h.applyMatrix4(n);let u=i.ray.origin.distanceTo(h);if(u<i.near||u>i.far)return;r.push({distance:u,distanceToRay:Math.sqrt(c),point:h,index:e,face:null,object:a})}}ms.prototype.isPoints=!0;class lh extends zt{constructor(e,t,n,i,r,a,c,h,u){super(e,t,n,i,r,a,c,h,u),this.format=c!==void 0?c:1022,this.minFilter=a!==void 0?a:1006,this.magFilter=r!==void 0?r:1006,this.generateMipmaps=!1;let d=this;"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(function p(){d.needsUpdate=!0,e.requestVideoFrameCallback(p)})}clone(){return new this.constructor(this.image).copy(this)}update(){let e=this.image;!("requestVideoFrameCallback"in e)&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}lh.prototype.isVideoTexture=!0;class Ho extends zt{constructor(e,t,n,i,r,a,c,h,u,d,p,f){super(null,a,c,h,u,d,i,r,p,f),this.image={width:t,height:n},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}}Ho.prototype.isCompressedTexture=!0;class ch extends zt{constructor(e,t,n,i,r,a,c,h,u){super(e,t,n,i,r,a,c,h,u),this.needsUpdate=!0}}ch.prototype.isCanvasTexture=!0;class hh extends zt{constructor(e,t,n,i,r,a,c,h,u,d){if((d=d!==void 0?d:1026)!==1026&&d!==1027)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");n===void 0&&d===1026&&(n=1012),n===void 0&&d===1027&&(n=1020),super(null,i,r,a,c,h,d,n,u),this.image={width:e,height:t},this.magFilter=c!==void 0?c:1003,this.minFilter=h!==void 0?h:1003,this.flipY=!1,this.generateMipmaps=!1}}hh.prototype.isDepthTexture=!0;class Hr extends st{constructor(e=1,t=8,n=0,i=2*Math.PI){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:t,thetaStart:n,thetaLength:i},t=Math.max(3,t);let r=[],a=[],c=[],h=[],u=new L,d=new me;a.push(0,0,0),c.push(0,0,1),h.push(.5,.5);for(let p=0,f=3;p<=t;p++,f+=3){let m=n+p/t*i;u.x=e*Math.cos(m),u.y=e*Math.sin(m),a.push(u.x,u.y,u.z),c.push(0,0,1),d.x=(a[f]/e+1)/2,d.y=(a[f+1]/e+1)/2,h.push(d.x,d.y)}for(let p=1;p<=t;p++)r.push(p,p+1,0);this.setIndex(r),this.setAttribute("position",new Ue(a,3)),this.setAttribute("normal",new Ue(c,3)),this.setAttribute("uv",new Ue(h,2))}static fromJSON(e){return new Hr(e.radius,e.segments,e.thetaStart,e.thetaLength)}}class Oi extends st{constructor(e=1,t=1,n=1,i=8,r=1,a=!1,c=0,h=2*Math.PI){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:n,radialSegments:i,heightSegments:r,openEnded:a,thetaStart:c,thetaLength:h};let u=this;i=Math.floor(i),r=Math.floor(r);let d=[],p=[],f=[],m=[],g=0,y=[],x=n/2,v=0;function w(A){let S=g,D=new me,F=new L,q=0,X=A===!0?e:t,te=A===!0?1:-1;for(let $=1;$<=i;$++)p.push(0,x*te,0),f.push(0,te,0),m.push(.5,.5),g++;let J=g;for(let $=0;$<=i;$++){let Re=$/i*h+c,ye=Math.cos(Re),ae=Math.sin(Re);F.x=X*ae,F.y=x*te,F.z=X*ye,p.push(F.x,F.y,F.z),f.push(0,te,0),D.x=.5*ye+.5,D.y=.5*ae*te+.5,m.push(D.x,D.y),g++}for(let $=0;$<i;$++){let Re=S+$,ye=J+$;A===!0?d.push(ye,ye+1,Re):d.push(ye+1,ye,Re),q+=3}u.addGroup(v,q,A===!0?1:2),v+=q}(function(){let A=new L,S=new L,D=0,F=(t-e)/n;for(let q=0;q<=r;q++){let X=[],te=q/r,J=te*(t-e)+e;for(let $=0;$<=i;$++){let Re=$/i,ye=Re*h+c,ae=Math.sin(ye),be=Math.cos(ye);S.x=J*ae,S.y=-te*n+x,S.z=J*be,p.push(S.x,S.y,S.z),A.set(ae,F,be).normalize(),f.push(A.x,A.y,A.z),m.push(Re,1-te),X.push(g++)}y.push(X)}for(let q=0;q<i;q++)for(let X=0;X<r;X++){let te=y[X][q],J=y[X+1][q],$=y[X+1][q+1],Re=y[X][q+1];d.push(te,J,Re),d.push(J,$,Re),D+=6}u.addGroup(v,D,0),v+=D})(),a===!1&&(e>0&&w(!0),t>0&&w(!1)),this.setIndex(d),this.setAttribute("position",new Ue(p,3)),this.setAttribute("normal",new Ue(f,3)),this.setAttribute("uv",new Ue(m,2))}static fromJSON(e){return new Oi(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class Ur extends Oi{constructor(e=1,t=1,n=8,i=1,r=!1,a=0,c=2*Math.PI){super(0,e,t,n,i,r,a,c),this.type="ConeGeometry",this.parameters={radius:e,height:t,radialSegments:n,heightSegments:i,openEnded:r,thetaStart:a,thetaLength:c}}static fromJSON(e){return new Ur(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class si extends st{constructor(e,t,n=1,i=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:t,radius:n,detail:i};let r=[],a=[];function c(f,m,g,y){let x=y+1,v=[];for(let w=0;w<=x;w++){v[w]=[];let A=f.clone().lerp(g,w/x),S=m.clone().lerp(g,w/x),D=x-w;for(let F=0;F<=D;F++)v[w][F]=F===0&&w===x?A:A.clone().lerp(S,F/D)}for(let w=0;w<x;w++)for(let A=0;A<2*(x-w)-1;A++){let S=Math.floor(A/2);A%2==0?(h(v[w][S+1]),h(v[w+1][S]),h(v[w][S])):(h(v[w][S+1]),h(v[w+1][S+1]),h(v[w+1][S]))}}function h(f){r.push(f.x,f.y,f.z)}function u(f,m){let g=3*f;m.x=e[g+0],m.y=e[g+1],m.z=e[g+2]}function d(f,m,g,y){y<0&&f.x===1&&(a[m]=f.x-1),g.x===0&&g.z===0&&(a[m]=y/2/Math.PI+.5)}function p(f){return Math.atan2(f.z,-f.x)}(function(f){let m=new L,g=new L,y=new L;for(let x=0;x<t.length;x+=3)u(t[x+0],m),u(t[x+1],g),u(t[x+2],y),c(m,g,y,f)})(i),function(f){let m=new L;for(let g=0;g<r.length;g+=3)m.x=r[g+0],m.y=r[g+1],m.z=r[g+2],m.normalize().multiplyScalar(f),r[g+0]=m.x,r[g+1]=m.y,r[g+2]=m.z}(n),function(){let f=new L;for(let g=0;g<r.length;g+=3){f.x=r[g+0],f.y=r[g+1],f.z=r[g+2];let y=p(f)/2/Math.PI+.5,x=(m=f,Math.atan2(-m.y,Math.sqrt(m.x*m.x+m.z*m.z))/Math.PI+.5);a.push(y,1-x)}var m;(function(){let g=new L,y=new L,x=new L,v=new L,w=new me,A=new me,S=new me;for(let D=0,F=0;D<r.length;D+=9,F+=6){g.set(r[D+0],r[D+1],r[D+2]),y.set(r[D+3],r[D+4],r[D+5]),x.set(r[D+6],r[D+7],r[D+8]),w.set(a[F+0],a[F+1]),A.set(a[F+2],a[F+3]),S.set(a[F+4],a[F+5]),v.copy(g).add(y).add(x).divideScalar(3);let q=p(v);d(w,F+0,g,q),d(A,F+2,y,q),d(S,F+4,x,q)}})(),function(){for(let g=0;g<a.length;g+=6){let y=a[g+0],x=a[g+2],v=a[g+4],w=Math.max(y,x,v),A=Math.min(y,x,v);w>.9&&A<.1&&(y<.2&&(a[g+0]+=1),x<.2&&(a[g+2]+=1),v<.2&&(a[g+4]+=1))}}()}(),this.setAttribute("position",new Ue(r,3)),this.setAttribute("normal",new Ue(r.slice(),3)),this.setAttribute("uv",new Ue(a,2)),i===0?this.computeVertexNormals():this.normalizeNormals()}static fromJSON(e){return new si(e.vertices,e.indices,e.radius,e.details)}}class Gr extends si{constructor(e=1,t=0){let n=(1+Math.sqrt(5))/2,i=1/n;super([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-i,-n,0,-i,n,0,i,-n,0,i,n,-i,-n,0,-i,n,0,i,-n,0,i,n,0,-n,0,-i,n,0,-i,-n,0,i,n,0,i],[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],e,t),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new Gr(e.radius,e.detail)}}let Ma=new L,wa=new L,Uo=new L,Sa=new Yt;class Go extends st{constructor(e,t){if(super(),this.type="EdgesGeometry",this.parameters={thresholdAngle:t},t=t!==void 0?t:1,e.isGeometry===!0)return void console.error("THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");let n=Math.pow(10,4),i=Math.cos(rt*t),r=e.getIndex(),a=e.getAttribute("position"),c=r?r.count:a.count,h=[0,0,0],u=["a","b","c"],d=new Array(3),p={},f=[];for(let m=0;m<c;m+=3){r?(h[0]=r.getX(m),h[1]=r.getX(m+1),h[2]=r.getX(m+2)):(h[0]=m,h[1]=m+1,h[2]=m+2);let{a:g,b:y,c:x}=Sa;if(g.fromBufferAttribute(a,h[0]),y.fromBufferAttribute(a,h[1]),x.fromBufferAttribute(a,h[2]),Sa.getNormal(Uo),d[0]=`${Math.round(g.x*n)},${Math.round(g.y*n)},${Math.round(g.z*n)}`,d[1]=`${Math.round(y.x*n)},${Math.round(y.y*n)},${Math.round(y.z*n)}`,d[2]=`${Math.round(x.x*n)},${Math.round(x.y*n)},${Math.round(x.z*n)}`,d[0]!==d[1]&&d[1]!==d[2]&&d[2]!==d[0])for(let v=0;v<3;v++){let w=(v+1)%3,A=d[v],S=d[w],D=Sa[u[v]],F=Sa[u[w]],q=`${A}_${S}`,X=`${S}_${A}`;X in p&&p[X]?(Uo.dot(p[X].normal)<=i&&(f.push(D.x,D.y,D.z),f.push(F.x,F.y,F.z)),p[X]=null):q in p||(p[q]={index0:h[v],index1:h[w],normal:Uo.clone()})}}for(let m in p)if(p[m]){let{index0:g,index1:y}=p[m];Ma.fromBufferAttribute(a,g),wa.fromBufferAttribute(a,y),f.push(Ma.x,Ma.y,Ma.z),f.push(wa.x,wa.y,wa.z)}this.setAttribute("position",new Ue(f,3))}}class In{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(e,t){let n=this.getUtoTmapping(e);return this.getPoint(n,t)}getPoints(e=5){let t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return t}getSpacedPoints(e=5){let t=[];for(let n=0;n<=e;n++)t.push(this.getPointAt(n/e));return t}getLength(){let e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;let t=[],n,i=this.getPoint(0),r=0;t.push(0);for(let a=1;a<=e;a++)n=this.getPoint(a/e),r+=n.distanceTo(i),t.push(r),i=n;return this.cacheArcLengths=t,t}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,t){let n=this.getLengths(),i=0,r=n.length,a;a=t||e*n[r-1];let c,h=0,u=r-1;for(;h<=u;)if(i=Math.floor(h+(u-h)/2),c=n[i]-a,c<0)h=i+1;else{if(!(c>0)){u=i;break}u=i-1}if(i=u,n[i]===a)return i/(r-1);let d=n[i];return(i+(a-d)/(n[i+1]-d))/(r-1)}getTangent(e,t){let i=e-1e-4,r=e+1e-4;i<0&&(i=0),r>1&&(r=1);let a=this.getPoint(i),c=this.getPoint(r),h=t||(a.isVector2?new me:new L);return h.copy(c).sub(a).normalize(),h}getTangentAt(e,t){let n=this.getUtoTmapping(e);return this.getTangent(n,t)}computeFrenetFrames(e,t){let n=new L,i=[],r=[],a=[],c=new L,h=new Xe;for(let m=0;m<=e;m++){let g=m/e;i[m]=this.getTangentAt(g,new L),i[m].normalize()}r[0]=new L,a[0]=new L;let u=Number.MAX_VALUE,d=Math.abs(i[0].x),p=Math.abs(i[0].y),f=Math.abs(i[0].z);d<=u&&(u=d,n.set(1,0,0)),p<=u&&(u=p,n.set(0,1,0)),f<=u&&n.set(0,0,1),c.crossVectors(i[0],n).normalize(),r[0].crossVectors(i[0],c),a[0].crossVectors(i[0],r[0]);for(let m=1;m<=e;m++){if(r[m]=r[m-1].clone(),a[m]=a[m-1].clone(),c.crossVectors(i[m-1],i[m]),c.length()>Number.EPSILON){c.normalize();let g=Math.acos(Ke(i[m-1].dot(i[m]),-1,1));r[m].applyMatrix4(h.makeRotationAxis(c,g))}a[m].crossVectors(i[m],r[m])}if(t===!0){let m=Math.acos(Ke(r[0].dot(r[e]),-1,1));m/=e,i[0].dot(c.crossVectors(r[0],r[e]))>0&&(m=-m);for(let g=1;g<=e;g++)r[g].applyMatrix4(h.makeRotationAxis(i[g],m*g)),a[g].crossVectors(i[g],r[g])}return{tangents:i,normals:r,binormals:a}}clone(){return new this.constructor().copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){let e={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}class gs extends In{constructor(e=0,t=0,n=1,i=1,r=0,a=2*Math.PI,c=!1,h=0){super(),this.type="EllipseCurve",this.aX=e,this.aY=t,this.xRadius=n,this.yRadius=i,this.aStartAngle=r,this.aEndAngle=a,this.aClockwise=c,this.aRotation=h}getPoint(e,t){let n=t||new me,i=2*Math.PI,r=this.aEndAngle-this.aStartAngle,a=Math.abs(r)<Number.EPSILON;for(;r<0;)r+=i;for(;r>i;)r-=i;r<Number.EPSILON&&(r=a?0:i),this.aClockwise!==!0||a||(r===i?r=-i:r-=i);let c=this.aStartAngle+e*r,h=this.aX+this.xRadius*Math.cos(c),u=this.aY+this.yRadius*Math.sin(c);if(this.aRotation!==0){let d=Math.cos(this.aRotation),p=Math.sin(this.aRotation),f=h-this.aX,m=u-this.aY;h=f*d-m*p+this.aX,u=f*p+m*d+this.aY}return n.set(h,u)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){let e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}gs.prototype.isEllipseCurve=!0;class ko extends gs{constructor(e,t,n,i,r,a){super(e,t,n,n,i,r,a),this.type="ArcCurve"}}function Vo(){let s=0,e=0,t=0,n=0;function i(r,a,c,h){s=r,e=c,t=-3*r+3*a-2*c-h,n=2*r-2*a+c+h}return{initCatmullRom:function(r,a,c,h,u){i(a,c,u*(c-r),u*(h-a))},initNonuniformCatmullRom:function(r,a,c,h,u,d,p){let f=(a-r)/u-(c-r)/(u+d)+(c-a)/d,m=(c-a)/d-(h-a)/(d+p)+(h-c)/p;f*=d,m*=d,i(a,c,f,m)},calc:function(r){let a=r*r;return s+e*r+t*a+n*(a*r)}}}ko.prototype.isArcCurve=!0;let Ta=new L,Wo=new Vo,qo=new Vo,jo=new Vo;class Xo extends In{constructor(e=[],t=!1,n="centripetal",i=.5){super(),this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=n,this.tension=i}getPoint(e,t=new L){let n=t,i=this.points,r=i.length,a=(r-(this.closed?0:1))*e,c,h,u=Math.floor(a),d=a-u;this.closed?u+=u>0?0:(Math.floor(Math.abs(u)/r)+1)*r:d===0&&u===r-1&&(u=r-2,d=1),this.closed||u>0?c=i[(u-1)%r]:(Ta.subVectors(i[0],i[1]).add(i[0]),c=Ta);let p=i[u%r],f=i[(u+1)%r];if(this.closed||u+2<r?h=i[(u+2)%r]:(Ta.subVectors(i[r-1],i[r-2]).add(i[r-1]),h=Ta),this.curveType==="centripetal"||this.curveType==="chordal"){let m=this.curveType==="chordal"?.5:.25,g=Math.pow(c.distanceToSquared(p),m),y=Math.pow(p.distanceToSquared(f),m),x=Math.pow(f.distanceToSquared(h),m);y<1e-4&&(y=1),g<1e-4&&(g=y),x<1e-4&&(x=y),Wo.initNonuniformCatmullRom(c.x,p.x,f.x,h.x,g,y,x),qo.initNonuniformCatmullRom(c.y,p.y,f.y,h.y,g,y,x),jo.initNonuniformCatmullRom(c.z,p.z,f.z,h.z,g,y,x)}else this.curveType==="catmullrom"&&(Wo.initCatmullRom(c.x,p.x,f.x,h.x,this.tension),qo.initCatmullRom(c.y,p.y,f.y,h.y,this.tension),jo.initCatmullRom(c.z,p.z,f.z,h.z,this.tension));return n.set(Wo.calc(d),qo.calc(d),jo.calc(d)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){let i=e.points[t];this.points.push(i.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){let e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){let i=this.points[t];e.points.push(i.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){let i=e.points[t];this.points.push(new L().fromArray(i))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}function uh(s,e,t,n,i){let r=.5*(n-e),a=.5*(i-t),c=s*s;return(2*t-2*n+r+a)*(s*c)+(-3*t+3*n-2*r-a)*c+r*s+t}function ys(s,e,t,n){return function(i,r){let a=1-i;return a*a*r}(s,e)+function(i,r){return 2*(1-i)*i*r}(s,t)+function(i,r){return i*i*r}(s,n)}function vs(s,e,t,n,i){return function(r,a){let c=1-r;return c*c*c*a}(s,e)+function(r,a){let c=1-r;return 3*c*c*r*a}(s,t)+function(r,a){return 3*(1-r)*r*r*a}(s,n)+function(r,a){return r*r*r*a}(s,i)}Xo.prototype.isCatmullRomCurve3=!0;class Ea extends In{constructor(e=new me,t=new me,n=new me,i=new me){super(),this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=n,this.v3=i}getPoint(e,t=new me){let n=t,i=this.v0,r=this.v1,a=this.v2,c=this.v3;return n.set(vs(e,i.x,r.x,a.x,c.x),vs(e,i.y,r.y,a.y,c.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){let e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}Ea.prototype.isCubicBezierCurve=!0;class Zo extends In{constructor(e=new L,t=new L,n=new L,i=new L){super(),this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=n,this.v3=i}getPoint(e,t=new L){let n=t,i=this.v0,r=this.v1,a=this.v2,c=this.v3;return n.set(vs(e,i.x,r.x,a.x,c.x),vs(e,i.y,r.y,a.y,c.y),vs(e,i.z,r.z,a.z,c.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){let e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}Zo.prototype.isCubicBezierCurve3=!0;class xs extends In{constructor(e=new me,t=new me){super(),this.type="LineCurve",this.v1=e,this.v2=t}getPoint(e,t=new me){let n=t;return e===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t){let n=t||new me;return n.copy(this.v2).sub(this.v1).normalize(),n}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){let e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}xs.prototype.isLineCurve=!0;class dh extends In{constructor(e=new L,t=new L){super(),this.type="LineCurve3",this.isLineCurve3=!0,this.v1=e,this.v2=t}getPoint(e,t=new L){let n=t;return e===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){let e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class Aa extends In{constructor(e=new me,t=new me,n=new me){super(),this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new me){let n=t,i=this.v0,r=this.v1,a=this.v2;return n.set(ys(e,i.x,r.x,a.x),ys(e,i.y,r.y,a.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){let e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}Aa.prototype.isQuadraticBezierCurve=!0;class Yo extends In{constructor(e=new L,t=new L,n=new L){super(),this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new L){let n=t,i=this.v0,r=this.v1,a=this.v2;return n.set(ys(e,i.x,r.x,a.x),ys(e,i.y,r.y,a.y),ys(e,i.z,r.z,a.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){let e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}Yo.prototype.isQuadraticBezierCurve3=!0;class La extends In{constructor(e=[]){super(),this.type="SplineCurve",this.points=e}getPoint(e,t=new me){let n=t,i=this.points,r=(i.length-1)*e,a=Math.floor(r),c=r-a,h=i[a===0?a:a-1],u=i[a],d=i[a>i.length-2?i.length-1:a+1],p=i[a>i.length-3?i.length-1:a+2];return n.set(uh(c,h.x,u.x,d.x,p.x),uh(c,h.y,u.y,d.y,p.y)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){let i=e.points[t];this.points.push(i.clone())}return this}toJSON(){let e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){let i=this.points[t];e.points.push(i.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){let i=e.points[t];this.points.push(new me().fromArray(i))}return this}}La.prototype.isSplineCurve=!0;var Jo=Object.freeze({__proto__:null,ArcCurve:ko,CatmullRomCurve3:Xo,CubicBezierCurve:Ea,CubicBezierCurve3:Zo,EllipseCurve:gs,LineCurve:xs,LineCurve3:dh,QuadraticBezierCurve:Aa,QuadraticBezierCurve3:Yo,SplineCurve:La});let Hf=function(s,e,t=2){let n=e&&e.length,i=n?e[0]*t:s.length,r=ph(s,0,i,t,!0),a=[];if(!r||r.next===r.prev)return a;let c,h,u,d,p,f,m;if(n&&(r=function(g,y,x,v){let w=[],A,S,D,F,q;for(A=0,S=y.length;A<S;A++)D=y[A]*v,F=A<S-1?y[A+1]*v:g.length,q=ph(g,D,F,v,!1),q===q.next&&(q.steiner=!0),w.push(Xf(q));for(w.sort(Wf),A=0;A<w.length;A++)qf(w[A],x),x=Fi(x,x.next);return x}(s,e,r,t)),s.length>80*t){c=u=s[0],h=d=s[1];for(let g=t;g<i;g+=t)p=s[g],f=s[g+1],p<c&&(c=p),f<h&&(h=f),p>u&&(u=p),f>d&&(d=f);m=Math.max(u-c,d-h),m=m!==0?1/m:0}return _s(r,a,t,c,h,m),a};function ph(s,e,t,n,i){let r,a;if(i===function(c,h,u,d){let p=0;for(let f=h,m=u-d;f<u;f+=d)p+=(c[m]-c[f])*(c[f+1]+c[m+1]),m=f;return p}(s,e,t,n)>0)for(r=e;r<t;r+=n)a=gh(r,s[r],s[r+1],a);else for(r=t-n;r>=e;r-=n)a=gh(r,s[r],s[r+1],a);return a&&Ra(a,a.next)&&(Ms(a),a=a.next),a}function Fi(s,e){if(!s)return s;e||(e=s);let t,n=s;do if(t=!1,n.steiner||!Ra(n,n.next)&&qt(n.prev,n,n.next)!==0)n=n.next;else{if(Ms(n),n=e=n.prev,n===n.next)break;t=!0}while(t||n!==e);return e}function _s(s,e,t,n,i,r,a){if(!s)return;!a&&r&&function(d,p,f,m){let g=d;do g.z===null&&(g.z=Ko(g.x,g.y,p,f,m)),g.prevZ=g.prev,g.nextZ=g.next,g=g.next;while(g!==d);g.prevZ.nextZ=null,g.prevZ=null,function(y){let x,v,w,A,S,D,F,q,X=1;do{for(v=y,y=null,S=null,D=0;v;){for(D++,w=v,F=0,x=0;x<X&&(F++,w=w.nextZ,w);x++);for(q=X;F>0||q>0&&w;)F!==0&&(q===0||!w||v.z<=w.z)?(A=v,v=v.nextZ,F--):(A=w,w=w.nextZ,q--),S?S.nextZ=A:y=A,A.prevZ=S,S=A;v=w}S.nextZ=null,X*=2}while(D>1)}(g)}(s,n,i,r);let c,h,u=s;for(;s.prev!==s.next;)if(c=s.prev,h=s.next,r?Gf(s,n,i,r):Uf(s))e.push(c.i/t),e.push(s.i/t),e.push(h.i/t),Ms(s),s=h.next,u=h.next;else if((s=h)===u){a?a===1?_s(s=kf(Fi(s),e,t),e,t,n,i,r,2):a===2&&Vf(s,e,t,n,i,r):_s(Fi(s),e,t,n,i,r,1);break}}function Uf(s){let e=s.prev,t=s,n=s.next;if(qt(e,t,n)>=0)return!1;let i=s.next.next;for(;i!==s.prev;){if(kr(e.x,e.y,t.x,t.y,n.x,n.y,i.x,i.y)&&qt(i.prev,i,i.next)>=0)return!1;i=i.next}return!0}function Gf(s,e,t,n){let i=s.prev,r=s,a=s.next;if(qt(i,r,a)>=0)return!1;let c=i.x<r.x?i.x<a.x?i.x:a.x:r.x<a.x?r.x:a.x,h=i.y<r.y?i.y<a.y?i.y:a.y:r.y<a.y?r.y:a.y,u=i.x>r.x?i.x>a.x?i.x:a.x:r.x>a.x?r.x:a.x,d=i.y>r.y?i.y>a.y?i.y:a.y:r.y>a.y?r.y:a.y,p=Ko(c,h,e,t,n),f=Ko(u,d,e,t,n),m=s.prevZ,g=s.nextZ;for(;m&&m.z>=p&&g&&g.z<=f;){if(m!==s.prev&&m!==s.next&&kr(i.x,i.y,r.x,r.y,a.x,a.y,m.x,m.y)&&qt(m.prev,m,m.next)>=0||(m=m.prevZ,g!==s.prev&&g!==s.next&&kr(i.x,i.y,r.x,r.y,a.x,a.y,g.x,g.y)&&qt(g.prev,g,g.next)>=0))return!1;g=g.nextZ}for(;m&&m.z>=p;){if(m!==s.prev&&m!==s.next&&kr(i.x,i.y,r.x,r.y,a.x,a.y,m.x,m.y)&&qt(m.prev,m,m.next)>=0)return!1;m=m.prevZ}for(;g&&g.z<=f;){if(g!==s.prev&&g!==s.next&&kr(i.x,i.y,r.x,r.y,a.x,a.y,g.x,g.y)&&qt(g.prev,g,g.next)>=0)return!1;g=g.nextZ}return!0}function kf(s,e,t){let n=s;do{let i=n.prev,r=n.next.next;!Ra(i,r)&&fh(i,n,n.next,r)&&bs(i,r)&&bs(r,i)&&(e.push(i.i/t),e.push(n.i/t),e.push(r.i/t),Ms(n),Ms(n.next),n=s=r),n=n.next}while(n!==s);return Fi(n)}function Vf(s,e,t,n,i,r){let a=s;do{let c=a.next.next;for(;c!==a.prev;){if(a.i!==c.i&&Zf(a,c)){let h=mh(a,c);return a=Fi(a,a.next),h=Fi(h,h.next),_s(a,e,t,n,i,r),void _s(h,e,t,n,i,r)}c=c.next}a=a.next}while(a!==s)}function Wf(s,e){return s.x-e.x}function qf(s,e){if(e=function(t,n){let i=n,r=t.x,a=t.y,c,h=-1/0;do{if(a<=i.y&&a>=i.next.y&&i.next.y!==i.y){let g=i.x+(a-i.y)*(i.next.x-i.x)/(i.next.y-i.y);if(g<=r&&g>h){if(h=g,g===r){if(a===i.y)return i;if(a===i.next.y)return i.next}c=i.x<i.next.x?i:i.next}}i=i.next}while(i!==n);if(!c)return null;if(r===h)return c;let u=c,d=c.x,p=c.y,f,m=1/0;i=c;do r>=i.x&&i.x>=d&&r!==i.x&&kr(a<p?r:h,a,d,p,a<p?h:r,a,i.x,i.y)&&(f=Math.abs(a-i.y)/(r-i.x),bs(i,t)&&(f<m||f===m&&(i.x>c.x||i.x===c.x&&jf(c,i)))&&(c=i,m=f)),i=i.next;while(i!==u);return c}(s,e)){let t=mh(e,s);Fi(e,e.next),Fi(t,t.next)}}function jf(s,e){return qt(s.prev,s,e.prev)<0&&qt(e.next,s,s.next)<0}function Ko(s,e,t,n,i){return(s=1431655765&((s=858993459&((s=252645135&((s=16711935&((s=32767*(s-t)*i)|s<<8))|s<<4))|s<<2))|s<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-n)*i)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function Xf(s){let e=s,t=s;do(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next;while(e!==s);return t}function kr(s,e,t,n,i,r,a,c){return(i-a)*(e-c)-(s-a)*(r-c)>=0&&(s-a)*(n-c)-(t-a)*(e-c)>=0&&(t-a)*(r-c)-(i-a)*(n-c)>=0}function Zf(s,e){return s.next.i!==e.i&&s.prev.i!==e.i&&!function(t,n){let i=t;do{if(i.i!==t.i&&i.next.i!==t.i&&i.i!==n.i&&i.next.i!==n.i&&fh(i,i.next,t,n))return!0;i=i.next}while(i!==t);return!1}(s,e)&&(bs(s,e)&&bs(e,s)&&function(t,n){let i=t,r=!1,a=(t.x+n.x)/2,c=(t.y+n.y)/2;do i.y>c!=i.next.y>c&&i.next.y!==i.y&&a<(i.next.x-i.x)*(c-i.y)/(i.next.y-i.y)+i.x&&(r=!r),i=i.next;while(i!==t);return r}(s,e)&&(qt(s.prev,s,e.prev)||qt(s,e.prev,e))||Ra(s,e)&&qt(s.prev,s,s.next)>0&&qt(e.prev,e,e.next)>0)}function qt(s,e,t){return(e.y-s.y)*(t.x-e.x)-(e.x-s.x)*(t.y-e.y)}function Ra(s,e){return s.x===e.x&&s.y===e.y}function fh(s,e,t,n){let i=Pa(qt(s,e,t)),r=Pa(qt(s,e,n)),a=Pa(qt(t,n,s)),c=Pa(qt(t,n,e));return i!==r&&a!==c||!(i!==0||!Ca(s,t,e))||!(r!==0||!Ca(s,n,e))||!(a!==0||!Ca(t,s,n))||!(c!==0||!Ca(t,e,n))}function Ca(s,e,t){return e.x<=Math.max(s.x,t.x)&&e.x>=Math.min(s.x,t.x)&&e.y<=Math.max(s.y,t.y)&&e.y>=Math.min(s.y,t.y)}function Pa(s){return s>0?1:s<0?-1:0}function bs(s,e){return qt(s.prev,s,s.next)<0?qt(s,e,s.next)>=0&&qt(s,s.prev,e)>=0:qt(s,e,s.prev)<0||qt(s,s.next,e)<0}function mh(s,e){let t=new Qo(s.i,s.x,s.y),n=new Qo(e.i,e.x,e.y),i=s.next,r=e.prev;return s.next=e,e.prev=s,t.next=i,i.prev=t,n.next=t,t.prev=n,r.next=n,n.prev=r,n}function gh(s,e,t,n){let i=new Qo(s,e,t);return n?(i.next=n.next,i.prev=n,n.next.prev=i,n.next=i):(i.prev=i,i.next=i),i}function Ms(s){s.next.prev=s.prev,s.prev.next=s.next,s.prevZ&&(s.prevZ.nextZ=s.nextZ),s.nextZ&&(s.nextZ.prevZ=s.prevZ)}function Qo(s,e,t){this.i=s,this.x=e,this.y=t,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}class ai{static area(e){let t=e.length,n=0;for(let i=t-1,r=0;r<t;i=r++)n+=e[i].x*e[r].y-e[r].x*e[i].y;return .5*n}static isClockWise(e){return ai.area(e)<0}static triangulateShape(e,t){let n=[],i=[],r=[];yh(e),vh(n,e);let a=e.length;t.forEach(yh);for(let h=0;h<t.length;h++)i.push(a),a+=t[h].length,vh(n,t[h]);let c=Hf(n,i);for(let h=0;h<c.length;h+=3)r.push(c.slice(h,h+3));return r}}function yh(s){let e=s.length;e>2&&s[e-1].equals(s[0])&&s.pop()}function vh(s,e){for(let t=0;t<e.length;t++)s.push(e[t].x),s.push(e[t].y)}class Xn extends st{constructor(e,t){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];let n=this,i=[],r=[];for(let c=0,h=e.length;c<h;c++)a(e[c]);function a(c){let h=[],u=t.curveSegments!==void 0?t.curveSegments:12,d=t.steps!==void 0?t.steps:1,p=t.depth!==void 0?t.depth:100,f=t.bevelEnabled===void 0||t.bevelEnabled,m=t.bevelThickness!==void 0?t.bevelThickness:6,g=t.bevelSize!==void 0?t.bevelSize:m-2,y=t.bevelOffset!==void 0?t.bevelOffset:0,x=t.bevelSegments!==void 0?t.bevelSegments:3,v=t.extrudePath,w=t.UVGenerator!==void 0?t.UVGenerator:Yf;t.amount!==void 0&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),p=t.amount);let A,S,D,F,q,X=!1;v&&(A=v.getSpacedPoints(d),X=!0,f=!1,S=v.computeFrenetFrames(d,!1),D=new L,F=new L,q=new L),f||(x=0,m=0,g=0,y=0);let te=c.extractPoints(u),J=te.shape,$=te.holes;if(!ai.isClockWise(J)){J=J.reverse();for(let ne=0,C=$.length;ne<C;ne++){let K=$[ne];ai.isClockWise(K)&&($[ne]=K.reverse())}}let Re=ai.triangulateShape(J,$),ye=J;for(let ne=0,C=$.length;ne<C;ne++){let K=$[ne];J=J.concat(K)}function ae(ne,C,K){return C||console.error("THREE.ExtrudeGeometry: vec does not exist"),C.clone().multiplyScalar(K).add(ne)}let be=J.length,Ce=Re.length;function Ie(ne,C,K){let de,pe,ue,Ne=ne.x-C.x,Je=ne.y-C.y,Be=K.x-ne.x,ut=K.y-ne.y,lt=Ne*Ne+Je*Je,on=Ne*ut-Je*Be;if(Math.abs(on)>Number.EPSILON){let Pt=Math.sqrt(lt),ln=Math.sqrt(Be*Be+ut*ut),On=C.x-Je/Pt,lr=C.y+Ne/Pt,cr=((K.x-ut/ln-On)*ut-(K.y+Be/ln-lr)*Be)/(Ne*ut-Je*Be);de=On+Ne*cr-ne.x,pe=lr+Je*cr-ne.y;let hr=de*de+pe*pe;if(hr<=2)return new me(de,pe);ue=Math.sqrt(hr/2)}else{let Pt=!1;Ne>Number.EPSILON?Be>Number.EPSILON&&(Pt=!0):Ne<-Number.EPSILON?Be<-Number.EPSILON&&(Pt=!0):Math.sign(Je)===Math.sign(ut)&&(Pt=!0),Pt?(de=-Je,pe=Ne,ue=Math.sqrt(lt)):(de=Ne,pe=Je,ue=Math.sqrt(lt/2))}return new me(de/ue,pe/ue)}let ke=[];for(let ne=0,C=ye.length,K=C-1,de=ne+1;ne<C;ne++,K++,de++)K===C&&(K=0),de===C&&(de=0),ke[ne]=Ie(ye[ne],ye[K],ye[de]);let $e=[],et,_e=ke.concat();for(let ne=0,C=$.length;ne<C;ne++){let K=$[ne];et=[];for(let de=0,pe=K.length,ue=pe-1,Ne=de+1;de<pe;de++,ue++,Ne++)ue===pe&&(ue=0),Ne===pe&&(Ne=0),et[de]=Ie(K[de],K[ue],K[Ne]);$e.push(et),_e=_e.concat(et)}for(let ne=0;ne<x;ne++){let C=ne/x,K=m*Math.cos(C*Math.PI/2),de=g*Math.sin(C*Math.PI/2)+y;for(let pe=0,ue=ye.length;pe<ue;pe++){let Ne=ae(ye[pe],ke[pe],de);ce(Ne.x,Ne.y,-K)}for(let pe=0,ue=$.length;pe<ue;pe++){let Ne=$[pe];et=$e[pe];for(let Je=0,Be=Ne.length;Je<Be;Je++){let ut=ae(Ne[Je],et[Je],de);ce(ut.x,ut.y,-K)}}}let O=g+y;for(let ne=0;ne<be;ne++){let C=f?ae(J[ne],_e[ne],O):J[ne];X?(F.copy(S.normals[0]).multiplyScalar(C.x),D.copy(S.binormals[0]).multiplyScalar(C.y),q.copy(A[0]).add(F).add(D),ce(q.x,q.y,q.z)):ce(C.x,C.y,0)}for(let ne=1;ne<=d;ne++)for(let C=0;C<be;C++){let K=f?ae(J[C],_e[C],O):J[C];X?(F.copy(S.normals[ne]).multiplyScalar(K.x),D.copy(S.binormals[ne]).multiplyScalar(K.y),q.copy(A[ne]).add(F).add(D),ce(q.x,q.y,q.z)):ce(K.x,K.y,p/d*ne)}for(let ne=x-1;ne>=0;ne--){let C=ne/x,K=m*Math.cos(C*Math.PI/2),de=g*Math.sin(C*Math.PI/2)+y;for(let pe=0,ue=ye.length;pe<ue;pe++){let Ne=ae(ye[pe],ke[pe],de);ce(Ne.x,Ne.y,p+K)}for(let pe=0,ue=$.length;pe<ue;pe++){let Ne=$[pe];et=$e[pe];for(let Je=0,Be=Ne.length;Je<Be;Je++){let ut=ae(Ne[Je],et[Je],de);X?ce(ut.x,ut.y+A[d-1].y,A[d-1].x+K):ce(ut.x,ut.y,p+K)}}}function B(ne,C){let K=ne.length;for(;--K>=0;){let de=K,pe=K-1;pe<0&&(pe=ne.length-1);for(let ue=0,Ne=d+2*x;ue<Ne;ue++){let Je=be*ue,Be=be*(ue+1);ee(C+de+Je,C+pe+Je,C+pe+Be,C+de+Be)}}}function ce(ne,C,K){h.push(ne),h.push(C),h.push(K)}function se(ne,C,K){Le(ne),Le(C),Le(K);let de=i.length/3,pe=w.generateTopUV(n,i,de-3,de-2,de-1);Ee(pe[0]),Ee(pe[1]),Ee(pe[2])}function ee(ne,C,K,de){Le(ne),Le(C),Le(de),Le(C),Le(K),Le(de);let pe=i.length/3,ue=w.generateSideWallUV(n,i,pe-6,pe-3,pe-2,pe-1);Ee(ue[0]),Ee(ue[1]),Ee(ue[3]),Ee(ue[1]),Ee(ue[2]),Ee(ue[3])}function Le(ne){i.push(h[3*ne+0]),i.push(h[3*ne+1]),i.push(h[3*ne+2])}function Ee(ne){r.push(ne.x),r.push(ne.y)}(function(){let ne=i.length/3;if(f){let C=0,K=be*C;for(let de=0;de<Ce;de++){let pe=Re[de];se(pe[2]+K,pe[1]+K,pe[0]+K)}C=d+2*x,K=be*C;for(let de=0;de<Ce;de++){let pe=Re[de];se(pe[0]+K,pe[1]+K,pe[2]+K)}}else{for(let C=0;C<Ce;C++){let K=Re[C];se(K[2],K[1],K[0])}for(let C=0;C<Ce;C++){let K=Re[C];se(K[0]+be*d,K[1]+be*d,K[2]+be*d)}}n.addGroup(ne,i.length/3-ne,0)})(),function(){let ne=i.length/3,C=0;B(ye,C),C+=ye.length;for(let K=0,de=$.length;K<de;K++){let pe=$[K];B(pe,C),C+=pe.length}n.addGroup(ne,i.length/3-ne,1)}()}this.setAttribute("position",new Ue(i,3)),this.setAttribute("uv",new Ue(r,2)),this.computeVertexNormals()}toJSON(){let e=super.toJSON();return function(t,n,i){if(i.shapes=[],Array.isArray(t))for(let r=0,a=t.length;r<a;r++){let c=t[r];i.shapes.push(c.uuid)}else i.shapes.push(t.uuid);return n.extrudePath!==void 0&&(i.options.extrudePath=n.extrudePath.toJSON()),i}(this.parameters.shapes,this.parameters.options,e)}static fromJSON(e,t){let n=[];for(let r=0,a=e.shapes.length;r<a;r++){let c=t[e.shapes[r]];n.push(c)}let i=e.options.extrudePath;return i!==void 0&&(e.options.extrudePath=new Jo[i.type]().fromJSON(i)),new Xn(n,e.options)}}let Yf={generateTopUV:function(s,e,t,n,i){let r=e[3*t],a=e[3*t+1],c=e[3*n],h=e[3*n+1],u=e[3*i],d=e[3*i+1];return[new me(r,a),new me(c,h),new me(u,d)]},generateSideWallUV:function(s,e,t,n,i,r){let a=e[3*t],c=e[3*t+1],h=e[3*t+2],u=e[3*n],d=e[3*n+1],p=e[3*n+2],f=e[3*i],m=e[3*i+1],g=e[3*i+2],y=e[3*r],x=e[3*r+1],v=e[3*r+2];return Math.abs(c-d)<Math.abs(a-u)?[new me(a,1-h),new me(u,1-p),new me(f,1-g),new me(y,1-v)]:[new me(c,1-h),new me(d,1-p),new me(m,1-g),new me(x,1-v)]}};class Vr extends si{constructor(e=1,t=0){let n=(1+Math.sqrt(5))/2;super([-1,n,0,1,n,0,-1,-n,0,1,-n,0,0,-1,n,0,1,n,0,-1,-n,0,1,-n,n,0,-1,n,0,1,-n,0,-1,-n,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],e,t),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new Vr(e.radius,e.detail)}}class Wr extends st{constructor(e,t=12,n=0,i=2*Math.PI){super(),this.type="LatheGeometry",this.parameters={points:e,segments:t,phiStart:n,phiLength:i},t=Math.floor(t),i=Ke(i,0,2*Math.PI);let r=[],a=[],c=[],h=1/t,u=new L,d=new me;for(let p=0;p<=t;p++){let f=n+p*h*i,m=Math.sin(f),g=Math.cos(f);for(let y=0;y<=e.length-1;y++)u.x=e[y].x*m,u.y=e[y].y,u.z=e[y].x*g,a.push(u.x,u.y,u.z),d.x=p/t,d.y=y/(e.length-1),c.push(d.x,d.y)}for(let p=0;p<t;p++)for(let f=0;f<e.length-1;f++){let m=f+p*e.length,g=m,y=m+e.length,x=m+e.length+1,v=m+1;r.push(g,y,v),r.push(y,x,v)}if(this.setIndex(r),this.setAttribute("position",new Ue(a,3)),this.setAttribute("uv",new Ue(c,2)),this.computeVertexNormals(),i===2*Math.PI){let p=this.attributes.normal.array,f=new L,m=new L,g=new L,y=t*e.length*3;for(let x=0,v=0;x<e.length;x++,v+=3)f.x=p[v+0],f.y=p[v+1],f.z=p[v+2],m.x=p[y+v+0],m.y=p[y+v+1],m.z=p[y+v+2],g.addVectors(f,m).normalize(),p[v+0]=p[y+v+0]=g.x,p[v+1]=p[y+v+1]=g.y,p[v+2]=p[y+v+2]=g.z}}static fromJSON(e){return new Wr(e.points,e.segments,e.phiStart,e.phiLength)}}class Qi extends si{constructor(e=1,t=0){super([1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],e,t),this.type="OctahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new Qi(e.radius,e.detail)}}class Da extends st{constructor(e,t,n){super(),this.type="ParametricGeometry",this.parameters={func:e,slices:t,stacks:n};let i=[],r=[],a=[],c=[],h=1e-5,u=new L,d=new L,p=new L,f=new L,m=new L;e.length<3&&console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");let g=t+1;for(let y=0;y<=n;y++){let x=y/n;for(let v=0;v<=t;v++){let w=v/t;e(w,x,d),r.push(d.x,d.y,d.z),w-h>=0?(e(w-h,x,p),f.subVectors(d,p)):(e(w+h,x,p),f.subVectors(p,d)),x-h>=0?(e(w,x-h,p),m.subVectors(d,p)):(e(w,x+h,p),m.subVectors(p,d)),u.crossVectors(f,m).normalize(),a.push(u.x,u.y,u.z),c.push(w,x)}}for(let y=0;y<n;y++)for(let x=0;x<t;x++){let v=y*g+x,w=y*g+x+1,A=(y+1)*g+x+1,S=(y+1)*g+x;i.push(v,w,S),i.push(w,A,S)}this.setIndex(i),this.setAttribute("position",new Ue(r,3)),this.setAttribute("normal",new Ue(a,3)),this.setAttribute("uv",new Ue(c,2))}}class qr extends st{constructor(e=.5,t=1,n=8,i=1,r=0,a=2*Math.PI){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:n,phiSegments:i,thetaStart:r,thetaLength:a},n=Math.max(3,n);let c=[],h=[],u=[],d=[],p=e,f=(t-e)/(i=Math.max(1,i)),m=new L,g=new me;for(let y=0;y<=i;y++){for(let x=0;x<=n;x++){let v=r+x/n*a;m.x=p*Math.cos(v),m.y=p*Math.sin(v),h.push(m.x,m.y,m.z),u.push(0,0,1),g.x=(m.x/t+1)/2,g.y=(m.y/t+1)/2,d.push(g.x,g.y)}p+=f}for(let y=0;y<i;y++){let x=y*(n+1);for(let v=0;v<n;v++){let w=v+x,A=w,S=w+n+1,D=w+n+2,F=w+1;c.push(A,S,F),c.push(S,D,F)}}this.setIndex(c),this.setAttribute("position",new Ue(h,3)),this.setAttribute("normal",new Ue(u,3)),this.setAttribute("uv",new Ue(d,2))}static fromJSON(e){return new qr(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)}}class $i extends st{constructor(e,t=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};let n=[],i=[],r=[],a=[],c=0,h=0;if(Array.isArray(e)===!1)u(e);else for(let d=0;d<e.length;d++)u(e[d]),this.addGroup(c,h,d),c+=h,h=0;function u(d){let p=i.length/3,f=d.extractPoints(t),m=f.shape,g=f.holes;ai.isClockWise(m)===!1&&(m=m.reverse());for(let x=0,v=g.length;x<v;x++){let w=g[x];ai.isClockWise(w)===!0&&(g[x]=w.reverse())}let y=ai.triangulateShape(m,g);for(let x=0,v=g.length;x<v;x++){let w=g[x];m=m.concat(w)}for(let x=0,v=m.length;x<v;x++){let w=m[x];i.push(w.x,w.y,0),r.push(0,0,1),a.push(w.x,w.y)}for(let x=0,v=y.length;x<v;x++){let w=y[x],A=w[0]+p,S=w[1]+p,D=w[2]+p;n.push(A,S,D),h+=3}}this.setIndex(n),this.setAttribute("position",new Ue(i,3)),this.setAttribute("normal",new Ue(r,3)),this.setAttribute("uv",new Ue(a,2))}toJSON(){let e=super.toJSON();return function(t,n){if(n.shapes=[],Array.isArray(t))for(let i=0,r=t.length;i<r;i++){let a=t[i];n.shapes.push(a.uuid)}else n.shapes.push(t.uuid);return n}(this.parameters.shapes,e)}static fromJSON(e,t){let n=[];for(let i=0,r=e.shapes.length;i<r;i++){let a=t[e.shapes[i]];n.push(a)}return new $i(n,e.curveSegments)}}class er extends st{constructor(e=1,t=32,n=16,i=0,r=2*Math.PI,a=0,c=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:n,phiStart:i,phiLength:r,thetaStart:a,thetaLength:c},t=Math.max(3,Math.floor(t)),n=Math.max(2,Math.floor(n));let h=Math.min(a+c,Math.PI),u=0,d=[],p=new L,f=new L,m=[],g=[],y=[],x=[];for(let v=0;v<=n;v++){let w=[],A=v/n,S=0;v==0&&a==0?S=.5/t:v==n&&h==Math.PI&&(S=-.5/t);for(let D=0;D<=t;D++){let F=D/t;p.x=-e*Math.cos(i+F*r)*Math.sin(a+A*c),p.y=e*Math.cos(a+A*c),p.z=e*Math.sin(i+F*r)*Math.sin(a+A*c),g.push(p.x,p.y,p.z),f.copy(p).normalize(),y.push(f.x,f.y,f.z),x.push(F+S,1-A),w.push(u++)}d.push(w)}for(let v=0;v<n;v++)for(let w=0;w<t;w++){let A=d[v][w+1],S=d[v][w],D=d[v+1][w],F=d[v+1][w+1];(v!==0||a>0)&&m.push(A,S,F),(v!==n-1||h<Math.PI)&&m.push(S,D,F)}this.setIndex(m),this.setAttribute("position",new Ue(g,3)),this.setAttribute("normal",new Ue(y,3)),this.setAttribute("uv",new Ue(x,2))}static fromJSON(e){return new er(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}}class jr extends si{constructor(e=1,t=0){super([1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],e,t),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new jr(e.radius,e.detail)}}class Ia extends Xn{constructor(e,t={}){let n=t.font;if(!n||!n.isFont)return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),new st;let i=n.generateShapes(e,t.size);t.depth=t.height!==void 0?t.height:50,t.bevelThickness===void 0&&(t.bevelThickness=10),t.bevelSize===void 0&&(t.bevelSize=8),t.bevelEnabled===void 0&&(t.bevelEnabled=!1),super(i,t),this.type="TextGeometry"}}class Xr extends st{constructor(e=1,t=.4,n=8,i=6,r=2*Math.PI){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:t,radialSegments:n,tubularSegments:i,arc:r},n=Math.floor(n),i=Math.floor(i);let a=[],c=[],h=[],u=[],d=new L,p=new L,f=new L;for(let m=0;m<=n;m++)for(let g=0;g<=i;g++){let y=g/i*r,x=m/n*Math.PI*2;p.x=(e+t*Math.cos(x))*Math.cos(y),p.y=(e+t*Math.cos(x))*Math.sin(y),p.z=t*Math.sin(x),c.push(p.x,p.y,p.z),d.x=e*Math.cos(y),d.y=e*Math.sin(y),f.subVectors(p,d).normalize(),h.push(f.x,f.y,f.z),u.push(g/i),u.push(m/n)}for(let m=1;m<=n;m++)for(let g=1;g<=i;g++){let y=(i+1)*m+g-1,x=(i+1)*(m-1)+g-1,v=(i+1)*(m-1)+g,w=(i+1)*m+g;a.push(y,x,w),a.push(x,v,w)}this.setIndex(a),this.setAttribute("position",new Ue(c,3)),this.setAttribute("normal",new Ue(h,3)),this.setAttribute("uv",new Ue(u,2))}static fromJSON(e){return new Xr(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)}}class Zr extends st{constructor(e=1,t=.4,n=64,i=8,r=2,a=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:t,tubularSegments:n,radialSegments:i,p:r,q:a},n=Math.floor(n),i=Math.floor(i);let c=[],h=[],u=[],d=[],p=new L,f=new L,m=new L,g=new L,y=new L,x=new L,v=new L;for(let A=0;A<=n;++A){let S=A/n*r*Math.PI*2;w(S,r,a,e,m),w(S+.01,r,a,e,g),x.subVectors(g,m),v.addVectors(g,m),y.crossVectors(x,v),v.crossVectors(y,x),y.normalize(),v.normalize();for(let D=0;D<=i;++D){let F=D/i*Math.PI*2,q=-t*Math.cos(F),X=t*Math.sin(F);p.x=m.x+(q*v.x+X*y.x),p.y=m.y+(q*v.y+X*y.y),p.z=m.z+(q*v.z+X*y.z),h.push(p.x,p.y,p.z),f.subVectors(p,m).normalize(),u.push(f.x,f.y,f.z),d.push(A/n),d.push(D/i)}}for(let A=1;A<=n;A++)for(let S=1;S<=i;S++){let D=(i+1)*(A-1)+(S-1),F=(i+1)*A+(S-1),q=(i+1)*A+S,X=(i+1)*(A-1)+S;c.push(D,F,X),c.push(F,q,X)}function w(A,S,D,F,q){let X=Math.cos(A),te=Math.sin(A),J=D/S*A,$=Math.cos(J);q.x=F*(2+$)*.5*X,q.y=F*(2+$)*te*.5,q.z=F*Math.sin(J)*.5}this.setIndex(c),this.setAttribute("position",new Ue(h,3)),this.setAttribute("normal",new Ue(u,3)),this.setAttribute("uv",new Ue(d,2))}static fromJSON(e){return new Zr(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)}}class Yr extends st{constructor(e,t=64,n=1,i=8,r=!1){super(),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:t,radius:n,radialSegments:i,closed:r};let a=e.computeFrenetFrames(t,r);this.tangents=a.tangents,this.normals=a.normals,this.binormals=a.binormals;let c=new L,h=new L,u=new me,d=new L,p=[],f=[],m=[],g=[];function y(x){d=e.getPointAt(x/t,d);let v=a.normals[x],w=a.binormals[x];for(let A=0;A<=i;A++){let S=A/i*Math.PI*2,D=Math.sin(S),F=-Math.cos(S);h.x=F*v.x+D*w.x,h.y=F*v.y+D*w.y,h.z=F*v.z+D*w.z,h.normalize(),f.push(h.x,h.y,h.z),c.x=d.x+n*h.x,c.y=d.y+n*h.y,c.z=d.z+n*h.z,p.push(c.x,c.y,c.z)}}(function(){for(let x=0;x<t;x++)y(x);y(r===!1?t:0),function(){for(let x=0;x<=t;x++)for(let v=0;v<=i;v++)u.x=x/t,u.y=v/i,m.push(u.x,u.y)}(),function(){for(let x=1;x<=t;x++)for(let v=1;v<=i;v++){let w=(i+1)*(x-1)+(v-1),A=(i+1)*x+(v-1),S=(i+1)*x+v,D=(i+1)*(x-1)+v;g.push(w,A,D),g.push(A,S,D)}}()})(),this.setIndex(g),this.setAttribute("position",new Ue(p,3)),this.setAttribute("normal",new Ue(f,3)),this.setAttribute("uv",new Ue(m,2))}toJSON(){let e=super.toJSON();return e.path=this.parameters.path.toJSON(),e}static fromJSON(e){return new Yr(new Jo[e.path.type]().fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)}}class $o extends st{constructor(e){if(super(),this.type="WireframeGeometry",e.isGeometry===!0)return void console.error("THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");let t=[],n=new Set,i=new L,r=new L;if(e.index!==null){let a=e.attributes.position,c=e.index,h=e.groups;h.length===0&&(h=[{start:0,count:c.count,materialIndex:0}]);for(let u=0,d=h.length;u<d;++u){let p=h[u],f=p.start;for(let m=f,g=f+p.count;m<g;m+=3)for(let y=0;y<3;y++){let x=c.getX(m+y),v=c.getX(m+(y+1)%3);i.fromBufferAttribute(a,x),r.fromBufferAttribute(a,v),xh(i,r,n)===!0&&(t.push(i.x,i.y,i.z),t.push(r.x,r.y,r.z))}}}else{let a=e.attributes.position;for(let c=0,h=a.count/3;c<h;c++)for(let u=0;u<3;u++){let d=3*c+u,p=3*c+(u+1)%3;i.fromBufferAttribute(a,d),r.fromBufferAttribute(a,p),xh(i,r,n)===!0&&(t.push(i.x,i.y,i.z),t.push(r.x,r.y,r.z))}}this.setAttribute("position",new Ue(t,3))}}function xh(s,e,t){let n=`${s.x},${s.y},${s.z}-${e.x},${e.y},${e.z}`,i=`${e.x},${e.y},${e.z}-${s.x},${s.y},${s.z}`;return t.has(n)!==!0&&t.has(i)!==!0&&(t.add(n,i),!0)}var _h=Object.freeze({__proto__:null,BoxGeometry:vi,BoxBufferGeometry:vi,CircleGeometry:Hr,CircleBufferGeometry:Hr,ConeGeometry:Ur,ConeBufferGeometry:Ur,CylinderGeometry:Oi,CylinderBufferGeometry:Oi,DodecahedronGeometry:Gr,DodecahedronBufferGeometry:Gr,EdgesGeometry:Go,ExtrudeGeometry:Xn,ExtrudeBufferGeometry:Xn,IcosahedronGeometry:Vr,IcosahedronBufferGeometry:Vr,LatheGeometry:Wr,LatheBufferGeometry:Wr,OctahedronGeometry:Qi,OctahedronBufferGeometry:Qi,ParametricGeometry:Da,ParametricBufferGeometry:Da,PlaneGeometry:qi,PlaneBufferGeometry:qi,PolyhedronGeometry:si,PolyhedronBufferGeometry:si,RingGeometry:qr,RingBufferGeometry:qr,ShapeGeometry:$i,ShapeBufferGeometry:$i,SphereGeometry:er,SphereBufferGeometry:er,TetrahedronGeometry:jr,TetrahedronBufferGeometry:jr,TextGeometry:Ia,TextBufferGeometry:Ia,TorusGeometry:Xr,TorusBufferGeometry:Xr,TorusKnotGeometry:Zr,TorusKnotBufferGeometry:Zr,TubeGeometry:Yr,TubeBufferGeometry:Yr,WireframeGeometry:$o});class el extends nn{constructor(e){super(),this.type="ShadowMaterial",this.color=new De(0),this.transparent=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this}}el.prototype.isShadowMaterial=!0;class Oa extends nn{constructor(e){super(),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new De(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new De(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new me(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this}}Oa.prototype.isMeshStandardMaterial=!0;class tl extends Oa{constructor(e){super(),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new me(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return Ke(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.sheenTint=new De(0),this.transmission=0,this.transmissionMap=null,this.thickness=.01,this.thicknessMap=null,this.attenuationDistance=0,this.attenuationTint=new De(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularTint=new De(1,1,1),this.specularTintMap=null,this._clearcoat=0,this._transmission=0,this.setValues(e)}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.ior=e.ior,this.sheenTint.copy(e.sheenTint),this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationTint.copy(e.attenuationTint),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularTint.copy(e.specularTint),this.specularTintMap=e.specularTintMap,this}}tl.prototype.isMeshPhysicalMaterial=!0;class nl extends nn{constructor(e){super(),this.type="MeshPhongMaterial",this.color=new De(16777215),this.specular=new De(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new De(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new me(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this}}nl.prototype.isMeshPhongMaterial=!0;class il extends nn{constructor(e){super(),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new De(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new De(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new me(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this}}il.prototype.isMeshToonMaterial=!0;class rl extends nn{constructor(e){super(),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new me(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.flatShading=e.flatShading,this}}rl.prototype.isMeshNormalMaterial=!0;class sl extends nn{constructor(e){super(),this.type="MeshLambertMaterial",this.color=new De(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new De(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this}}sl.prototype.isMeshLambertMaterial=!0;class al extends nn{constructor(e){super(),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new De(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new me(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.flatShading=e.flatShading,this}}al.prototype.isMeshMatcapMaterial=!0;class ol extends an{constructor(e){super(),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}ol.prototype.isLineDashedMaterial=!0;var Jf=Object.freeze({__proto__:null,ShadowMaterial:el,SpriteMaterial:ca,RawShaderMaterial:Pr,ShaderMaterial:xi,PointsMaterial:Ki,MeshPhysicalMaterial:tl,MeshStandardMaterial:Oa,MeshPhongMaterial:nl,MeshToonMaterial:il,MeshNormalMaterial:rl,MeshLambertMaterial:sl,MeshDepthMaterial:aa,MeshDistanceMaterial:oa,MeshBasicMaterial:yi,MeshMatcapMaterial:al,LineDashedMaterial:ol,LineBasicMaterial:an,Material:nn});let Ut={arraySlice:function(s,e,t){return Ut.isTypedArray(s)?new s.constructor(s.subarray(e,t!==void 0?t:s.length)):s.slice(e,t)},convertArray:function(s,e,t){return!s||!t&&s.constructor===e?s:typeof e.BYTES_PER_ELEMENT=="number"?new e(s):Array.prototype.slice.call(s)},isTypedArray:function(s){return ArrayBuffer.isView(s)&&!(s instanceof DataView)},getKeyframeOrder:function(s){let e=s.length,t=new Array(e);for(let n=0;n!==e;++n)t[n]=n;return t.sort(function(n,i){return s[n]-s[i]}),t},sortedArray:function(s,e,t){let n=s.length,i=new s.constructor(n);for(let r=0,a=0;a!==n;++r){let c=t[r]*e;for(let h=0;h!==e;++h)i[a++]=s[c+h]}return i},flattenJSON:function(s,e,t,n){let i=1,r=s[0];for(;r!==void 0&&r[n]===void 0;)r=s[i++];if(r===void 0)return;let a=r[n];if(a!==void 0)if(Array.isArray(a))do a=r[n],a!==void 0&&(e.push(r.time),t.push.apply(t,a)),r=s[i++];while(r!==void 0);else if(a.toArray!==void 0)do a=r[n],a!==void 0&&(e.push(r.time),a.toArray(t,t.length)),r=s[i++];while(r!==void 0);else do a=r[n],a!==void 0&&(e.push(r.time),t.push(a)),r=s[i++];while(r!==void 0)},subclip:function(s,e,t,n,i=30){let r=s.clone();r.name=e;let a=[];for(let h=0;h<r.tracks.length;++h){let u=r.tracks[h],d=u.getValueSize(),p=[],f=[];for(let m=0;m<u.times.length;++m){let g=u.times[m]*i;if(!(g<t||g>=n)){p.push(u.times[m]);for(let y=0;y<d;++y)f.push(u.values[m*d+y])}}p.length!==0&&(u.times=Ut.convertArray(p,u.times.constructor),u.values=Ut.convertArray(f,u.values.constructor),a.push(u))}r.tracks=a;let c=1/0;for(let h=0;h<r.tracks.length;++h)c>r.tracks[h].times[0]&&(c=r.tracks[h].times[0]);for(let h=0;h<r.tracks.length;++h)r.tracks[h].shift(-1*c);return r.resetDuration(),r},makeClipAdditive:function(s,e=0,t=s,n=30){n<=0&&(n=30);let i=t.tracks.length,r=e/n;for(let a=0;a<i;++a){let c=t.tracks[a],h=c.ValueTypeName;if(h==="bool"||h==="string")continue;let u=s.tracks.find(function(v){return v.name===c.name&&v.ValueTypeName===h});if(u===void 0)continue;let d=0,p=c.getValueSize();c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(d=p/3);let f=0,m=u.getValueSize();u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(f=m/3);let g=c.times.length-1,y;if(r<=c.times[0]){let v=d,w=p-d;y=Ut.arraySlice(c.values,v,w)}else if(r>=c.times[g]){let v=g*p+d,w=v+p-d;y=Ut.arraySlice(c.values,v,w)}else{let v=c.createInterpolant(),w=d,A=p-d;v.evaluate(r),y=Ut.arraySlice(v.resultBuffer,w,A)}h==="quaternion"&&new tn().fromArray(y).normalize().conjugate().toArray(y);let x=u.times.length;for(let v=0;v<x;++v){let w=v*m+f;if(h==="quaternion")tn.multiplyQuaternionsFlat(u.values,w,y,0,u.values,w);else{let A=m-2*f;for(let S=0;S<A;++S)u.values[w+S]-=y[S]}}}return s.blendMode=2501,s}};class bi{constructor(e,t,n,i){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=i!==void 0?i:new t.constructor(n),this.sampleValues=t,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(e){let t=this.parameterPositions,n=this._cachedIndex,i=t[n],r=t[n-1];e:{t:{let a;n:{i:if(!(e<i)){for(let c=n+2;;){if(i===void 0){if(e<r)break i;return n=t.length,this._cachedIndex=n,this.afterEnd_(n-1,e,r)}if(n===c)break;if(r=i,i=t[++n],e<i)break t}a=t.length;break n}if(e>=r)break e;{let c=t[1];e<c&&(n=2,r=c);for(let h=n-2;;){if(r===void 0)return this._cachedIndex=0,this.beforeStart_(0,e,i);if(n===h)break;if(i=r,r=t[--n-1],e>=r)break t}a=n,n=0}}for(;n<a;){let c=n+a>>>1;e<t[c]?a=c:n=c+1}if(i=t[n],r=t[n-1],r===void 0)return this._cachedIndex=0,this.beforeStart_(0,e,i);if(i===void 0)return n=t.length,this._cachedIndex=n,this.afterEnd_(n-1,r,e)}this._cachedIndex=n,this.intervalChanged_(n,r,i)}return this.interpolate_(n,r,e,i)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){let t=this.resultBuffer,n=this.sampleValues,i=this.valueSize,r=e*i;for(let a=0;a!==i;++a)t[a]=n[r+a];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}bi.prototype.beforeStart_=bi.prototype.copySampleValue_,bi.prototype.afterEnd_=bi.prototype.copySampleValue_;class bh extends bi{constructor(e,t,n,i){super(e,t,n,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:2400,endingEnd:2400}}intervalChanged_(e,t,n){let i=this.parameterPositions,r=e-2,a=e+1,c=i[r],h=i[a];if(c===void 0)switch(this.getSettings_().endingStart){case 2401:r=e,c=2*t-n;break;case 2402:r=i.length-2,c=t+i[r]-i[r+1];break;default:r=e,c=n}if(h===void 0)switch(this.getSettings_().endingEnd){case 2401:a=e,h=2*n-t;break;case 2402:a=1,h=n+i[1]-i[0];break;default:a=e-1,h=t}let u=.5*(n-t),d=this.valueSize;this._weightPrev=u/(t-c),this._weightNext=u/(h-n),this._offsetPrev=r*d,this._offsetNext=a*d}interpolate_(e,t,n,i){let r=this.resultBuffer,a=this.sampleValues,c=this.valueSize,h=e*c,u=h-c,d=this._offsetPrev,p=this._offsetNext,f=this._weightPrev,m=this._weightNext,g=(n-t)/(i-t),y=g*g,x=y*g,v=-f*x+2*f*y-f*g,w=(1+f)*x+(-1.5-2*f)*y+(-.5+f)*g+1,A=(-1-m)*x+(1.5+m)*y+.5*g,S=m*x-m*y;for(let D=0;D!==c;++D)r[D]=v*a[d+D]+w*a[u+D]+A*a[h+D]+S*a[p+D];return r}}class ll extends bi{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e,t,n,i){let r=this.resultBuffer,a=this.sampleValues,c=this.valueSize,h=e*c,u=h-c,d=(n-t)/(i-t),p=1-d;for(let f=0;f!==c;++f)r[f]=a[u+f]*p+a[h+f]*d;return r}}class Mh extends bi{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e){return this.copySampleValue_(e-1)}}class Zn{constructor(e,t,n,i){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(t===void 0||t.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=Ut.convertArray(t,this.TimeBufferType),this.values=Ut.convertArray(n,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(e){let t=e.constructor,n;if(t.toJSON!==this.toJSON)n=t.toJSON(e);else{n={name:e.name,times:Ut.convertArray(e.times,Array),values:Ut.convertArray(e.values,Array)};let i=e.getInterpolation();i!==e.DefaultInterpolation&&(n.interpolation=i)}return n.type=e.ValueTypeName,n}InterpolantFactoryMethodDiscrete(e){return new Mh(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new ll(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new bh(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case 2300:t=this.InterpolantFactoryMethodDiscrete;break;case 2301:t=this.InterpolantFactoryMethodLinear;break;case 2302:t=this.InterpolantFactoryMethodSmooth}if(t===void 0){let n="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0){if(e===this.DefaultInterpolation)throw new Error(n);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",n),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return 2300;case this.InterpolantFactoryMethodLinear:return 2301;case this.InterpolantFactoryMethodSmooth:return 2302}}getValueSize(){return this.values.length/this.times.length}shift(e){if(e!==0){let t=this.times;for(let n=0,i=t.length;n!==i;++n)t[n]+=e}return this}scale(e){if(e!==1){let t=this.times;for(let n=0,i=t.length;n!==i;++n)t[n]*=e}return this}trim(e,t){let n=this.times,i=n.length,r=0,a=i-1;for(;r!==i&&n[r]<e;)++r;for(;a!==-1&&n[a]>t;)--a;if(++a,r!==0||a!==i){r>=a&&(a=Math.max(a,1),r=a-1);let c=this.getValueSize();this.times=Ut.arraySlice(n,r,a),this.values=Ut.arraySlice(this.values,r*c,a*c)}return this}validate(){let e=!0,t=this.getValueSize();t-Math.floor(t)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);let n=this.times,i=this.values,r=n.length;r===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let a=null;for(let c=0;c!==r;c++){let h=n[c];if(typeof h=="number"&&isNaN(h)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,c,h),e=!1;break}if(a!==null&&a>h){console.error("THREE.KeyframeTrack: Out of order keys.",this,c,h,a),e=!1;break}a=h}if(i!==void 0&&Ut.isTypedArray(i))for(let c=0,h=i.length;c!==h;++c){let u=i[c];if(isNaN(u)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,c,u),e=!1;break}}return e}optimize(){let e=Ut.arraySlice(this.times),t=Ut.arraySlice(this.values),n=this.getValueSize(),i=this.getInterpolation()===2302,r=e.length-1,a=1;for(let c=1;c<r;++c){let h=!1,u=e[c];if(u!==e[c+1]&&(c!==1||u!==e[0]))if(i)h=!0;else{let d=c*n,p=d-n,f=d+n;for(let m=0;m!==n;++m){let g=t[d+m];if(g!==t[p+m]||g!==t[f+m]){h=!0;break}}}if(h){if(c!==a){e[a]=e[c];let d=c*n,p=a*n;for(let f=0;f!==n;++f)t[p+f]=t[d+f]}++a}}if(r>0){e[a]=e[r];for(let c=r*n,h=a*n,u=0;u!==n;++u)t[h+u]=t[c+u];++a}return a!==e.length?(this.times=Ut.arraySlice(e,0,a),this.values=Ut.arraySlice(t,0,a*n)):(this.times=e,this.values=t),this}clone(){let e=Ut.arraySlice(this.times,0),t=Ut.arraySlice(this.values,0),n=new this.constructor(this.name,e,t);return n.createInterpolant=this.createInterpolant,n}}Zn.prototype.TimeBufferType=Float32Array,Zn.prototype.ValueBufferType=Float32Array,Zn.prototype.DefaultInterpolation=2301;class tr extends Zn{}tr.prototype.ValueTypeName="bool",tr.prototype.ValueBufferType=Array,tr.prototype.DefaultInterpolation=2300,tr.prototype.InterpolantFactoryMethodLinear=void 0,tr.prototype.InterpolantFactoryMethodSmooth=void 0;class cl extends Zn{}cl.prototype.ValueTypeName="color";class ws extends Zn{}ws.prototype.ValueTypeName="number";class wh extends bi{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e,t,n,i){let r=this.resultBuffer,a=this.sampleValues,c=this.valueSize,h=(n-t)/(i-t),u=e*c;for(let d=u+c;u!==d;u+=4)tn.slerpFlat(r,0,a,u-c,a,u,h);return r}}class Jr extends Zn{InterpolantFactoryMethodLinear(e){return new wh(this.times,this.values,this.getValueSize(),e)}}Jr.prototype.ValueTypeName="quaternion",Jr.prototype.DefaultInterpolation=2301,Jr.prototype.InterpolantFactoryMethodSmooth=void 0;class nr extends Zn{}nr.prototype.ValueTypeName="string",nr.prototype.ValueBufferType=Array,nr.prototype.DefaultInterpolation=2300,nr.prototype.InterpolantFactoryMethodLinear=void 0,nr.prototype.InterpolantFactoryMethodSmooth=void 0;class Ss extends Zn{}Ss.prototype.ValueTypeName="vector";class Ts{constructor(e,t=-1,n,i=2500){this.name=e,this.tracks=n,this.duration=t,this.blendMode=i,this.uuid=nt(),this.duration<0&&this.resetDuration()}static parse(e){let t=[],n=e.tracks,i=1/(e.fps||1);for(let a=0,c=n.length;a!==c;++a)t.push(Kf(n[a]).scale(i));let r=new this(e.name,e.duration,t,e.blendMode);return r.uuid=e.uuid,r}static toJSON(e){let t=[],n=e.tracks,i={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let r=0,a=n.length;r!==a;++r)t.push(Zn.toJSON(n[r]));return i}static CreateFromMorphTargetSequence(e,t,n,i){let r=t.length,a=[];for(let c=0;c<r;c++){let h=[],u=[];h.push((c+r-1)%r,c,(c+1)%r),u.push(0,1,0);let d=Ut.getKeyframeOrder(h);h=Ut.sortedArray(h,1,d),u=Ut.sortedArray(u,1,d),i||h[0]!==0||(h.push(r),u.push(u[0])),a.push(new ws(".morphTargetInfluences["+t[c].name+"]",h,u).scale(1/n))}return new this(e,-1,a)}static findByName(e,t){let n=e;if(!Array.isArray(e)){let i=e;n=i.geometry&&i.geometry.animations||i.animations}for(let i=0;i<n.length;i++)if(n[i].name===t)return n[i];return null}static CreateClipsFromMorphTargetSequences(e,t,n){let i={},r=/^([\w-]*?)([\d]+)$/;for(let c=0,h=e.length;c<h;c++){let u=e[c],d=u.name.match(r);if(d&&d.length>1){let p=d[1],f=i[p];f||(i[p]=f=[]),f.push(u)}}let a=[];for(let c in i)a.push(this.CreateFromMorphTargetSequence(c,i[c],t,n));return a}static parseAnimation(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;let n=function(d,p,f,m,g){if(f.length!==0){let y=[],x=[];Ut.flattenJSON(f,y,x,m),y.length!==0&&g.push(new d(p,y,x))}},i=[],r=e.name||"default",a=e.fps||30,c=e.blendMode,h=e.length||-1,u=e.hierarchy||[];for(let d=0;d<u.length;d++){let p=u[d].keys;if(p&&p.length!==0)if(p[0].morphTargets){let f={},m;for(m=0;m<p.length;m++)if(p[m].morphTargets)for(let g=0;g<p[m].morphTargets.length;g++)f[p[m].morphTargets[g]]=-1;for(let g in f){let y=[],x=[];for(let v=0;v!==p[m].morphTargets.length;++v){let w=p[m];y.push(w.time),x.push(w.morphTarget===g?1:0)}i.push(new ws(".morphTargetInfluence["+g+"]",y,x))}h=f.length*(a||1)}else{let f=".bones["+t[d].name+"]";n(Ss,f+".position",p,"pos",i),n(Jr,f+".quaternion",p,"rot",i),n(Ss,f+".scale",p,"scl",i)}}return i.length===0?null:new this(r,h,i,c)}resetDuration(){let e=0;for(let t=0,n=this.tracks.length;t!==n;++t){let i=this.tracks[t];e=Math.max(e,i.times[i.times.length-1])}return this.duration=e,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){let e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function Kf(s){if(s.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");let e=function(t){switch(t.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return ws;case"vector":case"vector2":case"vector3":case"vector4":return Ss;case"color":return cl;case"quaternion":return Jr;case"bool":case"boolean":return tr;case"string":return nr}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+t)}(s.type);if(s.times===void 0){let t=[],n=[];Ut.flattenJSON(s.keys,t,n,"value"),s.times=t,s.values=n}return e.parse!==void 0?e.parse(s):new e(s.name,s.times,s.values,s.interpolation)}let ir={enabled:!1,files:{},add:function(s,e){this.enabled!==!1&&(this.files[s]=e)},get:function(s){if(this.enabled!==!1)return this.files[s]},remove:function(s){delete this.files[s]},clear:function(){this.files={}}};class hl{constructor(e,t,n){let i=this,r,a=!1,c=0,h=0,u=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=n,this.itemStart=function(d){h++,a===!1&&i.onStart!==void 0&&i.onStart(d,c,h),a=!0},this.itemEnd=function(d){c++,i.onProgress!==void 0&&i.onProgress(d,c,h),c===h&&(a=!1,i.onLoad!==void 0&&i.onLoad())},this.itemError=function(d){i.onError!==void 0&&i.onError(d)},this.resolveURL=function(d){return r?r(d):d},this.setURLModifier=function(d){return r=d,this},this.addHandler=function(d,p){return u.push(d,p),this},this.removeHandler=function(d){let p=u.indexOf(d);return p!==-1&&u.splice(p,2),this},this.getHandler=function(d){for(let p=0,f=u.length;p<f;p+=2){let m=u[p],g=u[p+1];if(m.global&&(m.lastIndex=0),m.test(d))return g}return null}}}let Sh=new hl;class pn{constructor(e){this.manager=e!==void 0?e:Sh,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){let n=this;return new Promise(function(i,r){n.load(e,i,t,r)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}let Yn={};class Jn extends pn{constructor(e){super(e)}load(e,t,n,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);let r=this,a=ir.get(e);if(a!==void 0)return r.manager.itemStart(e),setTimeout(function(){t&&t(a),r.manager.itemEnd(e)},0),a;if(Yn[e]!==void 0)return void Yn[e].push({onLoad:t,onProgress:n,onError:i});let c=e.match(/^data:(.*?)(;base64)?,(.*)$/),h;if(c){let u=c[1],d=!!c[2],p=c[3];p=decodeURIComponent(p),d&&(p=atob(p));try{let f,m=(this.responseType||"").toLowerCase();switch(m){case"arraybuffer":case"blob":let g=new Uint8Array(p.length);for(let x=0;x<p.length;x++)g[x]=p.charCodeAt(x);f=m==="blob"?new Blob([g.buffer],{type:u}):g.buffer;break;case"document":f=new DOMParser().parseFromString(p,u);break;case"json":f=JSON.parse(p);break;default:f=p}setTimeout(function(){t&&t(f),r.manager.itemEnd(e)},0)}catch(f){setTimeout(function(){i&&i(f),r.manager.itemError(e),r.manager.itemEnd(e)},0)}}else{Yn[e]=[],Yn[e].push({onLoad:t,onProgress:n,onError:i}),h=new XMLHttpRequest,h.open("GET",e,!0),h.addEventListener("load",function(u){let d=this.response,p=Yn[e];if(delete Yn[e],this.status===200||this.status===0){this.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),ir.add(e,d);for(let f=0,m=p.length;f<m;f++){let g=p[f];g.onLoad&&g.onLoad(d)}r.manager.itemEnd(e)}else{for(let f=0,m=p.length;f<m;f++){let g=p[f];g.onError&&g.onError(u)}r.manager.itemError(e),r.manager.itemEnd(e)}},!1),h.addEventListener("progress",function(u){let d=Yn[e];for(let p=0,f=d.length;p<f;p++){let m=d[p];m.onProgress&&m.onProgress(u)}},!1),h.addEventListener("error",function(u){let d=Yn[e];delete Yn[e];for(let p=0,f=d.length;p<f;p++){let m=d[p];m.onError&&m.onError(u)}r.manager.itemError(e),r.manager.itemEnd(e)},!1),h.addEventListener("abort",function(u){let d=Yn[e];delete Yn[e];for(let p=0,f=d.length;p<f;p++){let m=d[p];m.onError&&m.onError(u)}r.manager.itemError(e),r.manager.itemEnd(e)},!1),this.responseType!==void 0&&(h.responseType=this.responseType),this.withCredentials!==void 0&&(h.withCredentials=this.withCredentials),h.overrideMimeType&&h.overrideMimeType(this.mimeType!==void 0?this.mimeType:"text/plain");for(let u in this.requestHeader)h.setRequestHeader(u,this.requestHeader[u]);h.send(null)}return r.manager.itemStart(e),h}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}class Es extends pn{constructor(e){super(e)}load(e,t,n,i){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);let r=this,a=ir.get(e);if(a!==void 0)return r.manager.itemStart(e),setTimeout(function(){t&&t(a),r.manager.itemEnd(e)},0),a;let c=document.createElementNS("http://www.w3.org/1999/xhtml","img");function h(){c.removeEventListener("load",h,!1),c.removeEventListener("error",u,!1),ir.add(e,this),t&&t(this),r.manager.itemEnd(e)}function u(d){c.removeEventListener("load",h,!1),c.removeEventListener("error",u,!1),i&&i(d),r.manager.itemError(e),r.manager.itemEnd(e)}return c.addEventListener("load",h,!1),c.addEventListener("error",u,!1),e.substr(0,5)!=="data:"&&this.crossOrigin!==void 0&&(c.crossOrigin=this.crossOrigin),r.manager.itemStart(e),c.src=e,c}}class Th extends pn{constructor(e){super(e)}load(e,t,n,i){let r=new Rr,a=new Es(this.manager);a.setCrossOrigin(this.crossOrigin),a.setPath(this.path);let c=0;function h(u){a.load(e[u],function(d){r.images[u]=d,c++,c===6&&(r.needsUpdate=!0,t&&t(r))},void 0,i)}for(let u=0;u<e.length;++u)h(u);return r}}class Eh extends pn{constructor(e){super(e)}load(e,t,n,i){let r=this,a=new Yi,c=new Jn(this.manager);return c.setResponseType("arraybuffer"),c.setRequestHeader(this.requestHeader),c.setPath(this.path),c.setWithCredentials(r.withCredentials),c.load(e,function(h){let u=r.parse(h);u&&(u.image!==void 0?a.image=u.image:u.data!==void 0&&(a.image.width=u.width,a.image.height=u.height,a.image.data=u.data),a.wrapS=u.wrapS!==void 0?u.wrapS:1001,a.wrapT=u.wrapT!==void 0?u.wrapT:1001,a.magFilter=u.magFilter!==void 0?u.magFilter:1006,a.minFilter=u.minFilter!==void 0?u.minFilter:1006,a.anisotropy=u.anisotropy!==void 0?u.anisotropy:1,u.encoding!==void 0&&(a.encoding=u.encoding),u.flipY!==void 0&&(a.flipY=u.flipY),u.format!==void 0&&(a.format=u.format),u.type!==void 0&&(a.type=u.type),u.mipmaps!==void 0&&(a.mipmaps=u.mipmaps,a.minFilter=1008),u.mipmapCount===1&&(a.minFilter=1006),u.generateMipmaps!==void 0&&(a.generateMipmaps=u.generateMipmaps),a.needsUpdate=!0,t&&t(a,u))},n,i),a}}class Ah extends pn{constructor(e){super(e)}load(e,t,n,i){let r=new zt,a=new Es(this.manager);return a.setCrossOrigin(this.crossOrigin),a.setPath(this.path),a.load(e,function(c){r.image=c;let h=e.search(/\.jpe?g($|\?)/i)>0||e.search(/^data\:image\/jpeg/)===0;r.format=h?1022:1023,r.needsUpdate=!0,t!==void 0&&t(r)},n,i),r}}class Lh extends In{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){let e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);e.equals(t)||this.curves.push(new xs(t,e))}getPoint(e){let t=e*this.getLength(),n=this.getCurveLengths(),i=0;for(;i<n.length;){if(n[i]>=t){let r=n[i]-t,a=this.curves[i],c=a.getLength(),h=c===0?0:1-r/c;return a.getPointAt(h)}i++}return null}getLength(){let e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;let e=[],t=0;for(let n=0,i=this.curves.length;n<i;n++)t+=this.curves[n].getLength(),e.push(t);return this.cacheLengths=e,e}getSpacedPoints(e=40){let t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return this.autoClose&&t.push(t[0]),t}getPoints(e=12){let t=[],n;for(let i=0,r=this.curves;i<r.length;i++){let a=r[i],c=a&&a.isEllipseCurve?2*e:a&&(a.isLineCurve||a.isLineCurve3)?1:a&&a.isSplineCurve?e*a.points.length:e,h=a.getPoints(c);for(let u=0;u<h.length;u++){let d=h[u];n&&n.equals(d)||(t.push(d),n=d)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t}copy(e){super.copy(e),this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){let i=e.curves[t];this.curves.push(i.clone())}return this.autoClose=e.autoClose,this}toJSON(){let e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let t=0,n=this.curves.length;t<n;t++){let i=this.curves[t];e.curves.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){let i=e.curves[t];this.curves.push(new Jo[i.type]().fromJSON(i))}return this}}class As extends Lh{constructor(e){super(),this.type="Path",this.currentPoint=new me,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let t=1,n=e.length;t<n;t++)this.lineTo(e[t].x,e[t].y);return this}moveTo(e,t){return this.currentPoint.set(e,t),this}lineTo(e,t){let n=new xs(this.currentPoint.clone(),new me(e,t));return this.curves.push(n),this.currentPoint.set(e,t),this}quadraticCurveTo(e,t,n,i){let r=new Aa(this.currentPoint.clone(),new me(e,t),new me(n,i));return this.curves.push(r),this.currentPoint.set(n,i),this}bezierCurveTo(e,t,n,i,r,a){let c=new Ea(this.currentPoint.clone(),new me(e,t),new me(n,i),new me(r,a));return this.curves.push(c),this.currentPoint.set(r,a),this}splineThru(e){let t=[this.currentPoint.clone()].concat(e),n=new La(t);return this.curves.push(n),this.currentPoint.copy(e[e.length-1]),this}arc(e,t,n,i,r,a){let c=this.currentPoint.x,h=this.currentPoint.y;return this.absarc(e+c,t+h,n,i,r,a),this}absarc(e,t,n,i,r,a){return this.absellipse(e,t,n,n,i,r,a),this}ellipse(e,t,n,i,r,a,c,h){let u=this.currentPoint.x,d=this.currentPoint.y;return this.absellipse(e+u,t+d,n,i,r,a,c,h),this}absellipse(e,t,n,i,r,a,c,h){let u=new gs(e,t,n,i,r,a,c,h);if(this.curves.length>0){let p=u.getPoint(0);p.equals(this.currentPoint)||this.lineTo(p.x,p.y)}this.curves.push(u);let d=u.getPoint(1);return this.currentPoint.copy(d),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){let e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class Ni extends As{constructor(e){super(e),this.uuid=nt(),this.type="Shape",this.holes=[]}getPointsHoles(e){let t=[];for(let n=0,i=this.holes.length;n<i;n++)t[n]=this.holes[n].getPoints(e);return t}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){let i=e.holes[t];this.holes.push(i.clone())}return this}toJSON(){let e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let t=0,n=this.holes.length;t<n;t++){let i=this.holes[t];e.holes.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){let i=e.holes[t];this.holes.push(new As().fromJSON(i))}return this}}class Kn extends pt{constructor(e,t=1){super(),this.type="Light",this.color=new De(e),this.intensity=t}dispose(){}copy(e){return super.copy(e),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){let t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),t}}Kn.prototype.isLight=!0;class ul extends Kn{constructor(e,t,n){super(e,n),this.type="HemisphereLight",this.position.copy(pt.DefaultUp),this.updateMatrix(),this.groundColor=new De(t)}copy(e){return Kn.prototype.copy.call(this,e),this.groundColor.copy(e.groundColor),this}}ul.prototype.isHemisphereLight=!0;let Rh=new Xe,Ch=new L,Ph=new L;class dl{constructor(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new me(512,512),this.map=null,this.mapPass=null,this.matrix=new Xe,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new ss,this._frameExtents=new me(1,1),this._viewportCount=1,this._viewports=[new _t(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){let t=this.camera,n=this.matrix;Ch.setFromMatrixPosition(e.matrixWorld),t.position.copy(Ch),Ph.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(Ph),t.updateMatrixWorld(),Rh.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Rh),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(t.projectionMatrix),n.multiply(t.matrixWorldInverse)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){let e={};return this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),this.mapSize.x===512&&this.mapSize.y===512||(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class Dh extends dl{constructor(){super(new sn(50,1,.5,500)),this.focus=1}updateMatrices(e){let t=this.camera,n=2*Et*e.angle*this.focus,i=this.mapSize.width/this.mapSize.height,r=e.distance||t.far;n===t.fov&&i===t.aspect&&r===t.far||(t.fov=n,t.aspect=i,t.far=r,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}Dh.prototype.isSpotLightShadow=!0;class pl extends Kn{constructor(e,t,n=0,i=Math.PI/3,r=0,a=1){super(e,t),this.type="SpotLight",this.position.copy(pt.DefaultUp),this.updateMatrix(),this.target=new pt,this.distance=n,this.angle=i,this.penumbra=r,this.decay=a,this.shadow=new Dh}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}pl.prototype.isSpotLight=!0;let Ih=new Xe,Ls=new L,fl=new L;class Oh extends dl{constructor(){super(new sn(90,1,.5,500)),this._frameExtents=new me(4,2),this._viewportCount=6,this._viewports=[new _t(2,1,1,1),new _t(0,1,1,1),new _t(3,1,1,1),new _t(1,1,1,1),new _t(3,0,1,1),new _t(1,0,1,1)],this._cubeDirections=[new L(1,0,0),new L(-1,0,0),new L(0,0,1),new L(0,0,-1),new L(0,1,0),new L(0,-1,0)],this._cubeUps=[new L(0,1,0),new L(0,1,0),new L(0,1,0),new L(0,1,0),new L(0,0,1),new L(0,0,-1)]}updateMatrices(e,t=0){let n=this.camera,i=this.matrix,r=e.distance||n.far;r!==n.far&&(n.far=r,n.updateProjectionMatrix()),Ls.setFromMatrixPosition(e.matrixWorld),n.position.copy(Ls),fl.copy(n.position),fl.add(this._cubeDirections[t]),n.up.copy(this._cubeUps[t]),n.lookAt(fl),n.updateMatrixWorld(),i.makeTranslation(-Ls.x,-Ls.y,-Ls.z),Ih.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Ih)}}Oh.prototype.isPointLightShadow=!0;class ml extends Kn{constructor(e,t,n=0,i=1){super(e,t),this.type="PointLight",this.distance=n,this.decay=i,this.shadow=new Oh}get power(){return 4*this.intensity*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}ml.prototype.isPointLight=!0;class Fh extends dl{constructor(){super(new as(-5,5,5,-5,.5,500))}}Fh.prototype.isDirectionalLightShadow=!0;class gl extends Kn{constructor(e,t){super(e,t),this.type="DirectionalLight",this.position.copy(pt.DefaultUp),this.updateMatrix(),this.target=new pt,this.shadow=new Fh}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}gl.prototype.isDirectionalLight=!0;class yl extends Kn{constructor(e,t){super(e,t),this.type="AmbientLight"}}yl.prototype.isAmbientLight=!0;class vl extends Kn{constructor(e,t,n=10,i=10){super(e,t),this.type="RectAreaLight",this.width=n,this.height=i}get power(){return this.intensity*this.width*this.height*Math.PI}set power(e){this.intensity=e/(this.width*this.height*Math.PI)}copy(e){return super.copy(e),this.width=e.width,this.height=e.height,this}toJSON(e){let t=super.toJSON(e);return t.object.width=this.width,t.object.height=this.height,t}}vl.prototype.isRectAreaLight=!0;class xl{constructor(){this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new L)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){let n=e.x,i=e.y,r=e.z,a=this.coefficients;return t.copy(a[0]).multiplyScalar(.282095),t.addScaledVector(a[1],.488603*i),t.addScaledVector(a[2],.488603*r),t.addScaledVector(a[3],.488603*n),t.addScaledVector(a[4],n*i*1.092548),t.addScaledVector(a[5],i*r*1.092548),t.addScaledVector(a[6],.315392*(3*r*r-1)),t.addScaledVector(a[7],n*r*1.092548),t.addScaledVector(a[8],.546274*(n*n-i*i)),t}getIrradianceAt(e,t){let n=e.x,i=e.y,r=e.z,a=this.coefficients;return t.copy(a[0]).multiplyScalar(.886227),t.addScaledVector(a[1],1.023328*i),t.addScaledVector(a[2],1.023328*r),t.addScaledVector(a[3],1.023328*n),t.addScaledVector(a[4],.858086*n*i),t.addScaledVector(a[5],.858086*i*r),t.addScaledVector(a[6],.743125*r*r-.247708),t.addScaledVector(a[7],.858086*n*r),t.addScaledVector(a[8],.429043*(n*n-i*i)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(e.coefficients[n],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let n=0;n<9;n++)this.coefficients[n].lerp(e.coefficients[n],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,t=0){let n=this.coefficients;for(let i=0;i<9;i++)n[i].fromArray(e,t+3*i);return this}toArray(e=[],t=0){let n=this.coefficients;for(let i=0;i<9;i++)n[i].toArray(e,t+3*i);return e}static getBasisAt(e,t){let n=e.x,i=e.y,r=e.z;t[0]=.282095,t[1]=.488603*i,t[2]=.488603*r,t[3]=.488603*n,t[4]=1.092548*n*i,t[5]=1.092548*i*r,t[6]=.315392*(3*r*r-1),t[7]=1.092548*n*r,t[8]=.546274*(n*n-i*i)}}xl.prototype.isSphericalHarmonics3=!0;class Rs extends Kn{constructor(e=new xl,t=1){super(void 0,t),this.sh=e}copy(e){return super.copy(e),this.sh.copy(e.sh),this}fromJSON(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this}toJSON(e){let t=super.toJSON(e);return t.object.sh=this.sh.toArray(),t}}Rs.prototype.isLightProbe=!0;class Nh extends pn{constructor(e){super(e),this.textures={}}load(e,t,n,i){let r=this,a=new Jn(r.manager);a.setPath(r.path),a.setRequestHeader(r.requestHeader),a.setWithCredentials(r.withCredentials),a.load(e,function(c){try{t(r.parse(JSON.parse(c)))}catch(h){i?i(h):console.error(h),r.manager.itemError(e)}},n,i)}parse(e){let t=this.textures;function n(r){return t[r]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",r),t[r]}let i=new Jf[e.type];if(e.uuid!==void 0&&(i.uuid=e.uuid),e.name!==void 0&&(i.name=e.name),e.color!==void 0&&i.color!==void 0&&i.color.setHex(e.color),e.roughness!==void 0&&(i.roughness=e.roughness),e.metalness!==void 0&&(i.metalness=e.metalness),e.sheenTint!==void 0&&(i.sheenTint=new De().setHex(e.sheenTint)),e.emissive!==void 0&&i.emissive!==void 0&&i.emissive.setHex(e.emissive),e.specular!==void 0&&i.specular!==void 0&&i.specular.setHex(e.specular),e.specularIntensity!==void 0&&(i.specularIntensity=e.specularIntensity),e.specularTint!==void 0&&i.specularTint!==void 0&&i.specularTint.setHex(e.specularTint),e.shininess!==void 0&&(i.shininess=e.shininess),e.clearcoat!==void 0&&(i.clearcoat=e.clearcoat),e.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=e.clearcoatRoughness),e.transmission!==void 0&&(i.transmission=e.transmission),e.thickness!==void 0&&(i.thickness=e.thickness),e.attenuationDistance!==void 0&&(i.attenuationDistance=e.attenuationDistance),e.attenuationTint!==void 0&&i.attenuationTint!==void 0&&i.attenuationTint.setHex(e.attenuationTint),e.fog!==void 0&&(i.fog=e.fog),e.flatShading!==void 0&&(i.flatShading=e.flatShading),e.blending!==void 0&&(i.blending=e.blending),e.combine!==void 0&&(i.combine=e.combine),e.side!==void 0&&(i.side=e.side),e.shadowSide!==void 0&&(i.shadowSide=e.shadowSide),e.opacity!==void 0&&(i.opacity=e.opacity),e.format!==void 0&&(i.format=e.format),e.transparent!==void 0&&(i.transparent=e.transparent),e.alphaTest!==void 0&&(i.alphaTest=e.alphaTest),e.depthTest!==void 0&&(i.depthTest=e.depthTest),e.depthWrite!==void 0&&(i.depthWrite=e.depthWrite),e.colorWrite!==void 0&&(i.colorWrite=e.colorWrite),e.stencilWrite!==void 0&&(i.stencilWrite=e.stencilWrite),e.stencilWriteMask!==void 0&&(i.stencilWriteMask=e.stencilWriteMask),e.stencilFunc!==void 0&&(i.stencilFunc=e.stencilFunc),e.stencilRef!==void 0&&(i.stencilRef=e.stencilRef),e.stencilFuncMask!==void 0&&(i.stencilFuncMask=e.stencilFuncMask),e.stencilFail!==void 0&&(i.stencilFail=e.stencilFail),e.stencilZFail!==void 0&&(i.stencilZFail=e.stencilZFail),e.stencilZPass!==void 0&&(i.stencilZPass=e.stencilZPass),e.wireframe!==void 0&&(i.wireframe=e.wireframe),e.wireframeLinewidth!==void 0&&(i.wireframeLinewidth=e.wireframeLinewidth),e.wireframeLinecap!==void 0&&(i.wireframeLinecap=e.wireframeLinecap),e.wireframeLinejoin!==void 0&&(i.wireframeLinejoin=e.wireframeLinejoin),e.rotation!==void 0&&(i.rotation=e.rotation),e.linewidth!==1&&(i.linewidth=e.linewidth),e.dashSize!==void 0&&(i.dashSize=e.dashSize),e.gapSize!==void 0&&(i.gapSize=e.gapSize),e.scale!==void 0&&(i.scale=e.scale),e.polygonOffset!==void 0&&(i.polygonOffset=e.polygonOffset),e.polygonOffsetFactor!==void 0&&(i.polygonOffsetFactor=e.polygonOffsetFactor),e.polygonOffsetUnits!==void 0&&(i.polygonOffsetUnits=e.polygonOffsetUnits),e.dithering!==void 0&&(i.dithering=e.dithering),e.alphaToCoverage!==void 0&&(i.alphaToCoverage=e.alphaToCoverage),e.premultipliedAlpha!==void 0&&(i.premultipliedAlpha=e.premultipliedAlpha),e.visible!==void 0&&(i.visible=e.visible),e.toneMapped!==void 0&&(i.toneMapped=e.toneMapped),e.userData!==void 0&&(i.userData=e.userData),e.vertexColors!==void 0&&(typeof e.vertexColors=="number"?i.vertexColors=e.vertexColors>0:i.vertexColors=e.vertexColors),e.uniforms!==void 0)for(let r in e.uniforms){let a=e.uniforms[r];switch(i.uniforms[r]={},a.type){case"t":i.uniforms[r].value=n(a.value);break;case"c":i.uniforms[r].value=new De().setHex(a.value);break;case"v2":i.uniforms[r].value=new me().fromArray(a.value);break;case"v3":i.uniforms[r].value=new L().fromArray(a.value);break;case"v4":i.uniforms[r].value=new _t().fromArray(a.value);break;case"m3":i.uniforms[r].value=new Nt().fromArray(a.value);break;case"m4":i.uniforms[r].value=new Xe().fromArray(a.value);break;default:i.uniforms[r].value=a.value}}if(e.defines!==void 0&&(i.defines=e.defines),e.vertexShader!==void 0&&(i.vertexShader=e.vertexShader),e.fragmentShader!==void 0&&(i.fragmentShader=e.fragmentShader),e.extensions!==void 0)for(let r in e.extensions)i.extensions[r]=e.extensions[r];if(e.shading!==void 0&&(i.flatShading=e.shading===1),e.size!==void 0&&(i.size=e.size),e.sizeAttenuation!==void 0&&(i.sizeAttenuation=e.sizeAttenuation),e.map!==void 0&&(i.map=n(e.map)),e.matcap!==void 0&&(i.matcap=n(e.matcap)),e.alphaMap!==void 0&&(i.alphaMap=n(e.alphaMap)),e.bumpMap!==void 0&&(i.bumpMap=n(e.bumpMap)),e.bumpScale!==void 0&&(i.bumpScale=e.bumpScale),e.normalMap!==void 0&&(i.normalMap=n(e.normalMap)),e.normalMapType!==void 0&&(i.normalMapType=e.normalMapType),e.normalScale!==void 0){let r=e.normalScale;Array.isArray(r)===!1&&(r=[r,r]),i.normalScale=new me().fromArray(r)}return e.displacementMap!==void 0&&(i.displacementMap=n(e.displacementMap)),e.displacementScale!==void 0&&(i.displacementScale=e.displacementScale),e.displacementBias!==void 0&&(i.displacementBias=e.displacementBias),e.roughnessMap!==void 0&&(i.roughnessMap=n(e.roughnessMap)),e.metalnessMap!==void 0&&(i.metalnessMap=n(e.metalnessMap)),e.emissiveMap!==void 0&&(i.emissiveMap=n(e.emissiveMap)),e.emissiveIntensity!==void 0&&(i.emissiveIntensity=e.emissiveIntensity),e.specularMap!==void 0&&(i.specularMap=n(e.specularMap)),e.specularIntensityMap!==void 0&&(i.specularIntensityMap=n(e.specularIntensityMap)),e.specularTintMap!==void 0&&(i.specularTintMap=n(e.specularTintMap)),e.envMap!==void 0&&(i.envMap=n(e.envMap)),e.envMapIntensity!==void 0&&(i.envMapIntensity=e.envMapIntensity),e.reflectivity!==void 0&&(i.reflectivity=e.reflectivity),e.refractionRatio!==void 0&&(i.refractionRatio=e.refractionRatio),e.lightMap!==void 0&&(i.lightMap=n(e.lightMap)),e.lightMapIntensity!==void 0&&(i.lightMapIntensity=e.lightMapIntensity),e.aoMap!==void 0&&(i.aoMap=n(e.aoMap)),e.aoMapIntensity!==void 0&&(i.aoMapIntensity=e.aoMapIntensity),e.gradientMap!==void 0&&(i.gradientMap=n(e.gradientMap)),e.clearcoatMap!==void 0&&(i.clearcoatMap=n(e.clearcoatMap)),e.clearcoatRoughnessMap!==void 0&&(i.clearcoatRoughnessMap=n(e.clearcoatRoughnessMap)),e.clearcoatNormalMap!==void 0&&(i.clearcoatNormalMap=n(e.clearcoatNormalMap)),e.clearcoatNormalScale!==void 0&&(i.clearcoatNormalScale=new me().fromArray(e.clearcoatNormalScale)),e.transmissionMap!==void 0&&(i.transmissionMap=n(e.transmissionMap)),e.thicknessMap!==void 0&&(i.thicknessMap=n(e.thicknessMap)),i}setTextures(e){return this.textures=e,this}}class Fa{static decodeText(e){if(typeof TextDecoder<"u")return new TextDecoder().decode(e);let t="";for(let n=0,i=e.length;n<i;n++)t+=String.fromCharCode(e[n]);try{return decodeURIComponent(escape(t))}catch{return t}}static extractUrlBase(e){let t=e.lastIndexOf("/");return t===-1?"./":e.substr(0,t+1)}}class _l extends st{constructor(){super(),this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(e){return super.copy(e),this.instanceCount=e.instanceCount,this}clone(){return new this.constructor().copy(this)}toJSON(){let e=super.toJSON(this);return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}_l.prototype.isInstancedBufferGeometry=!0;class zh extends pn{constructor(e){super(e)}load(e,t,n,i){let r=this,a=new Jn(r.manager);a.setPath(r.path),a.setRequestHeader(r.requestHeader),a.setWithCredentials(r.withCredentials),a.load(e,function(c){try{t(r.parse(JSON.parse(c)))}catch(h){i?i(h):console.error(h),r.manager.itemError(e)}},n,i)}parse(e){let t={},n={};function i(p,f){if(t[f]!==void 0)return t[f];let m=p.interleavedBuffers[f],g=function(v,w){if(n[w]!==void 0)return n[w];let A=v.arrayBuffers[w],S=new Uint32Array(A).buffer;return n[w]=S,S}(p,m.buffer),y=Sr(m.type,g),x=new Zi(y,m.stride);return x.uuid=m.uuid,t[f]=x,x}let r=e.isInstancedBufferGeometry?new _l:new st,a=e.data.index;if(a!==void 0){let p=Sr(a.type,a.array);r.setIndex(new bt(p,1))}let c=e.data.attributes;for(let p in c){let f=c[p],m;if(f.isInterleavedBufferAttribute){let g=i(e.data,f.data);m=new Ii(g,f.itemSize,f.offset,f.normalized)}else{let g=Sr(f.type,f.array);m=new(f.isInstancedBufferAttribute?Ji:bt)(g,f.itemSize,f.normalized)}f.name!==void 0&&(m.name=f.name),f.usage!==void 0&&m.setUsage(f.usage),f.updateRange!==void 0&&(m.updateRange.offset=f.updateRange.offset,m.updateRange.count=f.updateRange.count),r.setAttribute(p,m)}let h=e.data.morphAttributes;if(h)for(let p in h){let f=h[p],m=[];for(let g=0,y=f.length;g<y;g++){let x=f[g],v;if(x.isInterleavedBufferAttribute){let w=i(e.data,x.data);v=new Ii(w,x.itemSize,x.offset,x.normalized)}else{let w=Sr(x.type,x.array);v=new bt(w,x.itemSize,x.normalized)}x.name!==void 0&&(v.name=x.name),m.push(v)}r.morphAttributes[p]=m}e.data.morphTargetsRelative&&(r.morphTargetsRelative=!0);let u=e.data.groups||e.data.drawcalls||e.data.offsets;if(u!==void 0)for(let p=0,f=u.length;p!==f;++p){let m=u[p];r.addGroup(m.start,m.count,m.materialIndex)}let d=e.data.boundingSphere;if(d!==void 0){let p=new L;d.center!==void 0&&p.fromArray(d.center),r.boundingSphere=new Ti(p,d.radius)}return e.name&&(r.name=e.name),e.userData&&(r.userData=e.userData),r}}let Qf={UVMapping:300,CubeReflectionMapping:301,CubeRefractionMapping:302,EquirectangularReflectionMapping:303,EquirectangularRefractionMapping:304,CubeUVReflectionMapping:306,CubeUVRefractionMapping:307},Bh={RepeatWrapping:1e3,ClampToEdgeWrapping:1001,MirroredRepeatWrapping:1002},Hh={NearestFilter:1003,NearestMipmapNearestFilter:1004,NearestMipmapLinearFilter:1005,LinearFilter:1006,LinearMipmapNearestFilter:1007,LinearMipmapLinearFilter:1008};class Uh extends pn{constructor(e){super(e),typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,t,n,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);let r=this,a=ir.get(e);if(a!==void 0)return r.manager.itemStart(e),setTimeout(function(){t&&t(a),r.manager.itemEnd(e)},0),a;let c={};c.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",c.headers=this.requestHeader,fetch(e,c).then(function(h){return h.blob()}).then(function(h){return createImageBitmap(h,Object.assign(r.options,{colorSpaceConversion:"none"}))}).then(function(h){ir.add(e,h),t&&t(h),r.manager.itemEnd(e)}).catch(function(h){i&&i(h),r.manager.itemError(e),r.manager.itemEnd(e)}),r.manager.itemStart(e)}}Uh.prototype.isImageBitmapLoader=!0;class Gh{constructor(){this.type="ShapePath",this.color=new De,this.subPaths=[],this.currentPath=null}moveTo(e,t){return this.currentPath=new As,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,t),this}lineTo(e,t){return this.currentPath.lineTo(e,t),this}quadraticCurveTo(e,t,n,i){return this.currentPath.quadraticCurveTo(e,t,n,i),this}bezierCurveTo(e,t,n,i,r,a){return this.currentPath.bezierCurveTo(e,t,n,i,r,a),this}splineThru(e){return this.currentPath.splineThru(e),this}toShapes(e,t){function n(w){let A=[];for(let S=0,D=w.length;S<D;S++){let F=w[S],q=new Ni;q.curves=F.curves,A.push(q)}return A}function i(w,A){let S=A.length,D=!1;for(let F=S-1,q=0;q<S;F=q++){let X=A[F],te=A[q],J=te.x-X.x,$=te.y-X.y;if(Math.abs($)>Number.EPSILON){if($<0&&(X=A[q],J=-J,te=A[F],$=-$),w.y<X.y||w.y>te.y)continue;if(w.y===X.y){if(w.x===X.x)return!0}else{let Re=$*(w.x-X.x)-J*(w.y-X.y);if(Re===0)return!0;if(Re<0)continue;D=!D}}else{if(w.y!==X.y)continue;if(te.x<=w.x&&w.x<=X.x||X.x<=w.x&&w.x<=te.x)return!0}}return D}let r=ai.isClockWise,a=this.subPaths;if(a.length===0)return[];if(t===!0)return n(a);let c,h,u,d=[];if(a.length===1)return h=a[0],u=new Ni,u.curves=h.curves,d.push(u),d;let p=!r(a[0].getPoints());p=e?!p:p;let f=[],m=[],g,y,x=[],v=0;m[v]=void 0,x[v]=[];for(let w=0,A=a.length;w<A;w++)h=a[w],g=h.getPoints(),c=r(g),c=e?!c:c,c?(!p&&m[v]&&v++,m[v]={s:new Ni,p:g},m[v].s.curves=h.curves,p&&v++,x[v]=[]):x[v].push({h,p:g[0]});if(!m[0])return n(a);if(m.length>1){let w=!1,A=[];for(let S=0,D=m.length;S<D;S++)f[S]=[];for(let S=0,D=m.length;S<D;S++){let F=x[S];for(let q=0;q<F.length;q++){let X=F[q],te=!0;for(let J=0;J<m.length;J++)i(X.p,m[J].p)&&(S!==J&&A.push({froms:S,tos:J,hole:q}),te?(te=!1,f[J].push(X)):w=!0);te&&f[S].push(X)}}A.length>0&&(w||(x=f))}for(let w=0,A=m.length;w<A;w++){u=m[w].s,d.push(u),y=x[w];for(let S=0,D=y.length;S<D;S++)u.holes.push(y[S].h)}return d}}class bl{constructor(e){this.type="Font",this.data=e}generateShapes(e,t=100){let n=[],i=function(r,a,c){let h=Array.from(r),u=a/c.resolution,d=(c.boundingBox.yMax-c.boundingBox.yMin+c.underlineThickness)*u,p=[],f=0,m=0;for(let g=0;g<h.length;g++){let y=h[g];if(y===`
`)f=0,m-=d;else{let x=$f(y,u,f,m,c);f+=x.offsetX,p.push(x.path)}}return p}(e,t,this.data);for(let r=0,a=i.length;r<a;r++)Array.prototype.push.apply(n,i[r].toShapes());return n}}function $f(s,e,t,n,i){let r=i.glyphs[s]||i.glyphs["?"];if(!r)return void console.error('THREE.Font: character "'+s+'" does not exists in font family '+i.familyName+".");let a=new Gh,c,h,u,d,p,f,m,g;if(r.o){let y=r._cachedOutline||(r._cachedOutline=r.o.split(" "));for(let x=0,v=y.length;x<v;)switch(y[x++]){case"m":c=y[x++]*e+t,h=y[x++]*e+n,a.moveTo(c,h);break;case"l":c=y[x++]*e+t,h=y[x++]*e+n,a.lineTo(c,h);break;case"q":u=y[x++]*e+t,d=y[x++]*e+n,p=y[x++]*e+t,f=y[x++]*e+n,a.quadraticCurveTo(p,f,u,d);break;case"b":u=y[x++]*e+t,d=y[x++]*e+n,p=y[x++]*e+t,f=y[x++]*e+n,m=y[x++]*e+t,g=y[x++]*e+n,a.bezierCurveTo(p,f,m,g,u,d)}}return{offsetX:r.ha*e,path:a}}bl.prototype.isFont=!0;let Na,Ml={getContext:function(){return Na===void 0&&(Na=new(window.AudioContext||window.webkitAudioContext)),Na},setContext:function(s){Na=s}};class kh extends pn{constructor(e){super(e)}load(e,t,n,i){let r=this,a=new Jn(this.manager);a.setResponseType("arraybuffer"),a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(c){try{let h=c.slice(0);Ml.getContext().decodeAudioData(h,function(u){t(u)})}catch(h){i?i(h):console.error(h),r.manager.itemError(e)}},n,i)}}class Vh extends Rs{constructor(e,t,n=1){super(void 0,n);let i=new De().set(e),r=new De().set(t),a=new L(i.r,i.g,i.b),c=new L(r.r,r.g,r.b),h=Math.sqrt(Math.PI),u=h*Math.sqrt(.75);this.sh.coefficients[0].copy(a).add(c).multiplyScalar(h),this.sh.coefficients[1].copy(a).sub(c).multiplyScalar(u)}}Vh.prototype.isHemisphereLightProbe=!0;class Wh extends Rs{constructor(e,t=1){super(void 0,t);let n=new De().set(e);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}}Wh.prototype.isAmbientLightProbe=!0;let qh=new Xe,jh=new Xe;class Xh{constructor(e=!0){this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=Zh(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){let t=Zh();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}function Zh(){return(typeof performance>"u"?Date:performance).now()}let rr=new L,Yh=new tn,em=new L,sr=new L;class wl extends pt{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(this.isPlaying===!0)return void console.warn("THREE.Audio: Audio is already playing.");if(this.hasPlaybackControl===!1)return void console.warn("THREE.Audio: this Audio has no playback control.");this._startedAt=this.context.currentTime+e;let t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl!==!1)return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this;console.warn("THREE.Audio: this Audio has no playback control.")}stop(){if(this.hasPlaybackControl!==!1)return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this;console.warn("THREE.Audio: this Audio has no playback control.")}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(e){return e||(e=[]),this._connected===!0?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){if(this.detune=e,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(this.hasPlaybackControl!==!1)return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this;console.warn("THREE.Audio: this Audio has no playback control.")}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(this.hasPlaybackControl!==!1)return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this;console.warn("THREE.Audio: this Audio has no playback control.")}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}let ar=new L,Jh=new tn,tm=new L,or=new L;class Kh{constructor(e,t=2048){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=t,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let e=0,t=this.getFrequencyData();for(let n=0;n<t.length;n++)e+=t[n];return e/t.length}}class Qh{constructor(e,t,n){let i,r,a;switch(this.binding=e,this.valueSize=n,t){case"quaternion":i=this._slerp,r=this._slerpAdditive,a=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*n),this._workIndex=5;break;case"string":case"bool":i=this._select,r=this._select,a=this._setAdditiveIdentityOther,this.buffer=new Array(5*n);break;default:i=this._lerp,r=this._lerpAdditive,a=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*n)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=r,this._setIdentity=a,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(e,t){let n=this.buffer,i=this.valueSize,r=e*i+i,a=this.cumulativeWeight;if(a===0){for(let c=0;c!==i;++c)n[r+c]=n[c];a=t}else{a+=t;let c=t/a;this._mixBufferRegion(n,r,0,c,i)}this.cumulativeWeight=a}accumulateAdditive(e){let t=this.buffer,n=this.valueSize,i=n*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(t,i,0,e,n),this.cumulativeWeightAdditive+=e}apply(e){let t=this.valueSize,n=this.buffer,i=e*t+t,r=this.cumulativeWeight,a=this.cumulativeWeightAdditive,c=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,r<1){let h=t*this._origIndex;this._mixBufferRegion(n,i,h,1-r,t)}a>0&&this._mixBufferRegionAdditive(n,i,this._addIndex*t,1,t);for(let h=t,u=t+t;h!==u;++h)if(n[h]!==n[h+t]){c.setValue(n,i);break}}saveOriginalState(){let e=this.binding,t=this.buffer,n=this.valueSize,i=n*this._origIndex;e.getValue(t,i);for(let r=n,a=i;r!==a;++r)t[r]=t[i+r%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){let e=3*this.valueSize;this.binding.setValue(this.buffer,e)}_setAdditiveIdentityNumeric(){let e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let n=e;n<t;n++)this.buffer[n]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){let e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[t+n]=this.buffer[e+n]}_select(e,t,n,i,r){if(i>=.5)for(let a=0;a!==r;++a)e[t+a]=e[n+a]}_slerp(e,t,n,i){tn.slerpFlat(e,t,e,t,e,n,i)}_slerpAdditive(e,t,n,i,r){let a=this._workIndex*r;tn.multiplyQuaternionsFlat(e,a,e,t,e,n),tn.slerpFlat(e,t,e,t,e,a,i)}_lerp(e,t,n,i,r){let a=1-i;for(let c=0;c!==r;++c){let h=t+c;e[h]=e[h]*a+e[n+c]*i}}_lerpAdditive(e,t,n,i,r){for(let a=0;a!==r;++a){let c=t+a;e[c]=e[c]+e[n+a]*i}}}let nm="\\[\\]\\.:\\/",im=new RegExp("[\\[\\]\\.:\\/]","g"),Sl="[^\\[\\]\\.:\\/]",rm="[^"+nm.replace("\\.","")+"]",sm=/((?:WC+[\/:])*)/.source.replace("WC",Sl),am=/(WCOD+)?/.source.replace("WCOD",rm),om=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",Sl),lm=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",Sl),cm=new RegExp("^"+sm+am+om+lm+"$"),hm=["material","materials","bones"];class Mt{constructor(e,t,n){this.path=t,this.parsedPath=n||Mt.parseTrackName(t),this.node=Mt.findNode(e,this.parsedPath.nodeName)||e,this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,n){return e&&e.isAnimationObjectGroup?new Mt.Composite(e,t,n):new Mt(e,t,n)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(im,"")}static parseTrackName(e){let t=cm.exec(e);if(!t)throw new Error("PropertyBinding: Cannot parse trackName: "+e);let n={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},i=n.nodeName&&n.nodeName.lastIndexOf(".");if(i!==void 0&&i!==-1){let r=n.nodeName.substring(i+1);hm.indexOf(r)!==-1&&(n.nodeName=n.nodeName.substring(0,i),n.objectName=r)}if(n.propertyName===null||n.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return n}static findNode(e,t){if(!t||t===""||t==="."||t===-1||t===e.name||t===e.uuid)return e;if(e.skeleton){let n=e.skeleton.getBoneByName(t);if(n!==void 0)return n}if(e.children){let n=function(r){for(let a=0;a<r.length;a++){let c=r[a];if(c.name===t||c.uuid===t)return c;let h=n(c.children);if(h)return h}return null},i=n(e.children);if(i)return i}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.targetObject[this.propertyName]}_getValue_array(e,t){let n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)e[t++]=n[i]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,t){let n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=e[t++]}_setValue_array_setNeedsUpdate(e,t){let n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){let n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}bind(){let e=this.node,t=this.parsedPath,n=t.objectName,i=t.propertyName,r=t.propertyIndex;if(e||(e=Mt.findNode(this.rootNode,t.nodeName)||this.rootNode,this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e)return void console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");if(n){let u=t.objectIndex;switch(n){case"materials":if(!e.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!e.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);e=e.material.materials;break;case"bones":if(!e.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);e=e.skeleton.bones;for(let d=0;d<e.length;d++)if(e[d].name===u){u=d;break}break;default:if(e[n]===void 0)return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);e=e[n]}if(u!==void 0){if(e[u]===void 0)return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);e=e[u]}}let a=e[i];if(a===void 0){let u=t.nodeName;return void console.error("THREE.PropertyBinding: Trying to update property for track: "+u+"."+i+" but it wasn't found.",e)}let c=this.Versioning.None;this.targetObject=e,e.needsUpdate!==void 0?c=this.Versioning.NeedsUpdate:e.matrixWorldNeedsUpdate!==void 0&&(c=this.Versioning.MatrixWorldNeedsUpdate);let h=this.BindingType.Direct;if(r!==void 0){if(i==="morphTargetInfluences"){if(!e.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!e.geometry.isBufferGeometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);if(!e.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);e.morphTargetDictionary[r]!==void 0&&(r=e.morphTargetDictionary[r])}h=this.BindingType.ArrayElement,this.resolvedProperty=a,this.propertyIndex=r}else a.fromArray!==void 0&&a.toArray!==void 0?(h=this.BindingType.HasFromToArray,this.resolvedProperty=a):Array.isArray(a)?(h=this.BindingType.EntireArray,this.resolvedProperty=a):this.propertyName=i;this.getValue=this.GetterByBindingType[h],this.setValue=this.SetterByBindingTypeAndVersioning[h][c]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}Mt.Composite=class{constructor(s,e,t){let n=t||Mt.parseTrackName(e);this._targetGroup=s,this._bindings=s.subscribe_(e,n)}getValue(s,e){this.bind();let t=this._targetGroup.nCachedObjects_,n=this._bindings[t];n!==void 0&&n.getValue(s,e)}setValue(s,e){let t=this._bindings;for(let n=this._targetGroup.nCachedObjects_,i=t.length;n!==i;++n)t[n].setValue(s,e)}bind(){let s=this._bindings;for(let e=this._targetGroup.nCachedObjects_,t=s.length;e!==t;++e)s[e].bind()}unbind(){let s=this._bindings;for(let e=this._targetGroup.nCachedObjects_,t=s.length;e!==t;++e)s[e].unbind()}},Mt.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Mt.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},Mt.prototype.GetterByBindingType=[Mt.prototype._getValue_direct,Mt.prototype._getValue_array,Mt.prototype._getValue_arrayElement,Mt.prototype._getValue_toArray],Mt.prototype.SetterByBindingTypeAndVersioning=[[Mt.prototype._setValue_direct,Mt.prototype._setValue_direct_setNeedsUpdate,Mt.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[Mt.prototype._setValue_array,Mt.prototype._setValue_array_setNeedsUpdate,Mt.prototype._setValue_array_setMatrixWorldNeedsUpdate],[Mt.prototype._setValue_arrayElement,Mt.prototype._setValue_arrayElement_setNeedsUpdate,Mt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[Mt.prototype._setValue_fromArray,Mt.prototype._setValue_fromArray_setNeedsUpdate,Mt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class $h{constructor(){this.uuid=nt(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;let e={};this._indicesByUUID=e;for(let n=0,i=arguments.length;n!==i;++n)e[arguments[n].uuid]=n;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};let t=this;this.stats={objects:{get total(){return t._objects.length},get inUse(){return this.total-t.nCachedObjects_}},get bindingsPerObject(){return t._bindings.length}}}add(){let e=this._objects,t=this._indicesByUUID,n=this._paths,i=this._parsedPaths,r=this._bindings,a=r.length,c,h=e.length,u=this.nCachedObjects_;for(let d=0,p=arguments.length;d!==p;++d){let f=arguments[d],m=f.uuid,g=t[m];if(g===void 0){g=h++,t[m]=g,e.push(f);for(let y=0,x=a;y!==x;++y)r[y].push(new Mt(f,n[y],i[y]))}else if(g<u){c=e[g];let y=--u,x=e[y];t[x.uuid]=g,e[g]=x,t[m]=y,e[y]=f;for(let v=0,w=a;v!==w;++v){let A=r[v],S=A[y],D=A[g];A[g]=S,D===void 0&&(D=new Mt(f,n[v],i[v])),A[y]=D}}else e[g]!==c&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=u}remove(){let e=this._objects,t=this._indicesByUUID,n=this._bindings,i=n.length,r=this.nCachedObjects_;for(let a=0,c=arguments.length;a!==c;++a){let h=arguments[a],u=h.uuid,d=t[u];if(d!==void 0&&d>=r){let p=r++,f=e[p];t[f.uuid]=d,e[d]=f,t[u]=p,e[p]=h;for(let m=0,g=i;m!==g;++m){let y=n[m],x=y[p],v=y[d];y[d]=x,y[p]=v}}}this.nCachedObjects_=r}uncache(){let e=this._objects,t=this._indicesByUUID,n=this._bindings,i=n.length,r=this.nCachedObjects_,a=e.length;for(let c=0,h=arguments.length;c!==h;++c){let u=arguments[c].uuid,d=t[u];if(d!==void 0)if(delete t[u],d<r){let p=--r,f=e[p],m=--a,g=e[m];t[f.uuid]=d,e[d]=f,t[g.uuid]=p,e[p]=g,e.pop();for(let y=0,x=i;y!==x;++y){let v=n[y],w=v[p],A=v[m];v[d]=w,v[p]=A,v.pop()}}else{let p=--a,f=e[p];p>0&&(t[f.uuid]=d),e[d]=f,e.pop();for(let m=0,g=i;m!==g;++m){let y=n[m];y[d]=y[p],y.pop()}}}this.nCachedObjects_=r}subscribe_(e,t){let n=this._bindingsIndicesByPath,i=n[e],r=this._bindings;if(i!==void 0)return r[i];let a=this._paths,c=this._parsedPaths,h=this._objects,u=h.length,d=this.nCachedObjects_,p=new Array(u);i=r.length,n[e]=i,a.push(e),c.push(t),r.push(p);for(let f=d,m=h.length;f!==m;++f){let g=h[f];p[f]=new Mt(g,e,t)}return p}unsubscribe_(e){let t=this._bindingsIndicesByPath,n=t[e];if(n!==void 0){let i=this._paths,r=this._parsedPaths,a=this._bindings,c=a.length-1,h=a[c];t[e[c]]=n,a[n]=h,a.pop(),r[n]=r[c],r.pop(),i[n]=i[c],i.pop()}}}$h.prototype.isAnimationObjectGroup=!0;class um{constructor(e,t,n=null,i=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=n,this.blendMode=i;let r=t.tracks,a=r.length,c=new Array(a),h={endingStart:2400,endingEnd:2400};for(let u=0;u!==a;++u){let d=r[u].createInterpolant(null);c[u]=d,d.settings=h}this._interpolantSettings=h,this._interpolants=c,this._propertyBindings=new Array(a),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=2201,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,n){if(e.fadeOut(t),this.fadeIn(t),n){let i=this._clip.duration,r=e._clip.duration,a=r/i,c=i/r;e.warp(1,a,t),this.warp(c,1,t)}return this}crossFadeTo(e,t,n){return e.crossFadeFrom(this,t,n)}stopFading(){let e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,n){let i=this._mixer,r=i.time,a=this.timeScale,c=this._timeScaleInterpolant;c===null&&(c=i._lendControlInterpolant(),this._timeScaleInterpolant=c);let h=c.parameterPositions,u=c.sampleValues;return h[0]=r,h[1]=r+n,u[0]=e/a,u[1]=t/a,this}stopWarping(){let e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,n,i){if(!this.enabled)return void this._updateWeight(e);let r=this._startTime;if(r!==null){let h=(e-r)*n;if(h<0||n===0)return;this._startTime=null,t=n*h}t*=this._updateTimeScale(e);let a=this._updateTime(t),c=this._updateWeight(e);if(c>0){let h=this._interpolants,u=this._propertyBindings;switch(this.blendMode){case 2501:for(let d=0,p=h.length;d!==p;++d)h[d].evaluate(a),u[d].accumulateAdditive(c);break;case 2500:default:for(let d=0,p=h.length;d!==p;++d)h[d].evaluate(a),u[d].accumulate(i,c)}}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;let n=this._weightInterpolant;if(n!==null){let i=n.evaluate(e)[0];t*=i,e>n.parameterPositions[1]&&(this.stopFading(),i===0&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;let n=this._timeScaleInterpolant;n!==null&&(t*=n.evaluate(e)[0],e>n.parameterPositions[1]&&(this.stopWarping(),t===0?this.paused=!0:this.timeScale=t))}return this._effectiveTimeScale=t,t}_updateTime(e){let t=this._clip.duration,n=this.loop,i=this.time+e,r=this._loopCount,a=n===2202;if(e===0)return r===-1?i:a&&(1&r)==1?t-i:i;if(n===2200){r===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(i>=t)i=t;else{if(!(i<0)){this.time=i;break e}i=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(r===-1&&(e>=0?(r=0,this._setEndings(!0,this.repetitions===0,a)):this._setEndings(this.repetitions===0,!0,a)),i>=t||i<0){let c=Math.floor(i/t);i-=t*c,r+=Math.abs(c);let h=this.repetitions-r;if(h<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,i=e>0?t:0,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(h===1){let u=e<0;this._setEndings(u,!u,a)}else this._setEndings(!1,!1,a);this._loopCount=r,this.time=i,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:c})}}else this.time=i;if(a&&(1&r)==1)return t-i}return i}_setEndings(e,t,n){let i=this._interpolantSettings;n?(i.endingStart=2401,i.endingEnd=2401):(i.endingStart=e?this.zeroSlopeAtStart?2401:2400:2402,i.endingEnd=t?this.zeroSlopeAtEnd?2401:2400:2402)}_scheduleFading(e,t,n){let i=this._mixer,r=i.time,a=this._weightInterpolant;a===null&&(a=i._lendControlInterpolant(),this._weightInterpolant=a);let c=a.parameterPositions,h=a.sampleValues;return c[0]=r,h[0]=t,c[1]=r+e,h[1]=n,this}}class eu extends Me{constructor(e){super(),this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(e,t){let n=e._localRoot||this._root,i=e._clip.tracks,r=i.length,a=e._propertyBindings,c=e._interpolants,h=n.uuid,u=this._bindingsByRootAndName,d=u[h];d===void 0&&(d={},u[h]=d);for(let p=0;p!==r;++p){let f=i[p],m=f.name,g=d[m];if(g!==void 0)a[p]=g;else{if(g=a[p],g!==void 0){g._cacheIndex===null&&(++g.referenceCount,this._addInactiveBinding(g,h,m));continue}let y=t&&t._propertyBindings[p].binding.parsedPath;g=new Qh(Mt.create(n,m,y),f.ValueTypeName,f.getValueSize()),++g.referenceCount,this._addInactiveBinding(g,h,m),a[p]=g}c[p].resultBuffer=g.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(e._cacheIndex===null){let n=(e._localRoot||this._root).uuid,i=e._clip.uuid,r=this._actionsByClip[i];this._bindAction(e,r&&r.knownActions[0]),this._addInactiveAction(e,i,n)}let t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){let r=t[n];r.useCount++==0&&(this._lendBinding(r),r.saveOriginalState())}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){let t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){let r=t[n];--r.useCount==0&&(r.restoreOriginalState(),this._takeBackBinding(r))}this._takeBackAction(e)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;let e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}_isActiveAction(e){let t=e._cacheIndex;return t!==null&&t<this._nActiveActions}_addInactiveAction(e,t,n){let i=this._actions,r=this._actionsByClip,a=r[t];if(a===void 0)a={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,r[t]=a;else{let c=a.knownActions;e._byClipCacheIndex=c.length,c.push(e)}e._cacheIndex=i.length,i.push(e),a.actionByRoot[n]=e}_removeInactiveAction(e){let t=this._actions,n=t[t.length-1],i=e._cacheIndex;n._cacheIndex=i,t[i]=n,t.pop(),e._cacheIndex=null;let r=e._clip.uuid,a=this._actionsByClip,c=a[r],h=c.knownActions,u=h[h.length-1],d=e._byClipCacheIndex;u._byClipCacheIndex=d,h[d]=u,h.pop(),e._byClipCacheIndex=null,delete c.actionByRoot[(e._localRoot||this._root).uuid],h.length===0&&delete a[r],this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){let t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){let r=t[n];--r.referenceCount==0&&this._removeInactiveBinding(r)}}_lendAction(e){let t=this._actions,n=e._cacheIndex,i=this._nActiveActions++,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=n,t[n]=r}_takeBackAction(e){let t=this._actions,n=e._cacheIndex,i=--this._nActiveActions,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=n,t[n]=r}_addInactiveBinding(e,t,n){let i=this._bindingsByRootAndName,r=this._bindings,a=i[t];a===void 0&&(a={},i[t]=a),a[n]=e,e._cacheIndex=r.length,r.push(e)}_removeInactiveBinding(e){let t=this._bindings,n=e.binding,i=n.rootNode.uuid,r=n.path,a=this._bindingsByRootAndName,c=a[i],h=t[t.length-1],u=e._cacheIndex;h._cacheIndex=u,t[u]=h,t.pop(),delete c[r],Object.keys(c).length===0&&delete a[i]}_lendBinding(e){let t=this._bindings,n=e._cacheIndex,i=this._nActiveBindings++,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=n,t[n]=r}_takeBackBinding(e){let t=this._bindings,n=e._cacheIndex,i=--this._nActiveBindings,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=n,t[n]=r}_lendControlInterpolant(){let e=this._controlInterpolants,t=this._nActiveControlInterpolants++,n=e[t];return n===void 0&&(n=new ll(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),n.__cacheIndex=t,e[t]=n),n}_takeBackControlInterpolant(e){let t=this._controlInterpolants,n=e.__cacheIndex,i=--this._nActiveControlInterpolants,r=t[i];e.__cacheIndex=i,t[i]=e,r.__cacheIndex=n,t[n]=r}clipAction(e,t,n){let i=t||this._root,r=i.uuid,a=typeof e=="string"?Ts.findByName(i,e):e,c=a!==null?a.uuid:e,h=this._actionsByClip[c],u=null;if(n===void 0&&(n=a!==null?a.blendMode:2500),h!==void 0){let p=h.actionByRoot[r];if(p!==void 0&&p.blendMode===n)return p;u=h.knownActions[0],a===null&&(a=u._clip)}if(a===null)return null;let d=new um(this,a,t,n);return this._bindAction(d,u),this._addInactiveAction(d,c,r),d}existingAction(e,t){let n=t||this._root,i=n.uuid,r=typeof e=="string"?Ts.findByName(n,e):e,a=r?r.uuid:e,c=this._actionsByClip[a];return c!==void 0&&c.actionByRoot[i]||null}stopAllAction(){let e=this._actions;for(let t=this._nActiveActions-1;t>=0;--t)e[t].stop();return this}update(e){e*=this.timeScale;let t=this._actions,n=this._nActiveActions,i=this.time+=e,r=Math.sign(e),a=this._accuIndex^=1;for(let u=0;u!==n;++u)t[u]._update(i,e,r,a);let c=this._bindings,h=this._nActiveBindings;for(let u=0;u!==h;++u)c[u].apply(a);return this}setTime(e){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(e)}getRoot(){return this._root}uncacheClip(e){let t=this._actions,n=e.uuid,i=this._actionsByClip,r=i[n];if(r!==void 0){let a=r.knownActions;for(let c=0,h=a.length;c!==h;++c){let u=a[c];this._deactivateAction(u);let d=u._cacheIndex,p=t[t.length-1];u._cacheIndex=null,u._byClipCacheIndex=null,p._cacheIndex=d,t[d]=p,t.pop(),this._removeInactiveBindingsForAction(u)}delete i[n]}}uncacheRoot(e){let t=e.uuid,n=this._actionsByClip;for(let r in n){let a=n[r].actionByRoot[t];a!==void 0&&(this._deactivateAction(a),this._removeInactiveAction(a))}let i=this._bindingsByRootAndName[t];if(i!==void 0)for(let r in i){let a=i[r];a.restoreOriginalState(),this._removeInactiveBinding(a)}}uncacheAction(e,t){let n=this.existingAction(e,t);n!==null&&(this._deactivateAction(n),this._removeInactiveAction(n))}}eu.prototype._controlInterpolantsResultBuffer=new Float32Array(1);class za{constructor(e){typeof e=="string"&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),e=arguments[1]),this.value=e}clone(){return new za(this.value.clone===void 0?this.value:this.value.clone())}}class tu extends Zi{constructor(e,t,n=1){super(e,t),this.meshPerAttribute=n}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}clone(e){let t=super.clone(e);return t.meshPerAttribute=this.meshPerAttribute,t}toJSON(e){let t=super.toJSON(e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}}tu.prototype.isInstancedInterleavedBuffer=!0;class nu{constructor(e,t,n,i,r){this.buffer=e,this.type=t,this.itemSize=n,this.elementSize=i,this.count=r,this.version=0}set needsUpdate(e){e===!0&&this.version++}setBuffer(e){return this.buffer=e,this}setType(e,t){return this.type=e,this.elementSize=t,this}setItemSize(e){return this.itemSize=e,this}setCount(e){return this.count=e,this}}nu.prototype.isGLBufferAttribute=!0;function iu(s,e){return s.distance-e.distance}function Tl(s,e,t,n){if(s.layers.test(e.layers)&&s.raycast(e,t),n===!0){let i=s.children;for(let r=0,a=i.length;r<a;r++)Tl(i[r],e,t,!0)}}let ru=new me;class Kr{constructor(e=new me(1/0,1/0),t=new me(-1/0,-1/0)){this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){let n=ru.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y)}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return ru.copy(e).clamp(this.min,this.max).sub(e).length()}intersect(e){return this.min.max(e.min),this.max.min(e.max),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}Kr.prototype.isBox2=!0;let su=new L,Ba=new L;class au{constructor(e=new L,t=new L){this.start=e,this.end=t}set(e,t){return this.start.copy(e),this.end.copy(t),this}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,t){return this.delta(t).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,t){su.subVectors(e,this.start),Ba.subVectors(this.end,this.start);let n=Ba.dot(Ba),i=Ba.dot(su)/n;return t&&(i=Ke(i,0,1)),i}closestPointToPoint(e,t,n){let i=this.closestPointToPointParameter(e,t);return this.delta(n).multiplyScalar(i).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}class ou extends pt{constructor(e){super(),this.material=e,this.render=function(){},this.hasPositions=!1,this.hasNormals=!1,this.hasColors=!1,this.hasUvs=!1,this.positionArray=null,this.normalArray=null,this.colorArray=null,this.uvArray=null,this.count=0}}ou.prototype.isImmediateRenderObject=!0;let lu=new L,zi=new L,Ha=new Xe,El=new Xe;class cu extends wn{constructor(e){let t=hu(e),n=new st,i=[],r=[],a=new De(0,0,1),c=new De(0,1,0);for(let h=0;h<t.length;h++){let u=t[h];u.parent&&u.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),r.push(a.r,a.g,a.b),r.push(c.r,c.g,c.b))}n.setAttribute("position",new Ue(i,3)),n.setAttribute("color",new Ue(r,3)),super(n,new an({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0})),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){let t=this.bones,n=this.geometry,i=n.getAttribute("position");El.copy(this.root.matrixWorld).invert();for(let r=0,a=0;r<t.length;r++){let c=t[r];c.parent&&c.parent.isBone&&(Ha.multiplyMatrices(El,c.matrixWorld),zi.setFromMatrixPosition(Ha),i.setXYZ(a,zi.x,zi.y,zi.z),Ha.multiplyMatrices(El,c.parent.matrixWorld),zi.setFromMatrixPosition(Ha),i.setXYZ(a+1,zi.x,zi.y,zi.z),a+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}}function hu(s){let e=[];s&&s.isBone&&e.push(s);for(let t=0;t<s.children.length;t++)e.push.apply(e,hu(s.children[t]));return e}let dm=new L,uu=new De,du=new De;class pu extends wn{constructor(e=10,t=10,n=4473924,i=8947848){n=new De(n),i=new De(i);let r=t/2,a=e/t,c=e/2,h=[],u=[];for(let p=0,f=0,m=-c;p<=t;p++,m+=a){h.push(-c,0,m,c,0,m),h.push(m,0,-c,m,0,c);let g=p===r?n:i;g.toArray(u,f),f+=3,g.toArray(u,f),f+=3,g.toArray(u,f),f+=3,g.toArray(u,f),f+=3}let d=new st;d.setAttribute("position",new Ue(h,3)),d.setAttribute("color",new Ue(u,3)),super(d,new an({vertexColors:!0,toneMapped:!1})),this.type="GridHelper"}}let fu=new L,Ua=new L,mu=new L,Ga=new L,jt=new rs;function Kt(s,e,t,n,i,r,a){Ga.set(i,r,a).unproject(n);let c=e[s];if(c!==void 0){let h=t.getAttribute("position");for(let u=0,d=c.length;u<d;u++)h.setXYZ(c[u],Ga.x,Ga.y,Ga.z)}}let ka=new Cn;class gu extends wn{constructor(e,t=16776960){let n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new Float32Array(24),r=new st;r.setIndex(new bt(n,1)),r.setAttribute("position",new bt(i,3)),super(r,new an({color:t,toneMapped:!1})),this.object=e,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(e){if(e!==void 0&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),this.object!==void 0&&ka.setFromObject(this.object),ka.isEmpty())return;let t=ka.min,n=ka.max,i=this.geometry.attributes.position,r=i.array;r[0]=n.x,r[1]=n.y,r[2]=n.z,r[3]=t.x,r[4]=n.y,r[5]=n.z,r[6]=t.x,r[7]=t.y,r[8]=n.z,r[9]=n.x,r[10]=t.y,r[11]=n.z,r[12]=n.x,r[13]=n.y,r[14]=t.z,r[15]=t.x,r[16]=n.y,r[17]=t.z,r[18]=t.x,r[19]=t.y,r[20]=t.z,r[21]=n.x,r[22]=t.y,r[23]=t.z,i.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(e){return this.object=e,this.update(),this}copy(e){return wn.prototype.copy.call(this,e),this.object=e.object,this}}let yu=new L,Va,Al;class vu extends wn{constructor(e=1){let t=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],n=new st;n.setAttribute("position",new Ue(t,3)),n.setAttribute("color",new Ue([1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],3)),super(n,new an({vertexColors:!0,toneMapped:!1})),this.type="AxesHelper"}setColors(e,t,n){let i=new De,r=this.geometry.attributes.color.array;return i.set(e),i.toArray(r,0),i.toArray(r,3),i.set(t),i.toArray(r,6),i.toArray(r,9),i.set(n),i.toArray(r,12),i.toArray(r,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}let xu=new Float32Array(1),pm=new Int32Array(xu.buffer);In.create=function(s,e){return console.log("THREE.Curve.create() has been deprecated"),s.prototype=Object.create(In.prototype),s.prototype.constructor=s,s.prototype.getPoint=e,s},As.prototype.fromPoints=function(s){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(s)},pu.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")},cu.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")},pn.prototype.extractUrlBase=function(s){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),Fa.extractUrlBase(s)},pn.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}},Kr.prototype.center=function(s){return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),this.getCenter(s)},Kr.prototype.empty=function(){return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),this.isEmpty()},Kr.prototype.isIntersectionBox=function(s){return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(s)},Kr.prototype.size=function(s){return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),this.getSize(s)},Cn.prototype.center=function(s){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(s)},Cn.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()},Cn.prototype.isIntersectionBox=function(s){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(s)},Cn.prototype.isIntersectionSphere=function(s){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(s)},Cn.prototype.size=function(s){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(s)},Ti.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()},ss.prototype.setFromMatrix=function(s){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(s)},au.prototype.center=function(s){return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),this.getCenter(s)},Nt.prototype.flattenToArrayOffset=function(s,e){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(s,e)},Nt.prototype.multiplyVector3=function(s){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),s.applyMatrix3(this)},Nt.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},Nt.prototype.applyToBufferAttribute=function(s){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),s.applyMatrix3(this)},Nt.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")},Nt.prototype.getInverse=function(s){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(s).invert()},Xe.prototype.extractPosition=function(s){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(s)},Xe.prototype.flattenToArrayOffset=function(s,e){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(s,e)},Xe.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),new L().setFromMatrixColumn(this,3)},Xe.prototype.setRotationFromQuaternion=function(s){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(s)},Xe.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},Xe.prototype.multiplyVector3=function(s){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),s.applyMatrix4(this)},Xe.prototype.multiplyVector4=function(s){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),s.applyMatrix4(this)},Xe.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},Xe.prototype.rotateAxis=function(s){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),s.transformDirection(this)},Xe.prototype.crossVector=function(s){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),s.applyMatrix4(this)},Xe.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")},Xe.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},Xe.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},Xe.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},Xe.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},Xe.prototype.applyToBufferAttribute=function(s){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),s.applyMatrix4(this)},Xe.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},Xe.prototype.makeFrustum=function(s,e,t,n,i,r){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(s,e,n,t,i,r)},Xe.prototype.getInverse=function(s){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(s).invert()},ni.prototype.isIntersectionLine=function(s){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(s)},tn.prototype.multiplyVector3=function(s){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),s.applyQuaternion(this)},tn.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()},Ai.prototype.isIntersectionBox=function(s){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(s)},Ai.prototype.isIntersectionPlane=function(s){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(s)},Ai.prototype.isIntersectionSphere=function(s){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(s)},Yt.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()},Yt.prototype.barycoordFromPoint=function(s,e){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(s,e)},Yt.prototype.midpoint=function(s){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(s)},Yt.prototypenormal=function(s){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(s)},Yt.prototype.plane=function(s){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(s)},Yt.barycoordFromPoint=function(s,e,t,n,i){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),Yt.getBarycoord(s,e,t,n,i)},Yt.normal=function(s,e,t,n){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),Yt.getNormal(s,e,t,n)},Ni.prototype.extractAllPoints=function(s){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(s)},Ni.prototype.extrude=function(s){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new Xn(this,s)},Ni.prototype.makeGeometry=function(s){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new $i(this,s)},me.prototype.fromAttribute=function(s,e,t){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(s,e,t)},me.prototype.distanceToManhattan=function(s){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(s)},me.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},L.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},L.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},L.prototype.getPositionFromMatrix=function(s){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(s)},L.prototype.getScaleFromMatrix=function(s){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(s)},L.prototype.getColumnFromMatrix=function(s,e){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(e,s)},L.prototype.applyProjection=function(s){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(s)},L.prototype.fromAttribute=function(s,e,t){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(s,e,t)},L.prototype.distanceToManhattan=function(s){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(s)},L.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},_t.prototype.fromAttribute=function(s,e,t){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(s,e,t)},_t.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},pt.prototype.getChildByName=function(s){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(s)},pt.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},pt.prototype.translate=function(s,e){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(e,s)},pt.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")},pt.prototype.applyMatrix=function(s){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(s)},Object.defineProperties(pt.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(s){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=s}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}}),en.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")},Object.defineProperties(en.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),0},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}}),ma.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")},sn.prototype.setLens=function(s,e){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),e!==void 0&&(this.filmGauge=e),this.setFocalLength(s)},Object.defineProperties(Kn.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(s){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=s}},shadowCameraLeft:{set:function(s){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=s}},shadowCameraRight:{set:function(s){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=s}},shadowCameraTop:{set:function(s){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=s}},shadowCameraBottom:{set:function(s){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=s}},shadowCameraNear:{set:function(s){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=s}},shadowCameraFar:{set:function(s){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=s}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(s){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=s}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(s){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=s}},shadowMapHeight:{set:function(s){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=s}}}),Object.defineProperties(bt.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===35048},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(35048)}}}),bt.prototype.setDynamic=function(s){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(s===!0?35048:35044),this},bt.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},bt.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")},st.prototype.addIndex=function(s){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(s)},st.prototype.addAttribute=function(s,e){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),e&&e.isBufferAttribute||e&&e.isInterleavedBufferAttribute?s==="index"?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(e),this):this.setAttribute(s,e):(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(s,new bt(arguments[1],arguments[2])))},st.prototype.addDrawCall=function(s,e,t){t!==void 0&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(s,e)},st.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()},st.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")},st.prototype.removeAttribute=function(s){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(s)},st.prototype.applyMatrix=function(s){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(s)},Object.defineProperties(st.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}}),Zi.prototype.setDynamic=function(s){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(s===!0?35048:35044),this},Zi.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")},Xn.prototype.getArrays=function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")},Xn.prototype.addShapeList=function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")},Xn.prototype.addShape=function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")},la.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")},za.prototype.onUpdate=function(){return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),this},Object.defineProperties(nn.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new De}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(s){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=s===1}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(s){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=s}},vertexTangents:{get:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")},set:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")}}}),Object.defineProperties(xi.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(s){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=s}}}),It.prototype.clearTarget=function(s,e,t,n){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(s),this.clear(e,t,n)},It.prototype.animate=function(s){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(s)},It.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()},It.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()},It.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision},It.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()},It.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")},It.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")},It.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")},It.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")},It.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")},It.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")},It.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures},It.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")},It.prototype.enableScissorTest=function(s){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(s)},It.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},It.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},It.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},It.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},It.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")},It.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")},It.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")},It.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")},It.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")},It.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()},Object.defineProperties(It.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(s){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=s}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(s){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=s}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(s){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=s===!0?3001:3e3}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}}),Object.defineProperties(Uc.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}}),Object.defineProperties($t.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(s){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=s}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(s){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=s}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(s){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=s}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(s){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=s}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(s){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=s}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(s){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=s}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(s){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=s}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(s){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=s}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(s){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=s}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(s){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=s}}}),wl.prototype.load=function(s){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");let e=this;return new kh().load(s,function(t){e.setBuffer(t)}),this},Kh.prototype.getData=function(){return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),this.getFrequencyData()},ea.prototype.updateCubeMap=function(s,e){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(s,e)},ea.prototype.clear=function(s,e,t,n){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(s,e,t,n)},ui.crossOrigin=void 0,ui.loadTexture=function(s,e,t,n){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");let i=new Ah;i.setCrossOrigin(this.crossOrigin);let r=i.load(s,t,void 0,n);return e&&(r.mapping=e),r},ui.loadTextureCube=function(s,e,t,n){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");let i=new Th;i.setCrossOrigin(this.crossOrigin);let r=i.load(s,t,void 0,n);return e&&(r.mapping=e),r},ui.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")},ui.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};let fm={createMultiMaterialObject:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},detach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},attach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")}};typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:_}})),typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=_),l.ACESFilmicToneMapping=4,l.AddEquation=100,l.AddOperation=2,l.AdditiveAnimationBlendMode=2501,l.AdditiveBlending=2,l.AlphaFormat=1021,l.AlwaysDepth=1,l.AlwaysStencilFunc=519,l.AmbientLight=yl,l.AmbientLightProbe=Wh,l.AnimationClip=Ts,l.AnimationLoader=class extends pn{constructor(s){super(s)}load(s,e,t,n){let i=this,r=new Jn(this.manager);r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials),r.load(s,function(a){try{e(i.parse(JSON.parse(a)))}catch(c){n?n(c):console.error(c),i.manager.itemError(s)}},t,n)}parse(s){let e=[];for(let t=0;t<s.length;t++){let n=Ts.parse(s[t]);e.push(n)}return e}},l.AnimationMixer=eu,l.AnimationObjectGroup=$h,l.AnimationUtils=Ut,l.ArcCurve=ko,l.ArrayCamera=Do,l.ArrowHelper=class extends pt{constructor(s=new L(0,0,1),e=new L(0,0,0),t=1,n=16776960,i=.2*t,r=.2*i){super(),this.type="ArrowHelper",Va===void 0&&(Va=new st,Va.setAttribute("position",new Ue([0,0,0,0,1,0],3)),Al=new Oi(0,.5,1,5,1),Al.translate(0,-.5,0)),this.position.copy(e),this.line=new _i(Va,new an({color:n,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new en(Al,new yi({color:n,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(s),this.setLength(t,i,r)}setDirection(s){if(s.y>.99999)this.quaternion.set(0,0,0,1);else if(s.y<-.99999)this.quaternion.set(1,0,0,0);else{yu.set(s.z,0,-s.x).normalize();let e=Math.acos(s.y);this.quaternion.setFromAxisAngle(yu,e)}}setLength(s,e=.2*s,t=.2*e){this.line.scale.set(1,Math.max(1e-4,s-e),1),this.line.updateMatrix(),this.cone.scale.set(t,e,t),this.cone.position.y=s,this.cone.updateMatrix()}setColor(s){this.line.material.color.set(s),this.cone.material.color.set(s)}copy(s){return super.copy(s,!1),this.line.copy(s.line),this.cone.copy(s.cone),this}},l.Audio=wl,l.AudioAnalyser=Kh,l.AudioContext=Ml,l.AudioListener=class extends pt{constructor(){super(),this.type="AudioListener",this.context=Ml.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new Xh}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(s){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=s,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(s){return this.gain.gain.setTargetAtTime(s,this.context.currentTime,.01),this}updateMatrixWorld(s){super.updateMatrixWorld(s);let e=this.context.listener,t=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(rr,Yh,em),sr.set(0,0,-1).applyQuaternion(Yh),e.positionX){let n=this.context.currentTime+this.timeDelta;e.positionX.linearRampToValueAtTime(rr.x,n),e.positionY.linearRampToValueAtTime(rr.y,n),e.positionZ.linearRampToValueAtTime(rr.z,n),e.forwardX.linearRampToValueAtTime(sr.x,n),e.forwardY.linearRampToValueAtTime(sr.y,n),e.forwardZ.linearRampToValueAtTime(sr.z,n),e.upX.linearRampToValueAtTime(t.x,n),e.upY.linearRampToValueAtTime(t.y,n),e.upZ.linearRampToValueAtTime(t.z,n)}else e.setPosition(rr.x,rr.y,rr.z),e.setOrientation(sr.x,sr.y,sr.z,t.x,t.y,t.z)}},l.AudioLoader=kh,l.AxesHelper=vu,l.AxisHelper=function(s){return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."),new vu(s)},l.BackSide=1,l.BasicDepthPacking=3200,l.BasicShadowMap=0,l.BinaryTextureLoader=function(s){return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."),new Eh(s)},l.Bone=ga,l.BooleanKeyframeTrack=tr,l.BoundingBoxHelper=function(s,e){return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."),new gu(s,e)},l.Box2=Kr,l.Box3=Cn,l.Box3Helper=class extends wn{constructor(s,e=16776960){let t=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),n=new st;n.setIndex(new bt(t,1)),n.setAttribute("position",new Ue([1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],3)),super(n,new an({color:e,toneMapped:!1})),this.box=s,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(s){let e=this.box;e.isEmpty()||(e.getCenter(this.position),e.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(s))}},l.BoxBufferGeometry=vi,l.BoxGeometry=vi,l.BoxHelper=gu,l.BufferAttribute=bt,l.BufferGeometry=st,l.BufferGeometryLoader=zh,l.ByteType=1010,l.Cache=ir,l.Camera=rs,l.CameraHelper=class extends wn{constructor(s){let e=new st,t=new an({color:16777215,vertexColors:!0,toneMapped:!1}),n=[],i=[],r={},a=new De(16755200),c=new De(16711680),h=new De(43775),u=new De(16777215),d=new De(3355443);function p(m,g,y){f(m,y),f(g,y)}function f(m,g){n.push(0,0,0),i.push(g.r,g.g,g.b),r[m]===void 0&&(r[m]=[]),r[m].push(n.length/3-1)}p("n1","n2",a),p("n2","n4",a),p("n4","n3",a),p("n3","n1",a),p("f1","f2",a),p("f2","f4",a),p("f4","f3",a),p("f3","f1",a),p("n1","f1",a),p("n2","f2",a),p("n3","f3",a),p("n4","f4",a),p("p","n1",c),p("p","n2",c),p("p","n3",c),p("p","n4",c),p("u1","u2",h),p("u2","u3",h),p("u3","u1",h),p("c","t",u),p("p","c",d),p("cn1","cn2",d),p("cn3","cn4",d),p("cf1","cf2",d),p("cf3","cf4",d),e.setAttribute("position",new Ue(n,3)),e.setAttribute("color",new Ue(i,3)),super(e,t),this.type="CameraHelper",this.camera=s,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=s.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=r,this.update()}update(){let s=this.geometry,e=this.pointMap;jt.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),Kt("c",e,s,jt,0,0,-1),Kt("t",e,s,jt,0,0,1),Kt("n1",e,s,jt,-1,-1,-1),Kt("n2",e,s,jt,1,-1,-1),Kt("n3",e,s,jt,-1,1,-1),Kt("n4",e,s,jt,1,1,-1),Kt("f1",e,s,jt,-1,-1,1),Kt("f2",e,s,jt,1,-1,1),Kt("f3",e,s,jt,-1,1,1),Kt("f4",e,s,jt,1,1,1),Kt("u1",e,s,jt,.7,1.1,-1),Kt("u2",e,s,jt,-.7,1.1,-1),Kt("u3",e,s,jt,0,2,-1),Kt("cf1",e,s,jt,-1,0,1),Kt("cf2",e,s,jt,1,0,1),Kt("cf3",e,s,jt,0,-1,1),Kt("cf4",e,s,jt,0,1,1),Kt("cn1",e,s,jt,-1,0,-1),Kt("cn2",e,s,jt,1,0,-1),Kt("cn3",e,s,jt,0,-1,-1),Kt("cn4",e,s,jt,0,1,-1),s.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}},l.CanvasRenderer=function(){console.error("THREE.CanvasRenderer has been removed")},l.CanvasTexture=ch,l.CatmullRomCurve3=Xo,l.CineonToneMapping=3,l.CircleBufferGeometry=Hr,l.CircleGeometry=Hr,l.ClampToEdgeWrapping=1001,l.Clock=Xh,l.Color=De,l.ColorKeyframeTrack=cl,l.CompressedTexture=Ho,l.CompressedTextureLoader=class extends pn{constructor(s){super(s)}load(s,e,t,n){let i=this,r=[],a=new Ho,c=new Jn(this.manager);c.setPath(this.path),c.setResponseType("arraybuffer"),c.setRequestHeader(this.requestHeader),c.setWithCredentials(i.withCredentials);let h=0;function u(d){c.load(s[d],function(p){let f=i.parse(p,!0);r[d]={width:f.width,height:f.height,format:f.format,mipmaps:f.mipmaps},h+=1,h===6&&(f.mipmapCount===1&&(a.minFilter=1006),a.image=r,a.format=f.format,a.needsUpdate=!0,e&&e(a))},t,n)}if(Array.isArray(s))for(let d=0,p=s.length;d<p;++d)u(d);else c.load(s,function(d){let p=i.parse(d,!0);if(p.isCubemap){let f=p.mipmaps.length/p.mipmapCount;for(let m=0;m<f;m++){r[m]={mipmaps:[]};for(let g=0;g<p.mipmapCount;g++)r[m].mipmaps.push(p.mipmaps[m*p.mipmapCount+g]),r[m].format=p.format,r[m].width=p.width,r[m].height=p.height}a.image=r}else a.image.width=p.width,a.image.height=p.height,a.mipmaps=p.mipmaps;p.mipmapCount===1&&(a.minFilter=1006),a.format=p.format,a.needsUpdate=!0,e&&e(a)},t,n);return a}},l.ConeBufferGeometry=Ur,l.ConeGeometry=Ur,l.CubeCamera=ea,l.CubeReflectionMapping=301,l.CubeRefractionMapping=302,l.CubeTexture=Rr,l.CubeTextureLoader=Th,l.CubeUVReflectionMapping=306,l.CubeUVRefractionMapping=307,l.CubicBezierCurve=Ea,l.CubicBezierCurve3=Zo,l.CubicInterpolant=bh,l.CullFaceBack=1,l.CullFaceFront=2,l.CullFaceFrontBack=3,l.CullFaceNone=0,l.Curve=In,l.CurvePath=Lh,l.CustomBlending=5,l.CustomToneMapping=5,l.CylinderBufferGeometry=Oi,l.CylinderGeometry=Oi,l.Cylindrical=class{constructor(s=1,e=0,t=0){return this.radius=s,this.theta=e,this.y=t,this}set(s,e,t){return this.radius=s,this.theta=e,this.y=t,this}copy(s){return this.radius=s.radius,this.theta=s.theta,this.y=s.y,this}setFromVector3(s){return this.setFromCartesianCoords(s.x,s.y,s.z)}setFromCartesianCoords(s,e,t){return this.radius=Math.sqrt(s*s+t*t),this.theta=Math.atan2(s,t),this.y=e,this}clone(){return new this.constructor().copy(this)}},l.DataTexture=Yi,l.DataTexture2DArray=Lo,l.DataTexture3D=Ro,l.DataTextureLoader=Eh,l.DataUtils=class{static toHalfFloat(s){xu[0]=s;let e=pm[0],t=e>>16&32768,n=e>>12&2047,i=e>>23&255;return i<103?t:i>142?(t|=31744,t|=(i==255?0:1)&&8388607&e,t):i<113?(n|=2048,t|=(n>>114-i)+(n>>113-i&1),t):(t|=i-112<<10|n>>1,t+=1&n,t)}},l.DecrementStencilOp=7683,l.DecrementWrapStencilOp=34056,l.DefaultLoadingManager=Sh,l.DepthFormat=1026,l.DepthStencilFormat=1027,l.DepthTexture=hh,l.DirectionalLight=gl,l.DirectionalLightHelper=class extends pt{constructor(s,e,t){super(),this.light=s,this.light.updateMatrixWorld(),this.matrix=s.matrixWorld,this.matrixAutoUpdate=!1,this.color=t,e===void 0&&(e=1);let n=new st;n.setAttribute("position",new Ue([-e,e,0,e,e,0,e,-e,0,-e,-e,0,-e,e,0],3));let i=new an({fog:!1,toneMapped:!1});this.lightPlane=new _i(n,i),this.add(this.lightPlane),n=new st,n.setAttribute("position",new Ue([0,0,0,0,0,1],3)),this.targetLine=new _i(n,i),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){fu.setFromMatrixPosition(this.light.matrixWorld),Ua.setFromMatrixPosition(this.light.target.matrixWorld),mu.subVectors(Ua,fu),this.lightPlane.lookAt(Ua),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(Ua),this.targetLine.scale.z=mu.length()}},l.DiscreteInterpolant=Mh,l.DodecahedronBufferGeometry=Gr,l.DodecahedronGeometry=Gr,l.DoubleSide=2,l.DstAlphaFactor=206,l.DstColorFactor=208,l.DynamicBufferAttribute=function(s,e){return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."),new bt(s,e).setUsage(35048)},l.DynamicCopyUsage=35050,l.DynamicDrawUsage=35048,l.DynamicReadUsage=35049,l.EdgesGeometry=Go,l.EdgesHelper=function(s,e){return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),new wn(new Go(s.geometry),new an({color:e!==void 0?e:16777215}))},l.EllipseCurve=gs,l.EqualDepth=4,l.EqualStencilFunc=514,l.EquirectangularReflectionMapping=303,l.EquirectangularRefractionMapping=304,l.Euler=Wi,l.EventDispatcher=Me,l.ExtrudeBufferGeometry=Xn,l.ExtrudeGeometry=Xn,l.FaceColors=1,l.FileLoader=Jn,l.FlatShading=1,l.Float16BufferAttribute=ic,l.Float32Attribute=function(s,e){return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."),new Ue(s,e)},l.Float32BufferAttribute=Ue,l.Float64Attribute=function(s,e){return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."),new rc(s,e)},l.Float64BufferAttribute=rc,l.FloatType=1015,l.Fog=hs,l.FogExp2=cs,l.Font=bl,l.FontLoader=class extends pn{constructor(s){super(s)}load(s,e,t,n){let i=this,r=new Jn(this.manager);r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(i.withCredentials),r.load(s,function(a){let c;try{c=JSON.parse(a)}catch{console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),c=JSON.parse(a.substring(65,a.length-2))}let h=i.parse(c);e&&e(h)},t,n)}parse(s){return new bl(s)}},l.FrontSide=0,l.Frustum=ss,l.GLBufferAttribute=nu,l.GLSL1="100",l.GLSL3=re,l.GammaEncoding=3007,l.GreaterDepth=6,l.GreaterEqualDepth=5,l.GreaterEqualStencilFunc=518,l.GreaterStencilFunc=516,l.GridHelper=pu,l.Group=Xi,l.HalfFloatType=1016,l.HemisphereLight=ul,l.HemisphereLightHelper=class extends pt{constructor(s,e,t){super(),this.light=s,this.light.updateMatrixWorld(),this.matrix=s.matrixWorld,this.matrixAutoUpdate=!1,this.color=t;let n=new Qi(e);n.rotateY(.5*Math.PI),this.material=new yi({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);let i=n.getAttribute("position"),r=new Float32Array(3*i.count);n.setAttribute("color",new bt(r,3)),this.add(new en(n,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){let s=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{let e=s.geometry.getAttribute("color");uu.copy(this.light.color),du.copy(this.light.groundColor);for(let t=0,n=e.count;t<n;t++){let i=t<n/2?uu:du;e.setXYZ(t,i.r,i.g,i.b)}e.needsUpdate=!0}s.lookAt(dm.setFromMatrixPosition(this.light.matrixWorld).negate())}},l.HemisphereLightProbe=Vh,l.IcosahedronBufferGeometry=Vr,l.IcosahedronGeometry=Vr,l.ImageBitmapLoader=Uh,l.ImageLoader=Es,l.ImageUtils=ui,l.ImmediateRenderObject=ou,l.IncrementStencilOp=7682,l.IncrementWrapStencilOp=34055,l.InstancedBufferAttribute=Ji,l.InstancedBufferGeometry=_l,l.InstancedInterleavedBuffer=tu,l.InstancedMesh=Fo,l.Int16Attribute=function(s,e){return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."),new tc(s,e)},l.Int16BufferAttribute=tc,l.Int32Attribute=function(s,e){return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."),new nc(s,e)},l.Int32BufferAttribute=nc,l.Int8Attribute=function(s,e){return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."),new Ql(s,e)},l.Int8BufferAttribute=Ql,l.IntType=1013,l.InterleavedBuffer=Zi,l.InterleavedBufferAttribute=Ii,l.Interpolant=bi,l.InterpolateDiscrete=2300,l.InterpolateLinear=2301,l.InterpolateSmooth=2302,l.InvertStencilOp=5386,l.JSONLoader=function(){console.error("THREE.JSONLoader has been removed.")},l.KeepStencilOp=7680,l.KeyframeTrack=Zn,l.LOD=Xc,l.LatheBufferGeometry=Wr,l.LatheGeometry=Wr,l.Layers=lo,l.LensFlare=function(){console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js")},l.LessDepth=2,l.LessEqualDepth=3,l.LessEqualStencilFunc=515,l.LessStencilFunc=513,l.Light=Kn,l.LightProbe=Rs,l.Line=_i,l.Line3=au,l.LineBasicMaterial=an,l.LineCurve=xs,l.LineCurve3=dh,l.LineDashedMaterial=ol,l.LineLoop=zo,l.LinePieces=1,l.LineSegments=wn,l.LineStrip=0,l.LinearEncoding=3e3,l.LinearFilter=1006,l.LinearInterpolant=ll,l.LinearMipMapLinearFilter=1008,l.LinearMipMapNearestFilter=1007,l.LinearMipmapLinearFilter=1008,l.LinearMipmapNearestFilter=1007,l.LinearToneMapping=1,l.Loader=pn,l.LoaderUtils=Fa,l.LoadingManager=hl,l.LogLuvEncoding=3003,l.LoopOnce=2200,l.LoopPingPong=2202,l.LoopRepeat=2201,l.LuminanceAlphaFormat=1025,l.LuminanceFormat=1024,l.MOUSE={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},l.Material=nn,l.MaterialLoader=Nh,l.Math=Ln,l.MathUtils=Ln,l.Matrix3=Nt,l.Matrix4=Xe,l.MaxEquation=104,l.Mesh=en,l.MeshBasicMaterial=yi,l.MeshDepthMaterial=aa,l.MeshDistanceMaterial=oa,l.MeshFaceMaterial=function(s){return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."),s},l.MeshLambertMaterial=sl,l.MeshMatcapMaterial=al,l.MeshNormalMaterial=rl,l.MeshPhongMaterial=nl,l.MeshPhysicalMaterial=tl,l.MeshStandardMaterial=Oa,l.MeshToonMaterial=il,l.MinEquation=103,l.MirroredRepeatWrapping=1002,l.MixOperation=1,l.MultiMaterial=function(s=[]){return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."),s.isMultiMaterial=!0,s.materials=s,s.clone=function(){return s.slice()},s},l.MultiplyBlending=4,l.MultiplyOperation=0,l.NearestFilter=1003,l.NearestMipMapLinearFilter=1005,l.NearestMipMapNearestFilter=1004,l.NearestMipmapLinearFilter=1005,l.NearestMipmapNearestFilter=1004,l.NeverDepth=0,l.NeverStencilFunc=512,l.NoBlending=0,l.NoColors=0,l.NoToneMapping=0,l.NormalAnimationBlendMode=2500,l.NormalBlending=1,l.NotEqualDepth=7,l.NotEqualStencilFunc=517,l.NumberKeyframeTrack=ws,l.Object3D=pt,l.ObjectLoader=class extends pn{constructor(s){super(s)}load(s,e,t,n){let i=this,r=this.path===""?Fa.extractUrlBase(s):this.path;this.resourcePath=this.resourcePath||r;let a=new Jn(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(s,function(c){let h=null;try{h=JSON.parse(c)}catch(d){return n!==void 0&&n(d),void console.error("THREE:ObjectLoader: Can't parse "+s+".",d.message)}let u=h.metadata;u!==void 0&&u.type!==void 0&&u.type.toLowerCase()!=="geometry"?i.parse(h,e):console.error("THREE.ObjectLoader: Can't load "+s)},t,n)}async loadAsync(s,e){let t=this.path===""?Fa.extractUrlBase(s):this.path;this.resourcePath=this.resourcePath||t;let n=new Jn(this.manager);n.setPath(this.path),n.setRequestHeader(this.requestHeader),n.setWithCredentials(this.withCredentials);let i=await n.loadAsync(s,e),r=JSON.parse(i),a=r.metadata;if(a===void 0||a.type===void 0||a.type.toLowerCase()==="geometry")throw new Error("THREE.ObjectLoader: Can't load "+s);return await this.parseAsync(r)}parse(s,e){let t=this.parseAnimations(s.animations),n=this.parseShapes(s.shapes),i=this.parseGeometries(s.geometries,n),r=this.parseImages(s.images,function(){e!==void 0&&e(h)}),a=this.parseTextures(s.textures,r),c=this.parseMaterials(s.materials,a),h=this.parseObject(s.object,i,c,a,t),u=this.parseSkeletons(s.skeletons,h);if(this.bindSkeletons(h,u),e!==void 0){let d=!1;for(let p in r)if(r[p]instanceof HTMLImageElement){d=!0;break}d===!1&&e(h)}return h}async parseAsync(s){let e=this.parseAnimations(s.animations),t=this.parseShapes(s.shapes),n=this.parseGeometries(s.geometries,t),i=await this.parseImagesAsync(s.images),r=this.parseTextures(s.textures,i),a=this.parseMaterials(s.materials,r),c=this.parseObject(s.object,n,a,r,e),h=this.parseSkeletons(s.skeletons,c);return this.bindSkeletons(c,h),c}parseShapes(s){let e={};if(s!==void 0)for(let t=0,n=s.length;t<n;t++){let i=new Ni().fromJSON(s[t]);e[i.uuid]=i}return e}parseSkeletons(s,e){let t={},n={};if(e.traverse(function(i){i.isBone&&(n[i.uuid]=i)}),s!==void 0)for(let i=0,r=s.length;i<r;i++){let a=new ya().fromJSON(s[i],n);t[a.uuid]=a}return t}parseGeometries(s,e){let t={};if(s!==void 0){let n=new zh;for(let i=0,r=s.length;i<r;i++){let a,c=s[i];switch(c.type){case"BufferGeometry":case"InstancedBufferGeometry":a=n.parse(c);break;case"Geometry":console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");break;default:c.type in _h?a=_h[c.type].fromJSON(c,e):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${c.type}"`)}a.uuid=c.uuid,c.name!==void 0&&(a.name=c.name),a.isBufferGeometry===!0&&c.userData!==void 0&&(a.userData=c.userData),t[c.uuid]=a}}return t}parseMaterials(s,e){let t={},n={};if(s!==void 0){let i=new Nh;i.setTextures(e);for(let r=0,a=s.length;r<a;r++){let c=s[r];if(c.type==="MultiMaterial"){let h=[];for(let u=0;u<c.materials.length;u++){let d=c.materials[u];t[d.uuid]===void 0&&(t[d.uuid]=i.parse(d)),h.push(t[d.uuid])}n[c.uuid]=h}else t[c.uuid]===void 0&&(t[c.uuid]=i.parse(c)),n[c.uuid]=t[c.uuid]}}return n}parseAnimations(s){let e={};if(s!==void 0)for(let t=0;t<s.length;t++){let n=s[t],i=Ts.parse(n);e[i.uuid]=i}return e}parseImages(s,e){let t=this,n={},i;function r(a){if(typeof a=="string"){let c=a;return function(h){return t.manager.itemStart(h),i.load(h,function(){t.manager.itemEnd(h)},void 0,function(){t.manager.itemError(h),t.manager.itemEnd(h)})}(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(c)?c:t.resourcePath+c)}return a.data?{data:Sr(a.type,a.data),width:a.width,height:a.height}:null}if(s!==void 0&&s.length>0){let a=new hl(e);i=new Es(a),i.setCrossOrigin(this.crossOrigin);for(let c=0,h=s.length;c<h;c++){let u=s[c],d=u.url;if(Array.isArray(d)){n[u.uuid]=[];for(let p=0,f=d.length;p<f;p++){let m=r(d[p]);m!==null&&(m instanceof HTMLImageElement?n[u.uuid].push(m):n[u.uuid].push(new Yi(m.data,m.width,m.height)))}}else{let p=r(u.url);p!==null&&(n[u.uuid]=p)}}}return n}async parseImagesAsync(s){let e=this,t={},n;async function i(r){if(typeof r=="string"){let a=r,c=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(a)?a:e.resourcePath+a;return await n.loadAsync(c)}return r.data?{data:Sr(r.type,r.data),width:r.width,height:r.height}:null}if(s!==void 0&&s.length>0){n=new Es(this.manager),n.setCrossOrigin(this.crossOrigin);for(let r=0,a=s.length;r<a;r++){let c=s[r],h=c.url;if(Array.isArray(h)){t[c.uuid]=[];for(let u=0,d=h.length;u<d;u++){let p=h[u],f=await i(p);f!==null&&(f instanceof HTMLImageElement?t[c.uuid].push(f):t[c.uuid].push(new Yi(f.data,f.width,f.height)))}}else{let u=await i(c.url);u!==null&&(t[c.uuid]=u)}}}return t}parseTextures(s,e){function t(i,r){return typeof i=="number"?i:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",i),r[i])}let n={};if(s!==void 0)for(let i=0,r=s.length;i<r;i++){let a=s[i],c;a.image===void 0&&console.warn('THREE.ObjectLoader: No "image" specified for',a.uuid),e[a.image]===void 0&&console.warn("THREE.ObjectLoader: Undefined image",a.image);let h=e[a.image];Array.isArray(h)?(c=new Rr(h),h.length===6&&(c.needsUpdate=!0)):(c=h&&h.data?new Yi(h.data,h.width,h.height):new zt(h),h&&(c.needsUpdate=!0)),c.uuid=a.uuid,a.name!==void 0&&(c.name=a.name),a.mapping!==void 0&&(c.mapping=t(a.mapping,Qf)),a.offset!==void 0&&c.offset.fromArray(a.offset),a.repeat!==void 0&&c.repeat.fromArray(a.repeat),a.center!==void 0&&c.center.fromArray(a.center),a.rotation!==void 0&&(c.rotation=a.rotation),a.wrap!==void 0&&(c.wrapS=t(a.wrap[0],Bh),c.wrapT=t(a.wrap[1],Bh)),a.format!==void 0&&(c.format=a.format),a.type!==void 0&&(c.type=a.type),a.encoding!==void 0&&(c.encoding=a.encoding),a.minFilter!==void 0&&(c.minFilter=t(a.minFilter,Hh)),a.magFilter!==void 0&&(c.magFilter=t(a.magFilter,Hh)),a.anisotropy!==void 0&&(c.anisotropy=a.anisotropy),a.flipY!==void 0&&(c.flipY=a.flipY),a.premultiplyAlpha!==void 0&&(c.premultiplyAlpha=a.premultiplyAlpha),a.unpackAlignment!==void 0&&(c.unpackAlignment=a.unpackAlignment),n[a.uuid]=c}return n}parseObject(s,e,t,n,i){let r,a,c;function h(p){return e[p]===void 0&&console.warn("THREE.ObjectLoader: Undefined geometry",p),e[p]}function u(p){if(p!==void 0){if(Array.isArray(p)){let f=[];for(let m=0,g=p.length;m<g;m++){let y=p[m];t[y]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",y),f.push(t[y])}return f}return t[p]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",p),t[p]}}function d(p){return n[p]===void 0&&console.warn("THREE.ObjectLoader: Undefined texture",p),n[p]}switch(s.type){case"Scene":r=new la,s.background!==void 0&&(Number.isInteger(s.background)?r.background=new De(s.background):r.background=d(s.background)),s.environment!==void 0&&(r.environment=d(s.environment)),s.fog!==void 0&&(s.fog.type==="Fog"?r.fog=new hs(s.fog.color,s.fog.near,s.fog.far):s.fog.type==="FogExp2"&&(r.fog=new cs(s.fog.color,s.fog.density)));break;case"PerspectiveCamera":r=new sn(s.fov,s.aspect,s.near,s.far),s.focus!==void 0&&(r.focus=s.focus),s.zoom!==void 0&&(r.zoom=s.zoom),s.filmGauge!==void 0&&(r.filmGauge=s.filmGauge),s.filmOffset!==void 0&&(r.filmOffset=s.filmOffset),s.view!==void 0&&(r.view=Object.assign({},s.view));break;case"OrthographicCamera":r=new as(s.left,s.right,s.top,s.bottom,s.near,s.far),s.zoom!==void 0&&(r.zoom=s.zoom),s.view!==void 0&&(r.view=Object.assign({},s.view));break;case"AmbientLight":r=new yl(s.color,s.intensity);break;case"DirectionalLight":r=new gl(s.color,s.intensity);break;case"PointLight":r=new ml(s.color,s.intensity,s.distance,s.decay);break;case"RectAreaLight":r=new vl(s.color,s.intensity,s.width,s.height);break;case"SpotLight":r=new pl(s.color,s.intensity,s.distance,s.angle,s.penumbra,s.decay);break;case"HemisphereLight":r=new ul(s.color,s.groundColor,s.intensity);break;case"LightProbe":r=new Rs().fromJSON(s);break;case"SkinnedMesh":a=h(s.geometry),c=u(s.material),r=new ma(a,c),s.bindMode!==void 0&&(r.bindMode=s.bindMode),s.bindMatrix!==void 0&&r.bindMatrix.fromArray(s.bindMatrix),s.skeleton!==void 0&&(r.skeleton=s.skeleton);break;case"Mesh":a=h(s.geometry),c=u(s.material),r=new en(a,c);break;case"InstancedMesh":a=h(s.geometry),c=u(s.material);let p=s.count,f=s.instanceMatrix,m=s.instanceColor;r=new Fo(a,c,p),r.instanceMatrix=new Ji(new Float32Array(f.array),16),m!==void 0&&(r.instanceColor=new Ji(new Float32Array(m.array),m.itemSize));break;case"LOD":r=new Xc;break;case"Line":r=new _i(h(s.geometry),u(s.material));break;case"LineLoop":r=new zo(h(s.geometry),u(s.material));break;case"LineSegments":r=new wn(h(s.geometry),u(s.material));break;case"PointCloud":case"Points":r=new ms(h(s.geometry),u(s.material));break;case"Sprite":r=new da(u(s.material));break;case"Group":r=new Xi;break;case"Bone":r=new ga;break;default:r=new pt}if(r.uuid=s.uuid,s.name!==void 0&&(r.name=s.name),s.matrix!==void 0?(r.matrix.fromArray(s.matrix),s.matrixAutoUpdate!==void 0&&(r.matrixAutoUpdate=s.matrixAutoUpdate),r.matrixAutoUpdate&&r.matrix.decompose(r.position,r.quaternion,r.scale)):(s.position!==void 0&&r.position.fromArray(s.position),s.rotation!==void 0&&r.rotation.fromArray(s.rotation),s.quaternion!==void 0&&r.quaternion.fromArray(s.quaternion),s.scale!==void 0&&r.scale.fromArray(s.scale)),s.castShadow!==void 0&&(r.castShadow=s.castShadow),s.receiveShadow!==void 0&&(r.receiveShadow=s.receiveShadow),s.shadow&&(s.shadow.bias!==void 0&&(r.shadow.bias=s.shadow.bias),s.shadow.normalBias!==void 0&&(r.shadow.normalBias=s.shadow.normalBias),s.shadow.radius!==void 0&&(r.shadow.radius=s.shadow.radius),s.shadow.mapSize!==void 0&&r.shadow.mapSize.fromArray(s.shadow.mapSize),s.shadow.camera!==void 0&&(r.shadow.camera=this.parseObject(s.shadow.camera))),s.visible!==void 0&&(r.visible=s.visible),s.frustumCulled!==void 0&&(r.frustumCulled=s.frustumCulled),s.renderOrder!==void 0&&(r.renderOrder=s.renderOrder),s.userData!==void 0&&(r.userData=s.userData),s.layers!==void 0&&(r.layers.mask=s.layers),s.children!==void 0){let p=s.children;for(let f=0;f<p.length;f++)r.add(this.parseObject(p[f],e,t,n,i))}if(s.animations!==void 0){let p=s.animations;for(let f=0;f<p.length;f++){let m=p[f];r.animations.push(i[m])}}if(s.type==="LOD"){s.autoUpdate!==void 0&&(r.autoUpdate=s.autoUpdate);let p=s.levels;for(let f=0;f<p.length;f++){let m=p[f],g=r.getObjectByProperty("uuid",m.object);g!==void 0&&r.addLevel(g,m.distance)}}return r}bindSkeletons(s,e){Object.keys(e).length!==0&&s.traverse(function(t){if(t.isSkinnedMesh===!0&&t.skeleton!==void 0){let n=e[t.skeleton];n===void 0?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",t.skeleton):t.bind(n,t.bindMatrix)}})}setTexturePath(s){return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."),this.setResourcePath(s)}},l.ObjectSpaceNormalMap=1,l.OctahedronBufferGeometry=Qi,l.OctahedronGeometry=Qi,l.OneFactor=201,l.OneMinusDstAlphaFactor=207,l.OneMinusDstColorFactor=209,l.OneMinusSrcAlphaFactor=205,l.OneMinusSrcColorFactor=203,l.OrthographicCamera=as,l.PCFShadowMap=1,l.PCFSoftShadowMap=2,l.PMREMGenerator=fc,l.ParametricBufferGeometry=Da,l.ParametricGeometry=Da,l.Particle=function(s){return console.warn("THREE.Particle has been renamed to THREE.Sprite."),new da(s)},l.ParticleBasicMaterial=function(s){return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),new Ki(s)},l.ParticleSystem=function(s,e){return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),new ms(s,e)},l.ParticleSystemMaterial=function(s){return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),new Ki(s)},l.Path=As,l.PerspectiveCamera=sn,l.Plane=ni,l.PlaneBufferGeometry=qi,l.PlaneGeometry=qi,l.PlaneHelper=class extends _i{constructor(s,e=1,t=16776960){let n=t,i=new st;i.setAttribute("position",new Ue([1,-1,1,-1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,0,0,1,0,0,0],3)),i.computeBoundingSphere(),super(i,new an({color:n,toneMapped:!1})),this.type="PlaneHelper",this.plane=s,this.size=e;let r=new st;r.setAttribute("position",new Ue([1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,1],3)),r.computeBoundingSphere(),this.add(new en(r,new yi({color:n,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(s){let e=-this.plane.constant;Math.abs(e)<1e-8&&(e=1e-8),this.scale.set(.5*this.size,.5*this.size,e),this.children[0].material.side=e<0?1:0,this.lookAt(this.plane.normal),super.updateMatrixWorld(s)}},l.PointCloud=function(s,e){return console.warn("THREE.PointCloud has been renamed to THREE.Points."),new ms(s,e)},l.PointCloudMaterial=function(s){return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),new Ki(s)},l.PointLight=ml,l.PointLightHelper=class extends en{constructor(s,e,t){super(new er(e,4,2),new yi({wireframe:!0,fog:!1,toneMapped:!1})),this.light=s,this.light.updateMatrixWorld(),this.color=t,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}},l.Points=ms,l.PointsMaterial=Ki,l.PolarGridHelper=class extends wn{constructor(s=10,e=16,t=8,n=64,i=4473924,r=8947848){i=new De(i),r=new De(r);let a=[],c=[];for(let u=0;u<=e;u++){let d=u/e*(2*Math.PI),p=Math.sin(d)*s,f=Math.cos(d)*s;a.push(0,0,0),a.push(p,0,f);let m=1&u?i:r;c.push(m.r,m.g,m.b),c.push(m.r,m.g,m.b)}for(let u=0;u<=t;u++){let d=1&u?i:r,p=s-s/t*u;for(let f=0;f<n;f++){let m=f/n*(2*Math.PI),g=Math.sin(m)*p,y=Math.cos(m)*p;a.push(g,0,y),c.push(d.r,d.g,d.b),m=(f+1)/n*(2*Math.PI),g=Math.sin(m)*p,y=Math.cos(m)*p,a.push(g,0,y),c.push(d.r,d.g,d.b)}}let h=new st;h.setAttribute("position",new Ue(a,3)),h.setAttribute("color",new Ue(c,3)),super(h,new an({vertexColors:!0,toneMapped:!1})),this.type="PolarGridHelper"}},l.PolyhedronBufferGeometry=si,l.PolyhedronGeometry=si,l.PositionalAudio=class extends wl{constructor(s){super(s),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(s){return this.panner.refDistance=s,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(s){return this.panner.rolloffFactor=s,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(s){return this.panner.distanceModel=s,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(s){return this.panner.maxDistance=s,this}setDirectionalCone(s,e,t){return this.panner.coneInnerAngle=s,this.panner.coneOuterAngle=e,this.panner.coneOuterGain=t,this}updateMatrixWorld(s){if(super.updateMatrixWorld(s),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(ar,Jh,tm),or.set(0,0,1).applyQuaternion(Jh);let e=this.panner;if(e.positionX){let t=this.context.currentTime+this.listener.timeDelta;e.positionX.linearRampToValueAtTime(ar.x,t),e.positionY.linearRampToValueAtTime(ar.y,t),e.positionZ.linearRampToValueAtTime(ar.z,t),e.orientationX.linearRampToValueAtTime(or.x,t),e.orientationY.linearRampToValueAtTime(or.y,t),e.orientationZ.linearRampToValueAtTime(or.z,t)}else e.setPosition(ar.x,ar.y,ar.z),e.setOrientation(or.x,or.y,or.z)}},l.PropertyBinding=Mt,l.PropertyMixer=Qh,l.QuadraticBezierCurve=Aa,l.QuadraticBezierCurve3=Yo,l.Quaternion=tn,l.QuaternionKeyframeTrack=Jr,l.QuaternionLinearInterpolant=wh,l.REVISION=_,l.RGBADepthPacking=3201,l.RGBAFormat=1023,l.RGBAIntegerFormat=1033,l.RGBA_ASTC_10x10_Format=37819,l.RGBA_ASTC_10x5_Format=37816,l.RGBA_ASTC_10x6_Format=37817,l.RGBA_ASTC_10x8_Format=37818,l.RGBA_ASTC_12x10_Format=37820,l.RGBA_ASTC_12x12_Format=37821,l.RGBA_ASTC_4x4_Format=37808,l.RGBA_ASTC_5x4_Format=37809,l.RGBA_ASTC_5x5_Format=37810,l.RGBA_ASTC_6x5_Format=37811,l.RGBA_ASTC_6x6_Format=37812,l.RGBA_ASTC_8x5_Format=37813,l.RGBA_ASTC_8x6_Format=37814,l.RGBA_ASTC_8x8_Format=37815,l.RGBA_BPTC_Format=36492,l.RGBA_ETC2_EAC_Format=37496,l.RGBA_PVRTC_2BPPV1_Format=35843,l.RGBA_PVRTC_4BPPV1_Format=35842,l.RGBA_S3TC_DXT1_Format=33777,l.RGBA_S3TC_DXT3_Format=33778,l.RGBA_S3TC_DXT5_Format=33779,l.RGBDEncoding=3006,l.RGBEEncoding=3002,l.RGBEFormat=1023,l.RGBFormat=1022,l.RGBIntegerFormat=1032,l.RGBM16Encoding=3005,l.RGBM7Encoding=3004,l.RGB_ETC1_Format=36196,l.RGB_ETC2_Format=37492,l.RGB_PVRTC_2BPPV1_Format=35841,l.RGB_PVRTC_4BPPV1_Format=35840,l.RGB_S3TC_DXT1_Format=33776,l.RGFormat=1030,l.RGIntegerFormat=1031,l.RawShaderMaterial=Pr,l.Ray=Ai,l.Raycaster=class{constructor(s,e,t=0,n=1/0){this.ray=new Ai(s,e),this.near=t,this.far=n,this.camera=null,this.layers=new lo,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(s,e){this.ray.set(s,e)}setFromCamera(s,e){e&&e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(s.x,s.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e&&e.isOrthographicCamera?(this.ray.origin.set(s.x,s.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):console.error("THREE.Raycaster: Unsupported camera type: "+e.type)}intersectObject(s,e=!1,t=[]){return Tl(s,this,t,e),t.sort(iu),t}intersectObjects(s,e=!1,t=[]){for(let n=0,i=s.length;n<i;n++)Tl(s[n],this,t,e);return t.sort(iu),t}},l.RectAreaLight=vl,l.RedFormat=1028,l.RedIntegerFormat=1029,l.ReinhardToneMapping=2,l.RepeatWrapping=1e3,l.ReplaceStencilOp=7681,l.ReverseSubtractEquation=102,l.RingBufferGeometry=qr,l.RingGeometry=qr,l.SRGB8_ALPHA8_ASTC_10x10_Format=37851,l.SRGB8_ALPHA8_ASTC_10x5_Format=37848,l.SRGB8_ALPHA8_ASTC_10x6_Format=37849,l.SRGB8_ALPHA8_ASTC_10x8_Format=37850,l.SRGB8_ALPHA8_ASTC_12x10_Format=37852,l.SRGB8_ALPHA8_ASTC_12x12_Format=37853,l.SRGB8_ALPHA8_ASTC_4x4_Format=37840,l.SRGB8_ALPHA8_ASTC_5x4_Format=37841,l.SRGB8_ALPHA8_ASTC_5x5_Format=37842,l.SRGB8_ALPHA8_ASTC_6x5_Format=37843,l.SRGB8_ALPHA8_ASTC_6x6_Format=37844,l.SRGB8_ALPHA8_ASTC_8x5_Format=37845,l.SRGB8_ALPHA8_ASTC_8x6_Format=37846,l.SRGB8_ALPHA8_ASTC_8x8_Format=37847,l.Scene=la,l.SceneUtils=fm,l.ShaderChunk=ft,l.ShaderLib=jn,l.ShaderMaterial=xi,l.ShadowMaterial=el,l.Shape=Ni,l.ShapeBufferGeometry=$i,l.ShapeGeometry=$i,l.ShapePath=Gh,l.ShapeUtils=ai,l.ShortType=1011,l.Skeleton=ya,l.SkeletonHelper=cu,l.SkinnedMesh=ma,l.SmoothShading=2,l.Sphere=Ti,l.SphereBufferGeometry=er,l.SphereGeometry=er,l.Spherical=class{constructor(s=1,e=0,t=0){return this.radius=s,this.phi=e,this.theta=t,this}set(s,e,t){return this.radius=s,this.phi=e,this.theta=t,this}copy(s){return this.radius=s.radius,this.phi=s.phi,this.theta=s.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(s){return this.setFromCartesianCoords(s.x,s.y,s.z)}setFromCartesianCoords(s,e,t){return this.radius=Math.sqrt(s*s+e*e+t*t),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(s,t),this.phi=Math.acos(Ke(e/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}},l.SphericalHarmonics3=xl,l.SplineCurve=La,l.SpotLight=pl,l.SpotLightHelper=class extends pt{constructor(s,e){super(),this.light=s,this.light.updateMatrixWorld(),this.matrix=s.matrixWorld,this.matrixAutoUpdate=!1,this.color=e;let t=new st,n=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let r=0,a=1,c=32;r<c;r++,a++){let h=r/c*Math.PI*2,u=a/c*Math.PI*2;n.push(Math.cos(h),Math.sin(h),1,Math.cos(u),Math.sin(u),1)}t.setAttribute("position",new Ue(n,3));let i=new an({fog:!1,toneMapped:!1});this.cone=new wn(t,i),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateMatrixWorld();let s=this.light.distance?this.light.distance:1e3,e=s*Math.tan(this.light.angle);this.cone.scale.set(e,e,s),lu.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(lu),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}},l.Sprite=da,l.SpriteMaterial=ca,l.SrcAlphaFactor=204,l.SrcAlphaSaturateFactor=210,l.SrcColorFactor=202,l.StaticCopyUsage=35046,l.StaticDrawUsage=35044,l.StaticReadUsage=35045,l.StereoCamera=class{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new sn,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new sn,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(s){let e=this._cache;if(e.focus!==s.focus||e.fov!==s.fov||e.aspect!==s.aspect*this.aspect||e.near!==s.near||e.far!==s.far||e.zoom!==s.zoom||e.eyeSep!==this.eyeSep){e.focus=s.focus,e.fov=s.fov,e.aspect=s.aspect*this.aspect,e.near=s.near,e.far=s.far,e.zoom=s.zoom,e.eyeSep=this.eyeSep;let t=s.projectionMatrix.clone(),n=e.eyeSep/2,i=n*e.near/e.focus,r=e.near*Math.tan(rt*e.fov*.5)/e.zoom,a,c;jh.elements[12]=-n,qh.elements[12]=n,a=-r*e.aspect+i,c=r*e.aspect+i,t.elements[0]=2*e.near/(c-a),t.elements[8]=(c+a)/(c-a),this.cameraL.projectionMatrix.copy(t),a=-r*e.aspect-i,c=r*e.aspect-i,t.elements[0]=2*e.near/(c-a),t.elements[8]=(c+a)/(c-a),this.cameraR.projectionMatrix.copy(t)}this.cameraL.matrixWorld.copy(s.matrixWorld).multiply(jh),this.cameraR.matrixWorld.copy(s.matrixWorld).multiply(qh)}},l.StreamCopyUsage=35042,l.StreamDrawUsage=35040,l.StreamReadUsage=35041,l.StringKeyframeTrack=nr,l.SubtractEquation=101,l.SubtractiveBlending=3,l.TOUCH={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},l.TangentSpaceNormalMap=0,l.TetrahedronBufferGeometry=jr,l.TetrahedronGeometry=jr,l.TextBufferGeometry=Ia,l.TextGeometry=Ia,l.Texture=zt,l.TextureLoader=Ah,l.TorusBufferGeometry=Xr,l.TorusGeometry=Xr,l.TorusKnotBufferGeometry=Zr,l.TorusKnotGeometry=Zr,l.Triangle=Yt,l.TriangleFanDrawMode=2,l.TriangleStripDrawMode=1,l.TrianglesDrawMode=0,l.TubeBufferGeometry=Yr,l.TubeGeometry=Yr,l.UVMapping=300,l.Uint16Attribute=function(s,e){return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."),new Ws(s,e)},l.Uint16BufferAttribute=Ws,l.Uint32Attribute=function(s,e){return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."),new qs(s,e)},l.Uint32BufferAttribute=qs,l.Uint8Attribute=function(s,e){return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."),new $l(s,e)},l.Uint8BufferAttribute=$l,l.Uint8ClampedAttribute=function(s,e){return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."),new ec(s,e)},l.Uint8ClampedBufferAttribute=ec,l.Uniform=za,l.UniformsLib=Pe,l.UniformsUtils=oc,l.UnsignedByteType=1009,l.UnsignedInt248Type=1020,l.UnsignedIntType=1014,l.UnsignedShort4444Type=1017,l.UnsignedShort5551Type=1018,l.UnsignedShort565Type=1019,l.UnsignedShortType=1012,l.VSMShadowMap=3,l.Vector2=me,l.Vector3=L,l.Vector4=_t,l.VectorKeyframeTrack=Ss,l.Vertex=function(s,e,t){return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),new L(s,e,t)},l.VertexColors=2,l.VideoTexture=lh,l.WebGL1Renderer=kc,l.WebGLCubeRenderTarget=ta,l.WebGLMultipleRenderTargets=Qr,l.WebGLMultisampleRenderTarget=$r,l.WebGLRenderTarget=$t,l.WebGLRenderTargetCube=function(s,e,t){return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."),new ta(s,t)},l.WebGLRenderer=It,l.WebGLUtils=Gc,l.WireframeGeometry=$o,l.WireframeHelper=function(s,e){return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."),new wn(new $o(s.geometry),new an({color:e!==void 0?e:16777215}))},l.WrapAroundEnding=2402,l.XHRLoader=function(s){return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),new Jn(s)},l.ZeroCurvatureEnding=2400,l.ZeroFactor=200,l.ZeroSlopeEnding=2401,l.ZeroStencilOp=0,l.sRGBEncoding=3001,Object.defineProperty(l,"__esModule",{value:!0})})});var Xa=Ht((Iu,Ou)=>{var gm=.0005555555555555556*Math.PI,Du=Math.atan(3/4),ja=63710088e-1,ym=40075017;Ou.exports=Iu={WORLD_SIZE:1024e3,PROJECTION_WORLD_SIZE:1024e3/(ja*Math.PI*2),MERCATOR_A:ja,DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,EARTH_RADIUS:ja,EARTH_CIRCUMFERENCE:2*Math.PI*ja,EARTH_CIRCUMFERENCE_EQUATOR:ym,FOV_ORTHO:gm,FOV:Du,FOV_DEGREES:Du*180/Math.PI,TILE_SIZE:512}});var Bu=Ht((Nu,zu)=>{function Fu(){}Fu.prototype={Coords:function(l){if(l.constructor!==Array){console.error("Coords must be an array");return}if(l.length<2){console.error("Coords length must be at least 2");return}for(let _ of l)if(_.constructor!==Number){console.error("Coords values must be numbers");return}if(Math.abs(l[1])>90){console.error("Latitude must be between -90 and 90");return}return l},Line:function(l){var _=this;if(l.constructor!==Array){console.error("Line must be an array");return}for(let M of l)if(!_.Coords(M)){console.error("Each coordinate in a line must be a valid Coords type");return}return l},Rotation:function(l){if(l.constructor===Number)l={z:l};else if(l.constructor===Object)for(let _ of Object.keys(l)){if(!["x","y","z"].includes(_)){console.error("Rotation parameters must be x, y, or z");return}if(l[_].constructor!==Number){console.error("Individual rotation values must be numbers");return}}else{console.error("Rotation must be an object or a number");return}return l},Scale:function(l){if(l.constructor===Number)l={x:l,y:l,z:l};else if(l.constructor===Object)for(let _ of Object.keys(l)){if(!["x","y","z"].includes(_)){console.error("Scale parameters must be x, y, or z");return}if(l[_].constructor!==Number){console.error("Individual scale values must be numbers");return}}else{console.error("Scale must be an object or a number");return}return l}};zu.exports=Nu=Fu});var Tn=Ht((Hu,Uu)=>{var li=mn(),gn=Xa(),vm=Bu(),Za={prettyPrintMatrix:function(l){for(var _=0;_<4;_++){var M=[l[_],l[_+4],l[_+8],l[_+12]];console.log(M.map(function(b){return b.toFixed(4)}))}},makePerspectiveMatrix:function(l,_,M,b){var P=new li.Matrix4,H=1/Math.tan(l/2),W=1/(M-b),Z=[H/_,0,0,0,0,H,0,0,0,0,(b+M)*W,-1,0,0,2*b*M*W,0];return P.elements=Z,P},makeOrthographicMatrix:function(l,_,M,b,P,H){var W=new li.Matrix4;let Z=1/(_-l),Se=1/(M-b),ve=1/(H-P),ie=(_+l)*Z,Y=(M+b)*Se,Ge=P*ve;var qe=[2*Z,0,0,0,0,2*Se,0,0,0,0,-1*ve,0,-ie,-Y,-Ge,1];return W.elements=qe,W},radify:function(l){function _(M){return M=M||0,Math.PI*2*M/360}return typeof l=="object"?l.length>0?l.map(function(M){return _(M)}):[_(l.x),_(l.y),_(l.z)]:_(l)},degreeify:function(l){function _(M){return M=M||0,M*360/(Math.PI*2)}return typeof l=="object"?[_(l.x),_(l.y),_(l.z)]:_(l)},projectToWorld:function(l){var _=[-gn.MERCATOR_A*gn.DEG2RAD*l[0]*gn.PROJECTION_WORLD_SIZE,-gn.MERCATOR_A*Math.log(Math.tan(Math.PI*.25+.5*gn.DEG2RAD*l[1]))*gn.PROJECTION_WORLD_SIZE];if(!l[2])_.push(0);else{var M=this.projectedUnitsPerMeter(l[1]);_.push(l[2]*M)}var b=new li.Vector3(_[0],_[1],_[2]);return b},projectedUnitsPerMeter:function(l){return Math.abs(gn.WORLD_SIZE/Math.cos(gn.DEG2RAD*l)/gn.EARTH_CIRCUMFERENCE)},_circumferenceAtLatitude:function(l){return gn.EARTH_CIRCUMFERENCE*Math.cos(l*Math.PI/180)},mercatorZfromAltitude:function(l,_){return l/this._circumferenceAtLatitude(_)},_scaleVerticesToMeters:function(l,_){for(var M=this.projectedUnitsPerMeter(l[1]),b=this.projectToWorld(l),P=0;P<_.length;P++)_[P].multiplyScalar(M);return _},projectToScreen:function(l){console.log("WARNING: Projecting to screen coordinates is not yet implemented")},unprojectFromScreen:function(l){console.log("WARNING: unproject is not yet implemented")},unprojectFromWorld:function(l){var _=[-l.x/(gn.MERCATOR_A*gn.DEG2RAD*gn.PROJECTION_WORLD_SIZE),2*(Math.atan(Math.exp(l.y/(gn.PROJECTION_WORLD_SIZE*-gn.MERCATOR_A)))-Math.PI/4)/gn.DEG2RAD],M=this.projectedUnitsPerMeter(_[1]),b=l.z||0;return _.push(b/M),_},toScreenPosition:function(l,_){var M=new li.Vector3,b=.5*renderer.context.canvas.width,P=.5*renderer.context.canvas.height;return l.updateMatrixWorld(),M.setFromMatrixPosition(l.matrixWorld),M.project(_),M.x=M.x*b+b,M.y=-(M.y*P)+P,{x:M.x,y:M.y}},getFeatureCenter:function(_,M,b){let P=[],H=0,W=0,Z=0,Se=[..._.geometry.coordinates[0]];return _.geometry.type==="Point"?P=[...Se[0]]:(_.geometry.type==="MultiPolygon"&&(Se=Se[0]),Se.splice(-1,1),Se.forEach(function(ve){H+=ve[0],W+=ve[1]}),P=[H/Se.length,W/Se.length]),Z=this.getObjectHeightOnFloor(_,M,b),P.length<3?P.push(Z):P[2]=Z,P},getObjectHeightOnFloor:function(l,_,M=l.properties.level||0){let b=M*(l.properties.levelHeight||0),P=l.properties.base_height||l.properties.min_height||0,W=(_&&_.model?0:l.properties.height-P)+P;return b+W},_flipMaterialSides:function(l){},normalizeVertices(l){let _=new li.BufferGeometry,M=[];for(var b=0;b<l.length;b++){let W=l[b];M.push(W.x,W.y,W.z),M.push(W.x,W.y,W.z)}_.setAttribute("position",new li.BufferAttribute(new Float32Array(M),3)),_.computeBoundingSphere();var P=_.boundingSphere.center,H=l.map(function(W){var Z=W.sub(P);return Z});return{vertices:H,position:P}},flattenVectors(l){var _=[];for(let M of l)_.push(M.x,M.y,M.z);return _},lnglatsToWorld:function(l){var _=l.map(function(M){var b=Za.projectToWorld(M),P=new li.Vector3(b.x,b.y,b.z);return P});return _},extend:function(l,_){for(let M in _)l[M]=_[M]},clone:function(l){var _={};for(let M in l)_[M]=l[M];return _},clamp:function(l,_,M){return Math.min(M,Math.max(_,l))},types:{rotation:function(l,_){l||(l=0),typeof l=="number"&&(l={z:l});var M=this.applyDefault([l.x,l.y,l.z],_),b=Za.radify(M);return b},scale:function(l,_){return l||(l=1),typeof l=="number"?l=[l,l,l]:this.applyDefault([l.x,l.y,l.z],_)},applyDefault:function(l,_){var M=l.map(function(b,P){return b=b||_[P],b});return M}},toDecimal:function(l,_){return Number(l.toFixed(_))},equal:function(l,_){let M=Object.keys(l),b=Object.keys(_);if(M.length!==b.length||M.length==0&&b.length==0&&M!==b)return!1;for(let P of M){let H=l[P],W=_[P],Z=this.isObject(H)&&this.isObject(W);if(Z&&!equal(H,W)||!Z&&H!==W)return!1}return!0},isObject:function(l){return l!=null&&typeof l=="object"},curveToLine:(l,_)=>{let{width:M,color:b}=_,P=new li.BufferGeometry().setFromPoints(l.getPoints(100)),H=new li.LineBasicMaterial({color:b,linewidth:M});return new li.Line(P,H)},curvesToLines:l=>{var _=[16711680,2031360,2490623],M=l.map((b,P)=>{let H={width:3,color:_[P]||"purple"};return curveToLine(b,H)});return M},_validate:function(l,_){l=l||{};var M={};Za.extend(M,l);for(let b of Object.keys(_))if(l[b]===void 0)if(_[b]===null){console.error(b+" is required");return}else M[b]=_[b];else M[b]=l[b];return M},Validator:new vm,exposedMethods:["projectToWorld","projectedUnitsPerMeter","extend","unprojectFromWorld"]};Uu.exports=Hu=Za});var Vu=Ht((Gu,ku)=>{var yn=mn(),Cl=Tn(),fr=Xa();function Pl(l,_,M){this.map=l,this.camera=_,this.active=!0,this.camera.matrixAutoUpdate=!1,this.world=M||new yn.Group,this.world.position.x=this.world.position.y=fr.WORLD_SIZE/2,this.world.matrixAutoUpdate=!1,this.state={translateCenter:new yn.Matrix4().makeTranslation(fr.WORLD_SIZE/2,-fr.WORLD_SIZE/2,0),worldSizeRatio:fr.TILE_SIZE/fr.WORLD_SIZE,worldSize:fr.TILE_SIZE*this.map.transform.scale};let b=this;this.map.on("move",function(){b.updateCamera()}).on("resize",function(){let{clientWidth:P,clientHeight:H}=this.getCanvas();_.aspect=P/H,_.updateProjectionMatrix(),this.tb.renderer.setPixelRatio(window.devicePixelRatio),this.tb.renderer.setSize(P,H),b.setupCamera()}),this.setupCamera()}Pl.prototype={setupCamera:function(){let l=this.map.transform;this.camera.aspect=l.width/l.height,this.halfFov=l._fov/2,this.cameraToCenterDistance=.5/Math.tan(this.halfFov)*l.height;let _=l._maxPitch*Math.PI/180;this.acuteAngle=Math.PI/2-_,this.updateCamera()},updateCamera:function(l){if(!this.camera){console.log("nocamera");return}let _=this.map.transform;this.camera.aspect=_.width/_.height;let M=_.centerOffset||new yn.Vector3,b=0,P=0;this.halfFov=_._fov/2;let H=Math.PI/2+_._pitch,W=Math.cos(Math.PI/2-_._pitch);this.cameraToCenterDistance=.5/Math.tan(this.halfFov)*_.height;let Z=1,Se=this.worldSize();if(this.map.tb.mapboxVersion>=2){Z=this.mercatorZfromAltitude(1,_.center.lat)*Se;let it=_._fov*(.5+_.centerOffset.y/_.height),he=_.elevation?_.elevation.getMinElevationBelowMSL()*Z:0,ze=(_._camera.position[2]*Se-he)/Math.cos(_._pitch),We=Math.sin(it)*ze/Math.sin(Cl.clamp(Math.PI-H-it,.01,Math.PI-.01));P=W*We+ze;let j=ze*(1/_._horizonShift);b=Math.min(P*1.01,j)}else{let it=Math.sin(this.halfFov)*this.cameraToCenterDistance/Math.sin(Math.PI-H-this.halfFov);P=W*it+this.cameraToCenterDistance,b=P*1.01}this.cameraTranslateZ=new yn.Matrix4().makeTranslation(0,0,this.cameraToCenterDistance);let ve=_.height/50,ie=Math.max(ve*W,ve),Y=_.height,Ge=_.width;this.camera instanceof yn.OrthographicCamera?this.camera.projectionMatrix=Cl.makeOrthographicMatrix(Ge/-2,Ge/2,Y/2,Y/-2,ie,b):this.camera.projectionMatrix=Cl.makePerspectiveMatrix(_._fov,Ge/Y,ie,b),this.camera.projectionMatrix.elements[8]=-M.x*2/_.width,this.camera.projectionMatrix.elements[9]=M.y*2/_.height;let qe=this.calcCameraMatrix(_._pitch,_.angle);_.elevation&&(qe.elements[14]=_._camera.position[2]*Se),this.camera.matrixWorld.copy(qe);let He=_.scale*this.state.worldSizeRatio,yt=new yn.Matrix4,Rt=new yn.Matrix4,xt=new yn.Matrix4;yt.makeScale(He,He,He);let Tt=_.x||_.point.x,Ve=_.y||_.point.y;Rt.makeTranslation(-Tt,Ve,0),xt.makeRotationZ(Math.PI),this.world.matrix=new yn.Matrix4().premultiply(xt).premultiply(this.state.translateCenter).premultiply(yt).premultiply(Rt),this.map.fire("CameraSynced",{detail:{nearZ:ie,farZ:b,pitch:_._pitch,angle:_.angle,furthestDistance:P,cameraToCenterDistance:this.cameraToCenterDistance,t:this.map.transform,tbProjMatrix:this.camera.projectionMatrix.elements,tbWorldMatrix:this.world.matrix.elements,cameraSyn:Pl}})},worldSize(){let l=this.map.transform;return l.tileSize*l.scale},worldSizeFromZoom(){let l=this.map.transform;return Math.pow(2,l.zoom)*l.tileSize},mercatorZfromAltitude(l,_){return l/this.circumferenceAtLatitude(_)},mercatorZfromZoom(){return this.cameraToCenterDistance/this.worldSizeFromZoom()},circumferenceAtLatitude(l){return fr.EARTH_CIRCUMFERENCE*Math.cos(l*Math.PI/180)},calcCameraMatrix(l,_,M){let b=this.map.transform,P=l===void 0?b._pitch:l,H=_===void 0?b.angle:_,W=M===void 0?this.cameraTranslateZ:M;return new yn.Matrix4().premultiply(W).premultiply(new yn.Matrix4().makeRotationX(P)).premultiply(new yn.Matrix4().makeRotationZ(H))},updateCameraState(){let l=this.map.transform;if(!l.height)return;let _=l._camera.forward(),M=l.cameraToCenterDistance,b=l.point,P=l._cameraZoom?l._cameraZoom:l._zoom,W=this.mercatorZfromZoom(l)-this.mercatorZfromAltitude(l._centerAltitude,l.center.lat),Z=l.cameraToCenterDistance/W;return[b.x/this.worldSize()-_[0]*M/Z,b.y/this.worldSize()-_[1]*M/Z,this.mercatorZfromAltitude(l._centerAltitude,l._center.lat)+-_[2]*M/Z]},getWorldToCamera(l,_){let M=this.map.transform,b=new yn.Matrix4,P=new yn.Matrix4,H=M._camera._orientation,W=M._camera.position,Z=new yn.Vector3(W[0],W[1],W[2]),Se=new yn.Quaternion;Se.set(H[0],H[1],H[2],H[3]);let ve=Se.conjugate();return Z.multiplyScalar(-l),P.makeTranslation(Z.x,Z.y,Z.z),b.makeRotationFromQuaternion(ve).premultiply(P),b.elements[1]*=-1,b.elements[5]*=-1,b.elements[9]*=-1,b.elements[13]*=-1,b.elements[8]*=_,b.elements[9]*=_,b.elements[10]*=_,b.elements[11]*=_,b},translate(l,_,M){let b=M[0]||M.x,P=M[1]||M.y,H=M[2]||M.z,W,Z,Se,ve,ie,Y,Ge,qe,He,yt,Rt,xt;return _===l?(l[12]=_[0]*b+_[4]*P+_[8]*H+_[12],l[13]=_[1]*b+_[5]*P+_[9]*H+_[13],l[14]=_[2]*b+_[6]*P+_[10]*H+_[14],l[15]=_[3]*b+_[7]*P+_[11]*H+_[15]):(W=_[0],Z=_[1],Se=_[2],ve=_[3],ie=_[4],Y=_[5],Ge=_[6],qe=_[7],He=_[8],yt=_[9],Rt=_[10],xt=_[11],l[0]=W,l[1]=Z,l[2]=Se,l[3]=ve,l[4]=ie,l[5]=Y,l[6]=Ge,l[7]=qe,l[8]=He,l[9]=yt,l[10]=Rt,l[11]=xt,l[12]=W*b+ie*P+He*H+_[12],l[13]=Z*b+Y*P+yt*H+_[13],l[14]=Se*b+Ge*P+Rt*H+_[14],l[15]=ve*b+qe*P+xt*H+_[15]),l}};ku.exports=Gu=Pl});var Dl=Ht((Wu,qu)=>{(function(){"use strict";var l=Math.PI,_=Math.sin,M=Math.cos,b=Math.tan,P=Math.asin,H=Math.atan2,W=Math.acos,Z=l/180,Se=1e3*60*60*24,ve=2440588,ie=2451545;function Y(Oe){return Oe.valueOf()/Se-.5+ve}function Ge(Oe){return new Date((Oe+.5-ve)*Se)}function qe(Oe){return Y(Oe)-ie}var He=Z*23.4397;function yt(Oe,Ze){return H(_(Oe)*M(He)-b(Ze)*_(He),M(Oe))}function Rt(Oe,Ze){return P(_(Ze)*M(He)+M(Ze)*_(He)*_(Oe))}function xt(Oe,Ze,tt){return H(_(Oe),M(Oe)*_(Ze)-b(tt)*M(Ze))}function Tt(Oe,Ze,tt){return P(_(Ze)*_(tt)+M(Ze)*M(tt)*M(Oe))}function Ve(Oe,Ze){return Z*(280.16+360.9856235*Oe)-Ze}function it(Oe){return Oe<0&&(Oe=0),2967e-7/Math.tan(Oe+.00312536/(Oe+.08901179))}function he(Oe){return Z*(357.5291+.98560028*Oe)}function ze(Oe){var Ze=Z*(1.9148*_(Oe)+.02*_(2*Oe)+3e-4*_(3*Oe)),tt=Z*102.9372;return Oe+Ze+tt+l}function We(Oe){var Ze=he(Oe),tt=ze(Ze);return{dec:Rt(tt,0),ra:yt(tt,0)}}var j={};j.getPosition=function(Oe,Ze,tt){var Ft=Z*-tt,At=Z*Ze,Ct=qe(Oe),vt=We(Ct),Vt=Ve(Ct,Ft)-vt.ra;return{azimuth:xt(Vt,At,vt.dec),altitude:Tt(Vt,At,vt.dec)}},j.toJulian=function(Oe){return Y(Oe)};var U=j.times=[[-.833,"sunrise","sunset"],[-.3,"sunriseEnd","sunsetStart"],[-6,"dawn","dusk"],[-12,"nauticalDawn","nauticalDusk"],[-18,"nightEnd","night"],[6,"goldenHourEnd","goldenHour"]];j.addTime=function(Oe,Ze,tt){U.push([Oe,Ze,tt])};var Ae=9e-4;function Qe(Oe,Ze){return Math.round(Oe-Ae-Ze/(2*l))}function dt(Oe,Ze,tt){return Ae+(Oe+Ze)/(2*l)+tt}function Gt(Oe,Ze,tt){return ie+Oe+.0053*_(Ze)-.0069*_(2*tt)}function Qt(Oe,Ze,tt){return W((_(Oe)-_(Ze)*_(tt))/(M(Ze)*M(tt)))}function kt(Oe){return-2.076*Math.sqrt(Oe)/60}function Mn(Oe,Ze,tt,Ft,At,Ct,vt){var Vt=Qt(Oe,tt,Ft),hn=dt(Vt,Ze,At);return Gt(hn,Ct,vt)}j.getTimes=function(Oe,Ze,tt,Ft){Ft=Ft||0;var At=Z*-tt,Ct=Z*Ze,vt=kt(Ft),Vt=qe(Oe),hn=Qe(Vt,At),vn=dt(0,At,hn),En=he(vn),An=ze(En),Gn=Rt(An,0),xe=Gt(vn,En,An),T,E,N,R,z,G,V={solarNoon:Ge(xe),nadir:Ge(xe-.5)};for(T=0,E=U.length;T<E;T+=1)N=U[T],R=(N[0]+vt)*Z,z=Mn(R,At,Ct,Gn,hn,En,An),G=xe-(z-xe),V[N[1]]=Ge(G),V[N[2]]=Ge(z);return V};function Bn(Oe){var Ze=Z*(218.316+13.176396*Oe),tt=Z*(134.963+13.064993*Oe),Ft=Z*(93.272+13.22935*Oe),At=Ze+Z*6.289*_(tt),Ct=Z*5.128*_(Ft),vt=385001-20905*M(tt);return{ra:yt(At,Ct),dec:Rt(At,Ct),dist:vt}}j.getMoonPosition=function(Oe,Ze,tt){var Ft=Z*-tt,At=Z*Ze,Ct=qe(Oe),vt=Bn(Ct),Vt=Ve(Ct,Ft)-vt.ra,hn=Tt(Vt,At,vt.dec),vn=H(_(Vt),b(At)*M(vt.dec)-_(vt.dec)*M(Vt));return hn=hn+it(hn),{azimuth:xt(Vt,At,vt.dec),altitude:hn,distance:vt.dist,parallacticAngle:vn}},j.getMoonIllumination=function(Oe){var Ze=qe(Oe||new Date),tt=We(Ze),Ft=Bn(Ze),At=149598e3,Ct=W(_(tt.dec)*_(Ft.dec)+M(tt.dec)*M(Ft.dec)*M(tt.ra-Ft.ra)),vt=H(At*_(Ct),Ft.dist-At*M(Ct)),Vt=H(M(tt.dec)*_(tt.ra-Ft.ra),_(tt.dec)*M(Ft.dec)-M(tt.dec)*_(Ft.dec)*M(tt.ra-Ft.ra));return{fraction:(1+M(vt))/2,phase:.5+.5*vt*(Vt<0?-1:1)/Math.PI,angle:Vt}};function Zt(Oe,Ze){return new Date(Oe.valueOf()+Ze*Se/24)}j.getMoonTimes=function(Oe,Ze,tt,Ft){var At=new Date(Oe);Ft?At.setUTCHours(0,0,0,0):At.setHours(0,0,0,0);for(var Ct=.133*Z,vt=j.getMoonPosition(At,Ze,tt).altitude-Ct,Vt,hn,vn,En,An,Gn,xe,T,E,N,R,z,G,V=1;V<=24&&(Vt=j.getMoonPosition(Zt(At,V),Ze,tt).altitude-Ct,hn=j.getMoonPosition(Zt(At,V+1),Ze,tt).altitude-Ct,An=(vt+hn)/2-Vt,Gn=(hn-vt)/2,xe=-Gn/(2*An),T=(An*xe+Gn)*xe+Vt,E=Gn*Gn-4*An*Vt,N=0,E>=0&&(G=Math.sqrt(E)/(Math.abs(An)*2),R=xe-G,z=xe+G,Math.abs(R)<=1&&N++,Math.abs(z)<=1&&N++,R<-1&&(R=z)),N===1?vt<0?vn=V+R:En=V+R:N===2&&(vn=V+(T<0?z:R),En=V+(T<0?R:z)),!(vn&&En));V+=2)vt=hn;var k={};return vn&&(k.rise=Zt(At,vn)),En&&(k.set=Zt(At,En)),!vn&&!En&&(k[T>0?"alwaysUp":"alwaysDown"]=!0),k},qu.exports=Wu=j})()});var Cs=Ht((Xu,Zu)=>{var xm=Tn(),ju=mn(),Il={material:"MeshBasicMaterial",color:"black",opacity:1};function _m(l){var _;l?(l=xm._validate(l,Il),l.material&&l.material.isMaterial?_=l.material:l.material||l.color||l.opacity?_=new ju[l.material]({color:l.color,transparent:l.opacity<1}):_=M(),_.opacity=l.opacity,l.side&&(_.side=l.side)):_=M();function M(){return new ju[Il.material]({color:Il.color})}return _}Zu.exports=Xu=_m});var Qu=Ht((Ju,Ku)=>{var mr=mn(),Nn=Tn();function Yu(l){this.map=l,this.enrolledObjects=[],this.previousFrameTime}Yu.prototype={unenroll:function(l){this.enrolledObjects.splice(this.enrolledObjects.indexOf(l),1)},enroll:function(l){if(l.clock=new mr.Clock,l.hasDefaultAnimation=!1,l.defaultAction,l.actions=[],l.mixer,l.animations&&l.animations.length>0){l.hasDefaultAnimation=!0;let b=l.userData.defaultAnimation?l.userData.defaultAnimation:0;l.mixer=new mr.AnimationMixer(l),_(b)}function _(b){for(let P=0;P<l.animations.length;P++){b>l.animations.length&&console.log("The animation index "+b+" doesn't exist for this object");let H=l.animations[P],W=l.mixer.clipAction(H);l.actions.push(W),b===P?(l.defaultAction=W,W.setEffectiveWeight(1)):W.setEffectiveWeight(0),W.play()}}let M=!1;Object.defineProperty(l,"isPlaying",{get(){return M},set(b){M!=b&&(M=b,l.dispatchEvent({type:"IsPlayingChanged",detail:l}))}}),this.enrolledObjects.push(l),l.animationQueue=[],l.set=function(b){if(b.duration>0){let P={start:Date.now(),expiration:Date.now()+b.duration,endState:{}};Nn.extend(b,P);let H=b.coords,W=b.rotation,Z=b.scale||b.scaleX||b.scaleY||b.scaleZ;if(W){let ve=l.rotation;b.startRotation=[ve.x,ve.y,ve.z],b.endState.rotation=Nn.types.rotation(b.rotation,b.startRotation),b.rotationPerMs=b.endState.rotation.map(function(ie,Y){return(ie-b.startRotation[Y])/b.duration})}if(Z){let ve=l.scale;b.startScale=[ve.x,ve.y,ve.z],b.endState.scale=Nn.types.scale(b.scale,b.startScale),b.scalePerMs=b.endState.scale.map(function(ie,Y){return(ie-b.startScale[Y])/b.duration})}H&&(b.pathCurve=new mr.CatmullRomCurve3(Nn.lnglatsToWorld([l.coordinates,b.coords])));let Se={type:"set",parameters:b};this.animationQueue.push(Se),tb.map.repaint=!0}else this.stop(),b.rotation=Nn.radify(b.rotation),this._setObject(b);return this},l.animationMethod=null,l.stop=function(b){return l.mixer&&(l.isPlaying=!1,cancelAnimationFrame(l.animationMethod)),this.animationQueue=[],this},l.followPath=function(b,P){let H={type:"followPath",parameters:Nn._validate(b,bm.followPath)};return Nn.extend(H.parameters,{pathCurve:new mr.CatmullRomCurve3(Nn.lnglatsToWorld(b.path)),start:Date.now(),expiration:Date.now()+H.parameters.duration,cb:P}),this.animationQueue.push(H),tb.map.repaint=!0,this},l._setObject=function(b){l.setScale();let P=b.position,H=b.rotation,W=b.scale,Z=b.worldCoordinates,Se=b.quaternion,ve=b.translate,ie=b.worldTranslate;if(P){this.coordinates=P;let Ge=Nn.projectToWorld(P);this.position.copy(Ge)}if(ve){this.coordinates=[this.coordinates[0]+ve[0],this.coordinates[1]+ve[1],this.coordinates[2]+ve[2]];let Ge=Nn.projectToWorld(ve);this.position.copy(Ge),b.position=this.coordinates}if(ie){this.translateX(ie.x),this.translateY(ie.y),this.translateZ(ie.z);let Ge=Nn.unprojectFromWorld(this.position);this.coordinates=b.position=Ge}if(H&&(this.rotation.set(H[0],H[1],H[2]),b.rotation=new mr.Vector3(H[0],H[1],H[2])),W&&(this.scale.set(W[0],W[1],W[2]),b.scale=this.scale),Se&&(this.quaternion.setFromAxisAngle(Se[0],Se[1]),b.rotation=Se[0].multiplyScalar(Se[1])),Z){this.position.copy(Z);let Ge=Nn.unprojectFromWorld(Z);this.coordinates=b.position=Ge}this.setBoundingBoxShadowFloor(),this.setReceiveShadowFloor(),this.updateMatrixWorld(),tb.map.repaint=!0;let Y={type:"ObjectChanged",detail:{object:this,action:{position:b.position,rotation:b.rotation,scale:b.scale}}};this.dispatchEvent(Y)},l.playDefault=function(b){if(l.mixer&&l.hasDefaultAnimation){let P={start:Date.now(),expiration:Date.now()+b.duration,endState:{}};Nn.extend(b,P),l.mixer.timeScale=b.speed||1;let H={type:"playDefault",parameters:b};return this.animationQueue.push(H),tb.map.repaint=!0,this}},l.playAnimation=function(b){l.mixer&&(b.animation&&_(b.animation),l.playDefault(b))},l.pauseAllActions=function(){l.mixer&&l.actions.forEach(function(b){b.paused=!0})},l.unPauseAllActions=function(){l.mixer&&l.actions.forEach(function(b){b.paused=!1})},l.deactivateAllActions=function(){l.mixer&&l.actions.forEach(function(b){b.stop()})},l.activateAllActions=function(){l.mixer&&l.actions.forEach(function(b){b.play()})},l.idle=function(){return l.mixer&&l.mixer.update(.01),tb.map.repaint=!0,this}},update:function(l){this.previousFrameTime===void 0&&(this.previousFrameTime=l);let _=["X","Y","Z"];if(!this.enrolledObjects)return!1;for(let M=this.enrolledObjects.length-1;M>=0;M--){let b=this.enrolledObjects[M];if(!(!b.animationQueue||b.animationQueue.length===0))for(let P=b.animationQueue.length-1;P>=0;P--){let H=b.animationQueue[P];if(!H)continue;let W=H.parameters;if(!W.expiration){b.animationQueue.splice(P,1),b.animationQueue[P]&&(b.animationQueue[P].parameters.start=l);return}if(l>=W.expiration)W.expiration=!1,H.type==="playDefault"?b.stop():(W.endState&&b._setObject(W.endState),typeof W.cb<"u"&&W.cb());else{let Se=(l-W.start)/W.duration;if(H.type==="set"){let ve={};W.pathCurve&&(ve.worldCoordinates=W.pathCurve.getPoint(Se)),W.rotationPerMs&&(ve.rotation=W.startRotation.map(function(ie,Y){return ie+W.rotationPerMs[Y]*Se*W.duration})),W.scalePerMs&&(ve.scale=W.startScale.map(function(ie,Y){return ie+W.scalePerMs[Y]*Se*W.duration})),b._setObject(ve)}if(H.type==="followPath"){let ie={worldCoordinates:W.pathCurve.getPointAt(Se)};if(W.trackHeading){let Y=W.pathCurve.getTangentAt(Se).normalize(),Ge=new mr.Vector3(0,0,0),qe=new mr.Vector3(0,1,0);Ge.crossVectors(qe,Y).normalize();let He=Math.acos(qe.dot(Y));ie.quaternion=[Ge,He]}b._setObject(ie)}H.type==="playDefault"&&(b.activateAllActions(),b.isPlaying=!0,b.animationMethod=requestAnimationFrame(this.update),b.mixer.update(b.clock.getDelta()),tb.map.repaint=!0)}}}this.previousFrameTime=l}};var bm={followPath:{path:null,duration:1e3,trackHeading:!0}};Ku.exports=Ju=Yu});var Ps=Ht(($u,ed)=>{var ci=mn();(function(){class l extends ci.Object3D{constructor(Se){super(),this.element=Se||document.createElement("div"),this.element.style.position="absolute",this.element.style.userSelect="none",this.element.setAttribute("draggable",!1),this.alwaysVisible=!1,Object.defineProperty(this,"layer",{get(){return this.parent&&this.parent.parent?this.parent.parent.layer:null}}),this.dispose=function(){this.remove(),this.element=null},this.remove=function(){this.element instanceof Element&&this.element.parentNode!==null&&this.element.parentNode.removeChild(this.element)},this.addEventListener("removed",function(){this.remove()})}copy(Se,ve){return super.copy(Se,ve),this.element=Se.element.cloneNode(!0),this}}l.prototype.isCSS2DObject=!0;let _=new ci.Vector3,M=new ci.Matrix4,b=new ci.Matrix4,P=new ci.Vector3,H=new ci.Vector3;class W{constructor(){let Se=this,ve,ie,Y,Ge,qe={objects:new WeakMap,list:new Map};this.cacheList=qe.list;let He=document.createElement("div");He.style.overflow="hidden",this.domElement=He,this.getSize=function(){return{width:ve,height:ie}},this.render=function(Ve,it){Ve.autoUpdate===!0&&Ve.updateMatrixWorld(),it.parent===null&&it.updateMatrixWorld(),M.copy(it.matrixWorldInverse),b.multiplyMatrices(it.projectionMatrix,M),yt(Ve,Ve,it),Tt(Ve)},this.setSize=function(Ve,it){ve=Ve,ie=it,Y=ve/2,Ge=ie/2,He.style.width=Ve+"px",He.style.height=it+"px"};function yt(Ve,it,he){if(Ve.isCSS2DObject)if(!Ve.visible)qe.objects.delete({key:Ve.uuid}),qe.list.delete(Ve.uuid),Ve.remove();else{Ve.onBeforeRender(Se,it,he),_.setFromMatrixPosition(Ve.matrixWorld),_.applyMatrix4(b);let We=Ve.element;var ze;/apple/i.test(navigator.vendor)?ze="translate(-50%,-50%) translate("+Math.round(_.x*Y+Y)+"px,"+Math.round(-_.y*Ge+Ge)+"px)":ze="translate(-50%,-50%) translate("+(_.x*Y+Y)+"px,"+(-_.y*Ge+Ge)+"px)",We.style.WebkitTransform=ze,We.style.MozTransform=ze,We.style.oTransform=ze,We.style.transform=ze,We.style.display=Ve.visible&&_.z>=-1&&_.z<=1?"":"none";let j={distanceToCameraSquared:Rt(he,Ve)};qe.objects.set({key:Ve.uuid},j),qe.list.set(Ve.uuid,Ve),We.parentNode!==He&&He.appendChild(We),Ve.onAfterRender(Se,it,he)}for(let We=0,j=Ve.children.length;We<j;We++)yt(Ve.children[We],it,he)}function Rt(Ve,it){return P.setFromMatrixPosition(Ve.matrixWorld),H.setFromMatrixPosition(it.matrixWorld),P.distanceToSquared(H)}function xt(Ve){let it=[];return Ve.traverse(function(he){he.isCSS2DObject&&it.push(he)}),it}function Tt(Ve){let it=xt(Ve).sort(function(ze,We){let j=qe.objects.get({key:ze.uuid}),U=qe.objects.get({key:We.uuid});if(j&&U){let Ae=j.distanceToCameraSquared,Qe=U.distanceToCameraSquared;return Ae-Qe}}),he=it.length;for(let ze=0,We=it.length;ze<We;ze++)it[ze].element.style.zIndex=he-ze}}}ci.CSS2DObject=l,ci.CSS2DRenderer=W})();ed.exports=$u={CSS2DRenderer:ci.CSS2DRenderer,CSS2DObject:ci.CSS2DObject}});var hi=Ht((td,nd)=>{var zn=Tn(),Bg=Cs(),St=mn(),Mm=Qu(),wm=Ps();function Ui(){}Ui.prototype={line:function(l){l=zn._validate(l,this._defaults.line);var _=zn.lnglatsToWorld(l.geometry),M=zn.normalizeVertices(_),b=zn.flattenVectors(M.vertices),P=new Float32Array(b),H=new St.BufferGeometry;H.setAttribute("position",new St.BufferAttribute(P,3));var W=new St.LineBasicMaterial({color:16711680,linewidth:21}),Z=new St.Line(H,W);return Z.options=options||{},Z.position.copy(M.position),Z},extrusion:function(l){},unenroll:function(l,_){var M=this;_||M.animationManager.unenroll(l)},_addMethods:function(l,_){var M=this;let b="label",P="tooltip",H="help",W="shadowPlane";if(!_){let Y=function(j,U,Ae,Qe){let dt=zn.radify(Qe);j.position.sub(U),j.position.applyAxisAngle(Ae,dt),j.position.add(U),j.rotateOnAxis(Ae,dt),tb.map.repaint=!0},We=function(j){return Math.pow(2,j)};var Se=Y,ve=We;l.coordinates||(l.coordinates=[0,0,0]),Object.defineProperty(l,"model",{get(){return l.getObjectByName("model")}});let ie;Object.defineProperty(l,"animations",{get(){let j=l.model;return j?j.animations:null}}),M.animationManager.enroll(l),l.setCoords=function(j){return l.userData.topMargin&&l.userData.feature&&(j[2]+=((l.userData.feature.properties.height||0)-(l.userData.feature.properties.base_height||l.userData.feature.properties.min_height||0))*(l.userData.topMargin||0)),l.coordinates=j,l.set({position:j}),l},l.setTranslate=function(j){return l.set({translate:j}),l},l.setRotation=function(j){typeof j=="number"&&(j={z:j});var U={x:zn.radify(j.x)??l.rotation.x,y:zn.radify(j.y)??l.rotation.y,z:zn.radify(j.z)??l.rotation.z};l._setObject({rotation:[U.x,U.y,U.z]})},l.calculateAdjustedPosition=function(j,U,Ae){let Qe=j.slice(),dt=zn.unprojectFromWorld(l.modelSize);return Ae?(Qe[0]-=U.x!=0?dt[0]/U.x:0,Qe[1]-=U.y!=0?dt[1]/U.y:0,Qe[2]-=U.z!=0?dt[2]/U.z:0):(Qe[0]+=U.x!=0?dt[0]/U.x:0,Qe[1]+=U.y!=0?dt[1]/U.y:0,Qe[2]+=U.z!=0?dt[2]/U.z:0),Qe},l.setRotationAxis=function(j){typeof j=="number"&&(j={z:j});let U=l.modelBox(),Ae=new St.Vector3(U.max.x,U.max.y,U.min.z);j.x!=0&&Y(l,Ae,new St.Vector3(0,0,1),j.x),j.y!=0&&Y(l,Ae,new St.Vector3(0,0,1),j.y),j.z!=0&&Y(l,Ae,new St.Vector3(0,0,1),j.z)},Object.defineProperty(l,"scaleGroup",{get(){return l.getObjectByName("scaleGroup")}}),Object.defineProperty(l,"boxGroup",{get(){return l.getObjectByName("boxGroup")}}),Object.defineProperty(l,"boundingBox",{get(){return l.getObjectByName("boxModel")}});let Ge;Object.defineProperty(l,"boundingBoxShadow",{get(){return l.getObjectByName("boxShadow")}}),l.drawBoundingBox=function(){let j=l.box3(),U=new St.Group;U.name="boxGroup",U.updateMatrixWorld(!0);let Ae=new St.Box3Helper(j,Ui.prototype._defaults.colors.yellow);Ae.name="boxModel",U.add(Ae),Ae.layers.disable(0);let Qe=j.clone();Qe.max.z=Qe.min.z;let dt=new St.Box3Helper(Qe,Ui.prototype._defaults.colors.black);dt.name="boxShadow",U.add(dt),dt.layers.disable(0),U.visible=!1,l.scaleGroup.add(U),l.setBoundingBoxShadowFloor()},l.setBoundingBoxShadowFloor=function(){if(l.boundingBoxShadow){let j=-l.modelHeight,U=l.rotation,Ae=l.boundingBoxShadow;Ae.box.max.z=Ae.box.min.z=j,Ae.rotation.y=U.y,Ae.rotation.x=-U.x}},l.setAnchor=function(j){let U=l.box3(),Ae=U.getCenter(new St.Vector3);switch(l.none={x:0,y:0,z:0},l.center={x:Ae.x,y:Ae.y,z:U.min.z},l.bottom={x:Ae.x,y:U.max.y,z:U.min.z},l.bottomLeft={x:U.max.x,y:U.max.y,z:U.min.z},l.bottomRight={x:U.min.x,y:U.max.y,z:U.min.z},l.top={x:Ae.x,y:U.min.y,z:U.min.z},l.topLeft={x:U.max.x,y:U.min.y,z:U.min.z},l.topRight={x:U.min.x,y:U.min.y,z:U.min.z},l.left={x:U.max.x,y:Ae.y,z:U.min.z},l.right={x:U.min.x,y:Ae.y,z:U.min.z},j){case"center":l.anchor=l.center;break;case"top":l.anchor=l.top;break;case"top-left":l.anchor=l.topLeft;break;case"top-right":l.anchor=l.topRight;break;case"left":l.anchor=l.left;break;case"right":l.anchor=l.right;break;case"bottom":l.anchor=l.bottom;break;case"bottom-left":default:l.anchor=l.bottomLeft;break;case"bottom-right":l.anchor=l.bottomRight;break;case"auto":case"none":l.anchor=l.none}l.model.position.set(-l.anchor.x,-l.anchor.y,-l.anchor.z)},l.setCenter=function(j){if(j&&(j.x!=0||j.y!=0||j.z!=0)){let U=l.getSize();l.anchor={x:l.anchor.x-U.x*j.x,y:l.anchor.y-U.y*j.y,z:l.anchor.z-U.z*j.z},l.model.position.set(-l.anchor.x,-l.anchor.y,-l.anchor.z)}},Object.defineProperty(l,"label",{get(){return l.getObjectByName(b)}}),Object.defineProperty(l,"tooltip",{get(){return l.getObjectByName(P)}}),Object.defineProperty(l,"help",{get(){return l.getObjectByName(H)}});let qe=!1;Object.defineProperty(l,"hidden",{get(){return qe},set(j){qe!=j&&(qe=j,l.visibility=!qe)}}),Object.defineProperty(l,"visibility",{get(){return l.visible},set(j){let U=j;if(j=="visible"||j==!0)U=!0,l.label&&(l.label.visible=U);else if(j=="none"||j==!1)U=!1,l.label&&l.label.alwaysVisible&&(l.label.visible=U),l.tooltip&&(l.tooltip.visible=U);else return;if(l.visible!=U){if(l.hidden&&U)return;l.visible=U,l.model&&l.model.traverse(function(Ae){(Ae.type=="Mesh"||Ae.type=="SkinnedMesh")&&(U&&l.raycasted?Ae.layers.enable(0):Ae.layers.disable(0)),Ae.type=="LineSegments"&&Ae.layers.disableAll()})}}}),l.addLabel=function(j,U,Ae,Qe){j&&l.drawLabelHTML(j,U,Ae,Qe)},l.removeLabel=function(){l.removeCSS2D(b)},l.drawLabelHTML=function(j,U=!1,Ae=l.anchor,Qe=.5){let dt=M.drawLabelHTML(j,Ui.prototype._defaults.label.cssClass),Gt=l.addCSS2D(dt,b,Ae,Qe);return Gt.alwaysVisible=U,Gt.visible=U,Gt},l.addTooltip=function(j,U,Ae,Qe=!0,dt=1){let Gt=l.addHelp(j,P,U,Ae,dt);Gt.visible=!1,Gt.custom=Qe},l.removeTooltip=function(){l.removeCSS2D(P)},l.addHelp=function(j,U=H,Ae=!1,Qe=l.anchor,dt=0){let Gt=M.drawTooltip(j,Ae),Qt=l.addCSS2D(Gt,U,Qe,dt);return Qt.visible=!0,Qt},l.removeHelp=function(){l.removeCSS2D(H)},l.addCSS2D=function(j,U,Ae=l.anchor,Qe=1){if(j){let dt=l.box3(),Gt=dt.getSize(new St.Vector3),Qt={x:dt.max.x,y:dt.max.y,z:dt.min.z};l.removeCSS2D(U);let kt=new wm.CSS2DObject(j);return kt.name=U,kt.position.set(-Gt.x*.5-l.model.position.x-Ae.x+Qt.x,-Gt.y*.5-l.model.position.y-Ae.y+Qt.y,Gt.z*Qe),kt.visible=!1,l.scaleGroup.add(kt),kt}},l.removeCSS2D=function(j){let U=l.getObjectByName(j);if(U){U.dispose();let Ae=l.scaleGroup.children;Ae.splice(Ae.indexOf(U),1)}},Object.defineProperty(l,"shadowPlane",{get(){return l.getObjectByName(W)}});let He=!1;Object.defineProperty(l,"castShadow",{get(){return He},set(j){!l.model||He===j||(l.model.traverse(function(U){U.isMesh&&(U.castShadow=!0)}),j&&tb.createShadowLayer(),He=j)}}),l.setReceiveShadowFloor=function(){l.castShadow};let yt=!1;Object.defineProperty(l,"receiveShadow",{get(){return yt},set(j){!l.model||yt===j||(l.model.traverse(function(U){U.isMesh&&(U.receiveShadow=!0)}),yt=j)}});let Rt=!1;Object.defineProperty(l,"wireframe",{get(){return Rt},set(j){!l.model||Rt===j||(l.model.traverse(function(U){if(U.type=="Mesh"||U.type=="SkinnedMesh"){let Ae=[];Array.isArray(U.material)?Ae=U.material:Ae.push(U.material);let Qe=Ae[0];j?(U.userData.materials=Qe,U.material=Qe.clone(),U.material.wireframe=U.material.transparent=j,U.material.opacity=.3):(U.material.dispose(),U.material=U.userData.materials,U.userData.materials.dispose(),U.userData.materials=null),j?(U.layers.disable(0),U.layers.enable(1)):(U.layers.disable(1),U.layers.enable(0))}U.type=="LineSegments"&&U.layers.disableAll()}),Rt=j,l.dispatchEvent({type:"Wireframed",detail:l}))}});let xt=null;Object.defineProperty(l,"color",{get(){return xt},set(j){!l.model||xt===j||(l.model.traverse(function(U){if(U.type=="Mesh"||U.type=="SkinnedMesh"){let Ae=[];Array.isArray(U.material)?Ae=U.material:Ae.push(U.material);let Qe=Ae[0];j?(U.userData.materials=Qe,U.material=new St.MeshStandardMaterial,U.material.color.setHex(j)):(U.material.dispose(),U.material=U.userData.materials,U.userData.materials.dispose(),U.userData.materials=null)}}),xt=j)}});let Tt=!1;Object.defineProperty(l,"selected",{get(){return Tt},set(j){j?(l.userData.bbox&&!l.boundingBox&&l.drawBoundingBox(),l.boxGroup&&(l.boundingBox.material=Ui.prototype._defaults.materials.boxSelectedMaterial,l.boundingBox.parent.visible=!0,l.boundingBox.layers.enable(1),l.boundingBoxShadow.layers.enable(1)),l.label&&!l.label.alwaysVisible&&(l.label.visible=!0)):(l.boxGroup&&l.remove(l.boxGroup),l.label&&!l.label.alwaysVisible&&(l.label.visible=!1),l.removeHelp()),l.tooltip&&(l.tooltip.visible=j),Tt!=j&&(Tt=j,l.dispatchEvent({type:"SelectedChange",selected:Tt,detail:l}))}});let Ve=!0;Object.defineProperty(l,"raycasted",{get(){return Ve},set(j){!l.model||Ve===j||(l.model.traverse(function(U){(U.type=="Mesh"||U.type=="SkinnedMesh")&&(j?(U.layers.disable(1),U.layers.enable(0)):(U.layers.disable(0),U.layers.enable(1)))}),Ve=j)}});let it=!1;Object.defineProperty(l,"over",{get(){return it},set(j){j?(l.selected||(l.userData.bbox&&!l.boundingBox&&l.drawBoundingBox(),l.userData.tooltip&&!l.tooltip&&l.addTooltip(l.uuid,!0,l.anchor,!1),l.boxGroup&&(l.boundingBox.material=Ui.prototype._defaults.materials.boxOverMaterial,l.boundingBox.parent.visible=!0,l.boundingBox.layers.enable(1),l.boundingBoxShadow.layers.enable(1))),l.label&&!l.label.alwaysVisible&&(l.label.visible=!0),l.dispatchEvent({type:"ObjectMouseOver",detail:l})):(l.selected||(l.boxGroup&&(l.remove(l.boxGroup),l.tooltip&&!l.tooltip.custom&&l.removeTooltip()),l.label&&!l.label.alwaysVisible&&(l.label.visible=!1)),l.dispatchEvent({type:"ObjectMouseOut",detail:l})),l.tooltip&&(l.tooltip.visible=j||l.selected),it=j}}),l.box3=function(){l.updateMatrix(),l.updateMatrixWorld(!0,!0);let j;if(l.model){let U=l.clone(!0),Ae=l.model.clone();if(j=new St.Box3().setFromObject(Ae),l.parent){let Qe=new St.Matrix4,dt=new St.Matrix4;l.matrix.extractRotation(Qe),dt.copy(Qe).invert(),U.setRotationFromMatrix(dt),j=new St.Box3().setFromObject(Ae)}}return j},l.modelBox=function(){return l.box3()},l.getSize=function(){return l.box3().getSize(new St.Vector3(0,0,0))};let he=!1;Object.defineProperty(l,"modelSize",{get(){return he=l.getSize(),he},set(j){he!=j&&(he=j)}}),Object.defineProperty(l,"modelHeight",{get(){let j=l.coordinates[2]||0;return l.userData.units==="scene"&&(j*=l.unitsPerMeter/l.scale.x),j}}),Object.defineProperty(l,"unitsPerMeter",{get(){return Number(zn.projectedUnitsPerMeter(l.coordinates[1]).toFixed(7))}});let ze=null;Object.defineProperty(l,"fixedZoom",{get(){return l.userData.fixedZoom},set(j){l.userData.fixedZoom!==j&&(l.userData.fixedZoom=j,l.userData.units=j?"scene":"meters")}}),l.setFixedZoom=function(j){if(l.fixedZoom!=null&&l.fixedZoom!=0){j||(j=l.userData.mapScale);let U=We(l.fixedZoom);if(U>j){let Ae=U/j;l.scale.set(Ae,Ae,Ae)}else l.scale.set(1,1,1)}},l.setScale=function(j){if(l.userData.units!="scene"){let U=l.unitsPerMeter;l.scale.set(U,U,U)}else l.fixedZoom?(j&&(l.userData.mapScale=j),l.setFixedZoom(l.userData.mapScale)):l.scale.set(1,1,1)},l.setObjectScale=function(j){l.setScale(j),l.setBoundingBoxShadowFloor(),l.setReceiveShadowFloor()}}l.add=function(ie){return l.scaleGroup.add(ie),ie.position.z=l.coordinates[2]?-l.coordinates[2]:0,ie},l.remove=function(ie){ie&&(ie.traverse(Y=>{if(Y.geometry&&Y.geometry.dispose(),Y.material)if(Y.material.isMaterial)Z(Y.material);else for(let Ge of Y.material)Z(Ge);Y.dispose&&Y.dispose()}),l.scaleGroup.remove(ie),tb.map.repaint=!0)},l.duplicate=function(ie){let Y=l.clone(!0);if(Y.getObjectByName("model").animations=l.animations,Y.userData.feature&&(ie&&ie.feature&&(Y.userData.feature=ie.feature),Y.userData.feature.properties.uuid=Y.uuid),M._addMethods(Y),!ie||zn.equal(ie.scale,l.userData.scale))return Y.copyAnchor(l),Y;{Y.userData=ie,Y.userData.isGeoGroup=!0,Y.remove(Y.boxGroup);let Ge=zn.types.rotation(ie.rotation,[0,0,0]),qe=zn.types.scale(ie.scale,[1,1,1]);return Y.model.position.set(0,0,0),Y.model.rotation.set(Ge[0],Ge[1],Ge[2]),Y.model.scale.set(qe[0],qe[1],qe[2]),Y.setAnchor(ie.anchor),Y.setCenter(ie.adjustment),Y}},l.copyAnchor=function(ie){l.anchor=ie.anchor,l.none={x:0,y:0,z:0},l.center=ie.center,l.bottom=ie.bottom,l.bottomLeft=ie.bottomLeft,l.bottomRight=ie.bottomRight,l.top=ie.top,l.topLeft=ie.topLeft,l.topRight=ie.topRight,l.left=ie.left,l.right=ie.right},l.dispose=function(){Ui.prototype.unenroll(l),l.traverse(ie=>{if(!(ie.parent&&ie.parent.name=="world")&&ie.name!=="threeboxObject"){if(ie.geometry&&ie.geometry.dispose(),ie.material)if(ie.material.isMaterial)Z(ie.material);else for(let Y of ie.material)Z(Y);ie.dispose&&ie.dispose()}}),l.children=[]};let Z=ie=>{ie.dispose();for(let qe of Object.keys(ie)){let He=ie[qe];He&&typeof He=="object"&&"minFilter"in He&&He.dispose()}let Y=ie;(Y.map||Y.alphaMap||Y.aoMap||Y.bumpMap||Y.displacementMap||Y.emissiveMap||Y.envMap||Y.lightMap||Y.metalnessMap||Y.normalMap||Y.roughnessMap)&&(Y.map&&Y.map.dispose(),Y.alphaMap&&Y.alphaMap.dispose(),Y.aoMap&&Y.aoMap.dispose(),Y.bumpMap&&Y.bumpMap.dispose(),Y.displacementMap&&Y.displacementMap.dispose(),Y.emissiveMap&&Y.emissiveMap.dispose(),Y.envMap&&Y.envMap.dispose(),Y.lightMap&&Y.lightMap.dispose(),Y.metalnessMap&&Y.metalnessMap.dispose(),Y.normalMap&&Y.normalMap.dispose(),Y.roughnessMap&&Y.roughnessMap.dispose())};return l},_makeGroup:function(l,_){let M=new St.Group;M.name="scaleGroup",M.add(l);var b=new St.Group;b.userData=_||{},b.userData.isGeoGroup=!0,b.userData.feature&&(b.userData.feature.properties.uuid=b.uuid);var P=M.length;if(P)for(o of M)b.add(o);else b.add(M);return b.name="threeboxObject",b},animationManager:new Mm,drawTooltip:function(l,_=!1){if(l){let M;if(_){let b=document.createElement("div");b.className="mapboxgl-popup-content";let P=document.createElement("strong");P.innerHTML=l,b.appendChild(P);let H=document.createElement("div");H.className="mapboxgl-popup-tip";let W=document.createElement("div");W.className="marker mapboxgl-popup-anchor-bottom",W.appendChild(H),W.appendChild(b),M=document.createElement("div"),M.className+="label3D",M.appendChild(W)}else M=document.createElement("span"),M.className=this._defaults.tooltip.cssClass,M.innerHTML=l;return M}},drawLabelHTML:function(l,_){let M=document.createElement("div");return M.className+=_,typeof l=="string"?M.innerHTML=l:M.innerHTML=l.outerHTML,M},_defaults:{colors:{red:new St.Color(16711680),yellow:new St.Color(16776960),green:new St.Color(65280),black:new St.Color(0)},materials:{boxNormalMaterial:new St.LineBasicMaterial({color:new St.Color(16711680)}),boxOverMaterial:new St.LineBasicMaterial({color:new St.Color(16776960)}),boxSelectedMaterial:new St.LineBasicMaterial({color:new St.Color(65280)})},line:{geometry:null,color:"black",width:1,opacity:1},label:{htmlElement:null,cssClass:" label3D",alwaysVisible:!1,topMargin:-.5},tooltip:{text:"",cssClass:"toolTip text-xs",mapboxStyle:!1,topMargin:0},sphere:{position:[0,0,0],radius:1,sides:20,units:"scene",material:"MeshBasicMaterial",anchor:"bottom-left",bbox:!0,tooltip:!0,raycasted:!0},tube:{geometry:null,radius:1,sides:6,units:"scene",material:"MeshBasicMaterial",anchor:"center",bbox:!0,tooltip:!0,raycasted:!0},loadObj:{type:null,obj:null,units:"scene",scale:1,rotation:0,defaultAnimation:0,anchor:"bottom-left",bbox:!0,tooltip:!0,raycasted:!0,clone:!0},Object3D:{obj:null,units:"scene",anchor:"bottom-left",bbox:!0,tooltip:!0,raycasted:!0},extrusion:{coordinates:[[[]]],geometryOptions:{},height:100,materials:new St.MeshPhongMaterial({color:6684672,side:St.DoubleSide}),scale:1,rotation:0,units:"scene",anchor:"center",bbox:!0,tooltip:!0,raycasted:!0}},geometries:{line:["LineString"],tube:["LineString"],sphere:["Point"]}};nd.exports=td=Ui});var Ds=Ht((id,rd)=>{var Ol=hi(),Fl=Tn();function Sm(l){l=Fl._validate(l,Ol.prototype._defaults.Object3D);let _=l.obj,M=Fl.types.rotation(l.rotation,[0,0,0]),b=Fl.types.scale(l.scale,[1,1,1]);_.rotation.set(M[0],M[1],M[2]),_.scale.set(b[0],b[1],b[2]),_.name="model";let P=Ol.prototype._makeGroup(_,l);return l.obj.name="model",Ol.prototype._addMethods(P),P.setAnchor(l.anchor),P.setCenter(l.adjustment),P.raycasted=l.raycasted,P.visibility=!0,P}rd.exports=id=Sm});var ld=Ht((ad,od)=>{var Tm=Tn(),Em=Cs(),sd=mn(),Am=hi(),Lm=Ds();function Rm(l){l=Tm._validate(l,Am.prototype._defaults.sphere);let _=new sd.SphereBufferGeometry(l.radius,l.sides,l.sides),M=Em(l),b=new sd.Mesh(_,M);return new Lm({obj:b,units:l.units,anchor:l.anchor,adjustment:l.adjustment,bbox:l.bbox,tooltip:l.tooltip,raycasted:l.raycasted})}od.exports=ad=Rm});var ud=Ht((cd,hd)=>{var Cm=hi(),Is=Tn(),Mi=mn(),Pm=Ds();function Ya(l){l=Is._validate(l,Cm.prototype._defaults.extrusion);let _=Ya.prototype.buildShape(l.coordinates),M=Ya.prototype.buildGeometry(_,l.geometryOptions),b=new Mi.Mesh(M,l.materials);return l.obj=b,new Pm(l)}Ya.prototype={buildShape:function(l){if(l[0]instanceof(Mi.Vector2||Mi.Vector3))return new Mi.Shape(l);let _=new Mi.Shape;for(let M=0;M<l.length;M++)M===0?_=new Mi.Shape(this.buildPoints(l[0],l[0])):_.holes.push(new Mi.Path(this.buildPoints(l[M],l[0])));return _},buildPoints:function(l,_){let M=[],b=Is.projectToWorld([_[0][0],_[0][1],0]);for(let P=0;P<l.length;P++){let H=Is.projectToWorld([l[P][0],l[P][1],0]);M.push(new Mi.Vector2(Is.toDecimal(H.x-b.x,9),Is.toDecimal(H.y-b.y,9)))}return M},buildGeometry:function(l,_){let M=new Mi.ExtrudeBufferGeometry(l,_);return M.computeBoundingBox(),M}};hd.exports=cd=Ya});var fd=Ht((dd,pd)=>{var Dm=Tn(),Ja=hi(),Im=Ps();function Om(l){l=Dm._validate(l,Ja.prototype._defaults.label);let _=Ja.prototype.drawLabelHTML(l.htmlElement,l.cssClass),M=new Im.CSS2DObject(_);M.name="label",M.visible=l.alwaysVisible,M.alwaysVisible=l.alwaysVisible;var b=Ja.prototype._makeGroup(M,l);return Ja.prototype._addMethods(b),b.visibility=l.alwaysVisible,b}pd.exports=dd=Om});var yd=Ht((md,gd)=>{var Fm=Tn(),Ka=hi(),Nm=Ps(),Hg=mn();function zm(l){if(l=Fm._validate(l,Ka.prototype._defaults.tooltip),l.text){let M=Ka.prototype.drawTooltip(l.text,l.mapboxStyle),b=new Nm.CSS2DObject(M);b.visible=!1,b.name="tooltip";var _=Ka.prototype._makeGroup(b,l);return Ka.prototype._addMethods(_),_}}gd.exports=md=zm});var _d=Ht((vd,xd)=>{var bn=mn();(function(){class l extends bn.Loader{constructor(b){super(b)}load(b,P,H,W){let Z=this,Se=this.path===""?bn.LoaderUtils.extractUrlBase(b||""):this.path,ve=new bn.FileLoader(this.manager);ve.setPath(this.path),ve.setRequestHeader(this.requestHeader),ve.setWithCredentials(this.withCredentials),ve.load(b,function(ie){try{P(Z.parse(ie,Se))}catch(Y){W?W(Y):console.error(Y),Z.manager.itemError(b)}},H,W)}setMaterialOptions(b){return this.materialOptions=b,this}parse(b,P){let H=b.split(`
`),W={},Z=/\s+/,Se={};for(let ie=0;ie<H.length;ie++){let Y=H[ie];if(Y=Y.trim(),Y.length===0||Y.charAt(0)==="#")continue;let Ge=Y.indexOf(" "),qe=Ge>=0?Y.substring(0,Ge):Y;qe=qe.toLowerCase();let He=Ge>=0?Y.substring(Ge+1):"";if(He=He.trim(),qe==="newmtl")W={name:He},Se[He]=W;else if(qe==="ka"||qe==="kd"||qe==="ks"||qe==="ke"){let yt=He.split(Z,3);W[qe]=[parseFloat(yt[0]),parseFloat(yt[1]),parseFloat(yt[2])]}else W[qe]=He}let ve=new _(this.resourcePath||P,this.materialOptions);return ve.setCrossOrigin(this.crossOrigin),ve.setManager(this.manager),ve.setMaterials(Se),ve}}class _{constructor(b="",P={}){this.baseUrl=b,this.options=P,this.materialsInfo={},this.materials={},this.materialsArray=[],this.nameLookup={},this.crossOrigin="anonymous",this.side=this.options.side!==void 0?this.options.side:bn.FrontSide,this.wrap=this.options.wrap!==void 0?this.options.wrap:bn.RepeatWrapping}setCrossOrigin(b){return this.crossOrigin=b,this}setManager(b){this.manager=b}setMaterials(b){this.materialsInfo=this.convert(b),this.materials={},this.materialsArray=[],this.nameLookup={}}convert(b){if(!this.options)return b;let P={};for(let H in b){let W=b[H],Z={};P[H]=Z;for(let Se in W){let ve=!0,ie=W[Se],Y=Se.toLowerCase();switch(Y){case"kd":case"ka":case"ks":this.options&&this.options.normalizeRGB&&(ie=[ie[0]/255,ie[1]/255,ie[2]/255]),this.options&&this.options.ignoreZeroRGBs&&ie[0]===0&&ie[1]===0&&ie[2]===0&&(ve=!1);break;default:break}ve&&(Z[Y]=ie)}}return P}preload(){for(let b in this.materialsInfo)this.create(b)}getIndex(b){return this.nameLookup[b]}getAsArray(){let b=0;for(let P in this.materialsInfo)this.materialsArray[b]=this.create(P),this.nameLookup[P]=b,b++;return this.materialsArray}create(b){return this.materials[b]===void 0&&this.createMaterial_(b),this.materials[b]}createMaterial_(b){let P=this,H=this.materialsInfo[b],W={name:b,side:this.side};function Z(ve,ie){return typeof ie!="string"||ie===""?"":/^https?:\/\//i.test(ie)?ie:ve+ie}function Se(ve,ie){if(W[ve])return;let Y=P.getTextureParams(ie,W),Ge=P.loadTexture(Z(P.baseUrl,Y.url));Ge.repeat.copy(Y.scale),Ge.offset.copy(Y.offset),Ge.wrapS=P.wrap,Ge.wrapT=P.wrap,W[ve]=Ge}for(let ve in H){let ie=H[ve],Y;if(ie!=="")switch(ve.toLowerCase()){case"kd":W.color=new bn.Color().fromArray(ie);break;case"ks":W.specular=new bn.Color().fromArray(ie);break;case"ke":W.emissive=new bn.Color().fromArray(ie);break;case"map_kd":Se("map",ie);break;case"map_ks":Se("specularMap",ie);break;case"map_ke":Se("emissiveMap",ie);break;case"norm":Se("normalMap",ie);break;case"map_bump":case"bump":Se("bumpMap",ie);break;case"map_d":Se("alphaMap",ie),W.transparent=!0;break;case"ns":W.shininess=parseFloat(ie);break;case"d":Y=parseFloat(ie),Y<1&&(W.opacity=Y,W.transparent=!0);break;case"tr":Y=parseFloat(ie),this.options&&this.options.invertTrProperty&&(Y=1-Y),Y>0&&(W.opacity=1-Y,W.transparent=!0);break;default:break}}return this.materials[b]=new bn.MeshPhongMaterial(W),this.materials[b]}getTextureParams(b,P){let H={scale:new bn.Vector2(1,1),offset:new bn.Vector2(0,0)},W=b.split(/\s+/),Z;return Z=W.indexOf("-bm"),Z>=0&&(P.bumpScale=parseFloat(W[Z+1]),W.splice(Z,2)),Z=W.indexOf("-s"),Z>=0&&(H.scale.set(parseFloat(W[Z+1]),parseFloat(W[Z+2])),W.splice(Z,4)),Z=W.indexOf("-o"),Z>=0&&(H.offset.set(parseFloat(W[Z+1]),parseFloat(W[Z+2])),W.splice(Z,4)),H.url=W.join(" ").trim(),H}loadTexture(b,P,H,W,Z){let Se=this.manager!==void 0?this.manager:bn.DefaultLoadingManager,ve=Se.getHandler(b);ve===null&&(ve=new bn.TextureLoader(Se)),ve.setCrossOrigin&&ve.setCrossOrigin(this.crossOrigin);let ie=ve.load(b,H,W,Z);return P!==void 0&&(ie.mapping=P),ie}}bn.MTLLoader=l})();xd.exports=vd=bn.MTLLoader});var wd=Ht((bd,Md)=>{var ge=mn();(function(){class l extends ge.Loader{constructor(T){super(T),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(E){return new H(E)}),this.register(function(E){return new ie(E)}),this.register(function(E){return new Y(E)}),this.register(function(E){return new W(E)}),this.register(function(E){return new Z(E)}),this.register(function(E){return new Se(E)}),this.register(function(E){return new ve(E)}),this.register(function(E){return new b(E)}),this.register(function(E){return new Ge(E)})}load(T,E,N,R){let z=this,G;this.resourcePath!==""?G=this.resourcePath:this.path!==""?G=this.path:G=ge.LoaderUtils.extractUrlBase(T),this.manager.itemStart(T);let V=function(re){R?R(re):console.error(re),z.manager.itemError(T),z.manager.itemEnd(T)},k=new ge.FileLoader(this.manager);k.setPath(this.path),k.setResponseType("arraybuffer"),k.setRequestHeader(this.requestHeader),k.setWithCredentials(this.withCredentials),k.load(T,function(re){try{z.parse(re,G,function(Me){E(Me),z.manager.itemEnd(T)},V)}catch(Me){V(Me)}},N,V)}setDRACOLoader(T){return this.dracoLoader=T,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(T){return this.ktx2Loader=T,this}setMeshoptDecoder(T){return this.meshoptDecoder=T,this}register(T){return this.pluginCallbacks.indexOf(T)===-1&&this.pluginCallbacks.push(T),this}unregister(T){return this.pluginCallbacks.indexOf(T)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(T),1),this}parse(T,E,N,R){let z,G={},V={};if(typeof T=="string")z=T;else if(ge.LoaderUtils.decodeText(new Uint8Array(T,0,4))===qe){try{G[M.KHR_BINARY_GLTF]=new Rt(T)}catch(fe){R&&R(fe);return}z=G[M.KHR_BINARY_GLTF].content}else z=ge.LoaderUtils.decodeText(new Uint8Array(T));let k=JSON.parse(z);if(k.asset===void 0||k.asset.version[0]<2){R&&R(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}let re=new hn(k,{path:E||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});re.fileLoader.setRequestHeader(this.requestHeader);for(let Me=0;Me<this.pluginCallbacks.length;Me++){let fe=this.pluginCallbacks[Me](re);V[fe.name]=fe,G[fe.name]=!0}if(k.extensionsUsed)for(let Me=0;Me<k.extensionsUsed.length;++Me){let fe=k.extensionsUsed[Me],je=k.extensionsRequired||[];switch(fe){case M.KHR_MATERIALS_UNLIT:G[fe]=new P;break;case M.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:G[fe]=new it;break;case M.KHR_DRACO_MESH_COMPRESSION:G[fe]=new xt(k,this.dracoLoader);break;case M.KHR_TEXTURE_TRANSFORM:G[fe]=new Tt;break;case M.KHR_MESH_QUANTIZATION:G[fe]=new he;break;default:je.indexOf(fe)>=0&&V[fe]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+fe+'".')}}re.setExtensions(G),re.setPlugins(V),re.parse(N,R)}}function _(){let xe={};return{get:function(T){return xe[T]},add:function(T,E){xe[T]=E},remove:function(T){delete xe[T]},removeAll:function(){xe={}}}}let M={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression"};class b{constructor(T){this.parser=T,this.name=M.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){let T=this.parser,E=this.parser.json.nodes||[];for(let N=0,R=E.length;N<R;N++){let z=E[N];z.extensions&&z.extensions[this.name]&&z.extensions[this.name].light!==void 0&&T._addNodeRef(this.cache,z.extensions[this.name].light)}}_loadLight(T){let E=this.parser,N="light:"+T,R=E.cache.get(N);if(R)return R;let z=E.json,k=((z.extensions&&z.extensions[this.name]||{}).lights||[])[T],re,Me=new ge.Color(16777215);k.color!==void 0&&Me.fromArray(k.color);let fe=k.range!==void 0?k.range:0;switch(k.type){case"directional":re=new ge.DirectionalLight(Me),re.target.position.set(0,0,-1),re.add(re.target);break;case"point":re=new ge.PointLight(Me),re.distance=fe;break;case"spot":re=new ge.SpotLight(Me),re.distance=fe,k.spot=k.spot||{},k.spot.innerConeAngle=k.spot.innerConeAngle!==void 0?k.spot.innerConeAngle:0,k.spot.outerConeAngle=k.spot.outerConeAngle!==void 0?k.spot.outerConeAngle:Math.PI/4,re.angle=k.spot.outerConeAngle,re.penumbra=1-k.spot.innerConeAngle/k.spot.outerConeAngle,re.target.position.set(0,0,-1),re.add(re.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+k.type)}return re.position.set(0,0,0),re.decay=2,k.intensity!==void 0&&(re.intensity=k.intensity),re.name=E.createUniqueName(k.name||"light_"+T),R=Promise.resolve(re),E.cache.add(N,R),R}createNodeAttachment(T){let E=this,N=this.parser,z=N.json.nodes[T],V=(z.extensions&&z.extensions[this.name]||{}).light;return V===void 0?null:this._loadLight(V).then(function(k){return N._getNodeRef(E.cache,V,k)})}}class P{constructor(){this.name=M.KHR_MATERIALS_UNLIT}getMaterialType(){return ge.MeshBasicMaterial}extendParams(T,E,N){let R=[];T.color=new ge.Color(1,1,1),T.opacity=1;let z=E.pbrMetallicRoughness;if(z){if(Array.isArray(z.baseColorFactor)){let G=z.baseColorFactor;T.color.fromArray(G),T.opacity=G[3]}z.baseColorTexture!==void 0&&R.push(N.assignTexture(T,"map",z.baseColorTexture))}return Promise.all(R)}}class H{constructor(T){this.parser=T,this.name=M.KHR_MATERIALS_CLEARCOAT}getMaterialType(T){let N=this.parser.json.materials[T];return!N.extensions||!N.extensions[this.name]?null:ge.MeshPhysicalMaterial}extendMaterialParams(T,E){let N=this.parser,R=N.json.materials[T];if(!R.extensions||!R.extensions[this.name])return Promise.resolve();let z=[],G=R.extensions[this.name];if(G.clearcoatFactor!==void 0&&(E.clearcoat=G.clearcoatFactor),G.clearcoatTexture!==void 0&&z.push(N.assignTexture(E,"clearcoatMap",G.clearcoatTexture)),G.clearcoatRoughnessFactor!==void 0&&(E.clearcoatRoughness=G.clearcoatRoughnessFactor),G.clearcoatRoughnessTexture!==void 0&&z.push(N.assignTexture(E,"clearcoatRoughnessMap",G.clearcoatRoughnessTexture)),G.clearcoatNormalTexture!==void 0&&(z.push(N.assignTexture(E,"clearcoatNormalMap",G.clearcoatNormalTexture)),G.clearcoatNormalTexture.scale!==void 0)){let V=G.clearcoatNormalTexture.scale;E.clearcoatNormalScale=new ge.Vector2(V,-V)}return Promise.all(z)}}class W{constructor(T){this.parser=T,this.name=M.KHR_MATERIALS_TRANSMISSION}getMaterialType(T){let N=this.parser.json.materials[T];return!N.extensions||!N.extensions[this.name]?null:ge.MeshPhysicalMaterial}extendMaterialParams(T,E){let N=this.parser,R=N.json.materials[T];if(!R.extensions||!R.extensions[this.name])return Promise.resolve();let z=[],G=R.extensions[this.name];return G.transmissionFactor!==void 0&&(E.transmission=G.transmissionFactor),G.transmissionTexture!==void 0&&z.push(N.assignTexture(E,"transmissionMap",G.transmissionTexture)),Promise.all(z)}}class Z{constructor(T){this.parser=T,this.name=M.KHR_MATERIALS_VOLUME}getMaterialType(T){let N=this.parser.json.materials[T];return!N.extensions||!N.extensions[this.name]?null:ge.MeshPhysicalMaterial}extendMaterialParams(T,E){let N=this.parser,R=N.json.materials[T];if(!R.extensions||!R.extensions[this.name])return Promise.resolve();let z=[],G=R.extensions[this.name];E.thickness=G.thicknessFactor!==void 0?G.thicknessFactor:0,G.thicknessTexture!==void 0&&z.push(N.assignTexture(E,"thicknessMap",G.thicknessTexture)),E.attenuationDistance=G.attenuationDistance||0;let V=G.attenuationColor||[1,1,1];return E.attenuationTint=new ge.Color(V[0],V[1],V[2]),Promise.all(z)}}class Se{constructor(T){this.parser=T,this.name=M.KHR_MATERIALS_IOR}getMaterialType(T){let N=this.parser.json.materials[T];return!N.extensions||!N.extensions[this.name]?null:ge.MeshPhysicalMaterial}extendMaterialParams(T,E){let R=this.parser.json.materials[T];if(!R.extensions||!R.extensions[this.name])return Promise.resolve();let z=R.extensions[this.name];return E.ior=z.ior!==void 0?z.ior:1.5,Promise.resolve()}}class ve{constructor(T){this.parser=T,this.name=M.KHR_MATERIALS_SPECULAR}getMaterialType(T){let N=this.parser.json.materials[T];return!N.extensions||!N.extensions[this.name]?null:ge.MeshPhysicalMaterial}extendMaterialParams(T,E){let N=this.parser,R=N.json.materials[T];if(!R.extensions||!R.extensions[this.name])return Promise.resolve();let z=[],G=R.extensions[this.name];E.specularIntensity=G.specularFactor!==void 0?G.specularFactor:1,G.specularTexture!==void 0&&z.push(N.assignTexture(E,"specularIntensityMap",G.specularTexture));let V=G.specularColorFactor||[1,1,1];return E.specularTint=new ge.Color(V[0],V[1],V[2]),G.specularColorTexture!==void 0&&z.push(N.assignTexture(E,"specularTintMap",G.specularColorTexture).then(function(k){k.encoding=ge.sRGBEncoding})),Promise.all(z)}}class ie{constructor(T){this.parser=T,this.name=M.KHR_TEXTURE_BASISU}loadTexture(T){let E=this.parser,N=E.json,R=N.textures[T];if(!R.extensions||!R.extensions[this.name])return null;let z=R.extensions[this.name],G=N.images[z.source],V=E.options.ktx2Loader;if(!V){if(N.extensionsRequired&&N.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return E.loadTextureImage(T,G,V)}}class Y{constructor(T){this.parser=T,this.name=M.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(T){let E=this.name,N=this.parser,R=N.json,z=R.textures[T];if(!z.extensions||!z.extensions[E])return null;let G=z.extensions[E],V=R.images[G.source],k=N.textureLoader;if(V.uri){let re=N.options.manager.getHandler(V.uri);re!==null&&(k=re)}return this.detectSupport().then(function(re){if(re)return N.loadTextureImage(T,V,k);if(R.extensionsRequired&&R.extensionsRequired.indexOf(E)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return N.loadTexture(T)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(T){let E=new Image;E.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",E.onload=E.onerror=function(){T(E.height===1)}})),this.isSupported}}class Ge{constructor(T){this.name=M.EXT_MESHOPT_COMPRESSION,this.parser=T}loadBufferView(T){let E=this.parser.json,N=E.bufferViews[T];if(N.extensions&&N.extensions[this.name]){let R=N.extensions[this.name],z=this.parser.getDependency("buffer",R.buffer),G=this.parser.options.meshoptDecoder;if(!G||!G.supported){if(E.extensionsRequired&&E.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return Promise.all([z,G.ready]).then(function(V){let k=R.byteOffset||0,re=R.byteLength||0,Me=R.count,fe=R.byteStride,je=new ArrayBuffer(Me*fe),rt=new Uint8Array(V[0],k,re);return G.decodeGltfBuffer(new Uint8Array(je),Me,fe,rt,R.mode,R.filter),je})}else return null}}let qe="glTF",He=12,yt={JSON:1313821514,BIN:5130562};class Rt{constructor(T){this.name=M.KHR_BINARY_GLTF,this.content=null,this.body=null;let E=new DataView(T,0,He);if(this.header={magic:ge.LoaderUtils.decodeText(new Uint8Array(T.slice(0,4))),version:E.getUint32(4,!0),length:E.getUint32(8,!0)},this.header.magic!==qe)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");let N=this.header.length-He,R=new DataView(T,He),z=0;for(;z<N;){let G=R.getUint32(z,!0);z+=4;let V=R.getUint32(z,!0);if(z+=4,V===yt.JSON){let k=new Uint8Array(T,He+z,G);this.content=ge.LoaderUtils.decodeText(k)}else if(V===yt.BIN){let k=He+z;this.body=T.slice(k,k+G)}z+=G}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class xt{constructor(T,E){if(!E)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=M.KHR_DRACO_MESH_COMPRESSION,this.json=T,this.dracoLoader=E,this.dracoLoader.preload()}decodePrimitive(T,E){let N=this.json,R=this.dracoLoader,z=T.extensions[this.name].bufferView,G=T.extensions[this.name].attributes,V={},k={},re={};for(let Me in G){let fe=Qt[Me]||Me.toLowerCase();V[fe]=G[Me]}for(let Me in T.attributes){let fe=Qt[Me]||Me.toLowerCase();if(G[Me]!==void 0){let je=N.accessors[T.attributes[Me]],rt=Ae[je.componentType];re[fe]=rt,k[fe]=je.normalized===!0}}return E.getDependency("bufferView",z).then(function(Me){return new Promise(function(fe){R.decodeDracoFile(Me,function(je){for(let rt in je.attributes){let Et=je.attributes[rt],nt=k[rt];nt!==void 0&&(Et.normalized=nt)}fe(je)},V,re)})})}}class Tt{constructor(){this.name=M.KHR_TEXTURE_TRANSFORM}extendTexture(T,E){return E.texCoord!==void 0&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),E.offset===void 0&&E.rotation===void 0&&E.scale===void 0||(T=T.clone(),E.offset!==void 0&&T.offset.fromArray(E.offset),E.rotation!==void 0&&(T.rotation=E.rotation),E.scale!==void 0&&T.repeat.fromArray(E.scale),T.needsUpdate=!0),T}}class Ve extends ge.MeshStandardMaterial{constructor(T){super(),this.isGLTFSpecularGlossinessMaterial=!0;let E=["#ifdef USE_SPECULARMAP","	uniform sampler2D specularMap;","#endif"].join(`
`),N=["#ifdef USE_GLOSSINESSMAP","	uniform sampler2D glossinessMap;","#endif"].join(`
`),R=["vec3 specularFactor = specular;","#ifdef USE_SPECULARMAP","	vec4 texelSpecular = texture2D( specularMap, vUv );","	texelSpecular = sRGBToLinear( texelSpecular );","	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture","	specularFactor *= texelSpecular.rgb;","#endif"].join(`
`),z=["float glossinessFactor = glossiness;","#ifdef USE_GLOSSINESSMAP","	vec4 texelGlossiness = texture2D( glossinessMap, vUv );","	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture","	glossinessFactor *= texelGlossiness.a;","#endif"].join(`
`),G=["PhysicalMaterial material;","material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );","vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );","float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );","material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.","material.roughness += geometryRoughness;","material.roughness = min( material.roughness, 1.0 );","material.specularColor = specularFactor;"].join(`
`),V={specular:{value:new ge.Color().setHex(16777215)},glossiness:{value:1},specularMap:{value:null},glossinessMap:{value:null}};this._extraUniforms=V,this.onBeforeCompile=function(k){for(let re in V)k.uniforms[re]=V[re];k.fragmentShader=k.fragmentShader.replace("uniform float roughness;","uniform vec3 specular;").replace("uniform float metalness;","uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>",E).replace("#include <metalnessmap_pars_fragment>",N).replace("#include <roughnessmap_fragment>",R).replace("#include <metalnessmap_fragment>",z).replace("#include <lights_physical_fragment>",G)},Object.defineProperties(this,{specular:{get:function(){return V.specular.value},set:function(k){V.specular.value=k}},specularMap:{get:function(){return V.specularMap.value},set:function(k){V.specularMap.value=k,k?this.defines.USE_SPECULARMAP="":delete this.defines.USE_SPECULARMAP}},glossiness:{get:function(){return V.glossiness.value},set:function(k){V.glossiness.value=k}},glossinessMap:{get:function(){return V.glossinessMap.value},set:function(k){V.glossinessMap.value=k,k?(this.defines.USE_GLOSSINESSMAP="",this.defines.USE_UV=""):(delete this.defines.USE_GLOSSINESSMAP,delete this.defines.USE_UV)}}}),delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this.setValues(T)}copy(T){return super.copy(T),this.specularMap=T.specularMap,this.specular.copy(T.specular),this.glossinessMap=T.glossinessMap,this.glossiness=T.glossiness,delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this}}class it{constructor(){this.name=M.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,this.specularGlossinessParams=["color","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissive","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalMapType","displacementMap","displacementScale","displacementBias","specularMap","specular","glossinessMap","glossiness","alphaMap","envMap","envMapIntensity","refractionRatio"]}getMaterialType(){return Ve}extendParams(T,E,N){let R=E.extensions[this.name];T.color=new ge.Color(1,1,1),T.opacity=1;let z=[];if(Array.isArray(R.diffuseFactor)){let G=R.diffuseFactor;T.color.fromArray(G),T.opacity=G[3]}if(R.diffuseTexture!==void 0&&z.push(N.assignTexture(T,"map",R.diffuseTexture)),T.emissive=new ge.Color(0,0,0),T.glossiness=R.glossinessFactor!==void 0?R.glossinessFactor:1,T.specular=new ge.Color(1,1,1),Array.isArray(R.specularFactor)&&T.specular.fromArray(R.specularFactor),R.specularGlossinessTexture!==void 0){let G=R.specularGlossinessTexture;z.push(N.assignTexture(T,"glossinessMap",G)),z.push(N.assignTexture(T,"specularMap",G))}return Promise.all(z)}createMaterial(T){let E=new Ve(T);return E.fog=!0,E.color=T.color,E.map=T.map===void 0?null:T.map,E.lightMap=null,E.lightMapIntensity=1,E.aoMap=T.aoMap===void 0?null:T.aoMap,E.aoMapIntensity=1,E.emissive=T.emissive,E.emissiveIntensity=1,E.emissiveMap=T.emissiveMap===void 0?null:T.emissiveMap,E.bumpMap=T.bumpMap===void 0?null:T.bumpMap,E.bumpScale=1,E.normalMap=T.normalMap===void 0?null:T.normalMap,E.normalMapType=ge.TangentSpaceNormalMap,T.normalScale&&(E.normalScale=T.normalScale),E.displacementMap=null,E.displacementScale=1,E.displacementBias=0,E.specularMap=T.specularMap===void 0?null:T.specularMap,E.specular=T.specular,E.glossinessMap=T.glossinessMap===void 0?null:T.glossinessMap,E.glossiness=T.glossiness,E.alphaMap=null,E.envMap=T.envMap===void 0?null:T.envMap,E.envMapIntensity=1,E.refractionRatio=.98,E}}class he{constructor(){this.name=M.KHR_MESH_QUANTIZATION}}class ze extends ge.Interpolant{constructor(T,E,N,R){super(T,E,N,R)}copySampleValue_(T){let E=this.resultBuffer,N=this.sampleValues,R=this.valueSize,z=T*R*3+R;for(let G=0;G!==R;G++)E[G]=N[z+G];return E}}ze.prototype.beforeStart_=ze.prototype.copySampleValue_,ze.prototype.afterEnd_=ze.prototype.copySampleValue_,ze.prototype.interpolate_=function(xe,T,E,N){let R=this.resultBuffer,z=this.sampleValues,G=this.valueSize,V=G*2,k=G*3,re=N-T,Me=(E-T)/re,fe=Me*Me,je=fe*Me,rt=xe*k,Et=rt-k,nt=-2*je+3*fe,Ke=je-fe,at=1-nt,Wt=Ke-fe+Me;for(let Dt=0;Dt!==G;Dt++){let kn=z[Et+Dt+G],ti=z[Et+Dt+V]*re,Ln=z[rt+Dt+G],me=z[rt+Dt]*re;R[Dt]=at*kn+Wt*ti+nt*Ln+Ke*me}return R};let We=new ge.Quaternion;class j extends ze{interpolate_(T,E,N,R){let z=super.interpolate_(T,E,N,R);return We.fromArray(z).normalize().toArray(z),z}}let U={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},Ae={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},Qe={9728:ge.NearestFilter,9729:ge.LinearFilter,9984:ge.NearestMipmapNearestFilter,9985:ge.LinearMipmapNearestFilter,9986:ge.NearestMipmapLinearFilter,9987:ge.LinearMipmapLinearFilter},dt={33071:ge.ClampToEdgeWrapping,33648:ge.MirroredRepeatWrapping,10497:ge.RepeatWrapping},Gt={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Qt={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},kt={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},Mn={CUBICSPLINE:void 0,LINEAR:ge.InterpolateLinear,STEP:ge.InterpolateDiscrete},Bn={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function Zt(xe,T){return typeof xe!="string"||xe===""?"":(/^https?:\/\//i.test(T)&&/^\//.test(xe)&&(T=T.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(xe)||/^data:.*,.*$/i.test(xe)||/^blob:.*$/i.test(xe)?xe:T+xe)}function Oe(xe){return xe.DefaultMaterial===void 0&&(xe.DefaultMaterial=new ge.MeshStandardMaterial({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:ge.FrontSide})),xe.DefaultMaterial}function Ze(xe,T,E){for(let N in E.extensions)xe[N]===void 0&&(T.userData.gltfExtensions=T.userData.gltfExtensions||{},T.userData.gltfExtensions[N]=E.extensions[N])}function tt(xe,T){T.extras!==void 0&&(typeof T.extras=="object"?Object.assign(xe.userData,T.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+T.extras))}function Ft(xe,T,E){let N=!1,R=!1;for(let V=0,k=T.length;V<k;V++){let re=T[V];if(re.POSITION!==void 0&&(N=!0),re.NORMAL!==void 0&&(R=!0),N&&R)break}if(!N&&!R)return Promise.resolve(xe);let z=[],G=[];for(let V=0,k=T.length;V<k;V++){let re=T[V];if(N){let Me=re.POSITION!==void 0?E.getDependency("accessor",re.POSITION):xe.attributes.position;z.push(Me)}if(R){let Me=re.NORMAL!==void 0?E.getDependency("accessor",re.NORMAL):xe.attributes.normal;G.push(Me)}}return Promise.all([Promise.all(z),Promise.all(G)]).then(function(V){let k=V[0],re=V[1];return N&&(xe.morphAttributes.position=k),R&&(xe.morphAttributes.normal=re),xe.morphTargetsRelative=!0,xe})}function At(xe,T){if(xe.updateMorphTargets(),T.weights!==void 0)for(let E=0,N=T.weights.length;E<N;E++)xe.morphTargetInfluences[E]=T.weights[E];if(T.extras&&Array.isArray(T.extras.targetNames)){let E=T.extras.targetNames;if(xe.morphTargetInfluences.length===E.length){xe.morphTargetDictionary={};for(let N=0,R=E.length;N<R;N++)xe.morphTargetDictionary[E[N]]=N}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function Ct(xe){let T=xe.extensions&&xe.extensions[M.KHR_DRACO_MESH_COMPRESSION],E;return T?E="draco:"+T.bufferView+":"+T.indices+":"+vt(T.attributes):E=xe.indices+":"+vt(xe.attributes)+":"+xe.mode,E}function vt(xe){let T="",E=Object.keys(xe).sort();for(let N=0,R=E.length;N<R;N++)T+=E[N]+":"+xe[E[N]]+";";return T}function Vt(xe){switch(xe){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}class hn{constructor(T={},E={}){this.json=T,this.extensions={},this.plugins={},this.options=E,this.cache=new _,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.textureCache={},this.nodeNamesUsed={},typeof createImageBitmap<"u"&&/Firefox/.test(navigator.userAgent)===!1?this.textureLoader=new ge.ImageBitmapLoader(this.options.manager):this.textureLoader=new ge.TextureLoader(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new ge.FileLoader(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(T){this.extensions=T}setPlugins(T){this.plugins=T}parse(T,E){let N=this,R=this.json,z=this.extensions;this.cache.removeAll(),this._invokeAll(function(G){return G._markDefs&&G._markDefs()}),Promise.all(this._invokeAll(function(G){return G.beforeRoot&&G.beforeRoot()})).then(function(){return Promise.all([N.getDependencies("scene"),N.getDependencies("animation"),N.getDependencies("camera")])}).then(function(G){let V={scene:G[0][R.scene||0],scenes:G[0],animations:G[1],cameras:G[2],asset:R.asset,parser:N,userData:{}};Ze(z,V,R),tt(V,R),Promise.all(N._invokeAll(function(k){return k.afterRoot&&k.afterRoot(V)})).then(function(){T(V)})}).catch(E)}_markDefs(){let T=this.json.nodes||[],E=this.json.skins||[],N=this.json.meshes||[];for(let R=0,z=E.length;R<z;R++){let G=E[R].joints;for(let V=0,k=G.length;V<k;V++)T[G[V]].isBone=!0}for(let R=0,z=T.length;R<z;R++){let G=T[R];G.mesh!==void 0&&(this._addNodeRef(this.meshCache,G.mesh),G.skin!==void 0&&(N[G.mesh].isSkinnedMesh=!0)),G.camera!==void 0&&this._addNodeRef(this.cameraCache,G.camera)}}_addNodeRef(T,E){E!==void 0&&(T.refs[E]===void 0&&(T.refs[E]=T.uses[E]=0),T.refs[E]++)}_getNodeRef(T,E,N){if(T.refs[E]<=1)return N;let R=N.clone();return R.name+="_instance_"+T.uses[E]++,R}_invokeOne(T){let E=Object.values(this.plugins);E.push(this);for(let N=0;N<E.length;N++){let R=T(E[N]);if(R)return R}return null}_invokeAll(T){let E=Object.values(this.plugins);E.unshift(this);let N=[];for(let R=0;R<E.length;R++){let z=T(E[R]);z&&N.push(z)}return N}getDependency(T,E){let N=T+":"+E,R=this.cache.get(N);if(!R){switch(T){case"scene":R=this.loadScene(E);break;case"node":R=this.loadNode(E);break;case"mesh":R=this._invokeOne(function(z){return z.loadMesh&&z.loadMesh(E)});break;case"accessor":R=this.loadAccessor(E);break;case"bufferView":R=this._invokeOne(function(z){return z.loadBufferView&&z.loadBufferView(E)});break;case"buffer":R=this.loadBuffer(E);break;case"material":R=this._invokeOne(function(z){return z.loadMaterial&&z.loadMaterial(E)});break;case"texture":R=this._invokeOne(function(z){return z.loadTexture&&z.loadTexture(E)});break;case"skin":R=this.loadSkin(E);break;case"animation":R=this.loadAnimation(E);break;case"camera":R=this.loadCamera(E);break;default:throw new Error("Unknown type: "+T)}this.cache.add(N,R)}return R}getDependencies(T){let E=this.cache.get(T);if(!E){let N=this,R=this.json[T+(T==="mesh"?"es":"s")]||[];E=Promise.all(R.map(function(z,G){return N.getDependency(T,G)})),this.cache.add(T,E)}return E}loadBuffer(T){let E=this.json.buffers[T],N=this.fileLoader;if(E.type&&E.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+E.type+" buffer type is not supported.");if(E.uri===void 0&&T===0)return Promise.resolve(this.extensions[M.KHR_BINARY_GLTF].body);let R=this.options;return new Promise(function(z,G){N.load(Zt(E.uri,R.path),z,void 0,function(){G(new Error('THREE.GLTFLoader: Failed to load buffer "'+E.uri+'".'))})})}loadBufferView(T){let E=this.json.bufferViews[T];return this.getDependency("buffer",E.buffer).then(function(N){let R=E.byteLength||0,z=E.byteOffset||0;return N.slice(z,z+R)})}loadAccessor(T){let E=this,N=this.json,R=this.json.accessors[T];if(R.bufferView===void 0&&R.sparse===void 0)return Promise.resolve(null);let z=[];return R.bufferView!==void 0?z.push(this.getDependency("bufferView",R.bufferView)):z.push(null),R.sparse!==void 0&&(z.push(this.getDependency("bufferView",R.sparse.indices.bufferView)),z.push(this.getDependency("bufferView",R.sparse.values.bufferView))),Promise.all(z).then(function(G){let V=G[0],k=Gt[R.type],re=Ae[R.componentType],Me=re.BYTES_PER_ELEMENT,fe=Me*k,je=R.byteOffset||0,rt=R.bufferView!==void 0?N.bufferViews[R.bufferView].byteStride:void 0,Et=R.normalized===!0,nt,Ke;if(rt&&rt!==fe){let at=Math.floor(je/rt),Wt="InterleavedBuffer:"+R.bufferView+":"+R.componentType+":"+at+":"+R.count,Dt=E.cache.get(Wt);Dt||(nt=new re(V,at*rt,R.count*rt/Me),Dt=new ge.InterleavedBuffer(nt,rt/Me),E.cache.add(Wt,Dt)),Ke=new ge.InterleavedBufferAttribute(Dt,k,je%rt/Me,Et)}else V===null?nt=new re(R.count*k):nt=new re(V,je,R.count*k),Ke=new ge.BufferAttribute(nt,k,Et);if(R.sparse!==void 0){let at=Gt.SCALAR,Wt=Ae[R.sparse.indices.componentType],Dt=R.sparse.indices.byteOffset||0,kn=R.sparse.values.byteOffset||0,ti=new Wt(G[1],Dt,R.sparse.count*at),Ln=new re(G[2],kn,R.sparse.count*k);V!==null&&(Ke=new ge.BufferAttribute(Ke.array.slice(),Ke.itemSize,Ke.normalized));for(let me=0,Nt=ti.length;me<Nt;me++){let Rn=ti[me];if(Ke.setX(Rn,Ln[me*k]),k>=2&&Ke.setY(Rn,Ln[me*k+1]),k>=3&&Ke.setZ(Rn,Ln[me*k+2]),k>=4&&Ke.setW(Rn,Ln[me*k+3]),k>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse THREE.BufferAttribute.")}}return Ke})}loadTexture(T){let E=this.json,N=this.options,R=E.textures[T],z=E.images[R.source],G=this.textureLoader;if(z.uri){let V=N.manager.getHandler(z.uri);V!==null&&(G=V)}return this.loadTextureImage(T,z,G)}loadTextureImage(T,E,N){let R=this,z=this.json,G=this.options,V=z.textures[T],k=(E.uri||E.bufferView)+":"+V.sampler;if(this.textureCache[k])return this.textureCache[k];let re=self.URL||self.webkitURL,Me=E.uri||"",fe=!1,je=!0,rt=Me.search(/\.jpe?g($|\?)/i)>0||Me.search(/^data\:image\/jpeg/)===0;if((E.mimeType==="image/jpeg"||rt)&&(je=!1),E.bufferView!==void 0)Me=R.getDependency("bufferView",E.bufferView).then(function(nt){if(E.mimeType==="image/png"){let at=new DataView(nt,25,1).getUint8(0,!1);je=at===6||at===4||at===3}fe=!0;let Ke=new Blob([nt],{type:E.mimeType});return Me=re.createObjectURL(Ke),Me});else if(E.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+T+" is missing URI and bufferView");let Et=Promise.resolve(Me).then(function(nt){return new Promise(function(Ke,at){let Wt=Ke;N.isImageBitmapLoader===!0&&(Wt=function(Dt){let kn=new ge.Texture(Dt);kn.needsUpdate=!0,Ke(kn)}),N.load(Zt(nt,G.path),Wt,void 0,at)})}).then(function(nt){fe===!0&&re.revokeObjectURL(Me),nt.flipY=!1,V.name&&(nt.name=V.name),je||(nt.format=ge.RGBFormat);let at=(z.samplers||{})[V.sampler]||{};return nt.magFilter=Qe[at.magFilter]||ge.LinearFilter,nt.minFilter=Qe[at.minFilter]||ge.LinearMipmapLinearFilter,nt.wrapS=dt[at.wrapS]||ge.RepeatWrapping,nt.wrapT=dt[at.wrapT]||ge.RepeatWrapping,R.associations.set(nt,{type:"textures",index:T}),nt}).catch(function(){return console.error("THREE.GLTFLoader: Couldn't load texture",Me),null});return this.textureCache[k]=Et,Et}assignTexture(T,E,N){let R=this;return this.getDependency("texture",N.index).then(function(z){if(N.texCoord!==void 0&&N.texCoord!=0&&!(E==="aoMap"&&N.texCoord==1)&&console.warn("THREE.GLTFLoader: Custom UV set "+N.texCoord+" for texture "+E+" not yet supported."),R.extensions[M.KHR_TEXTURE_TRANSFORM]){let G=N.extensions!==void 0?N.extensions[M.KHR_TEXTURE_TRANSFORM]:void 0;if(G){let V=R.associations.get(z);z=R.extensions[M.KHR_TEXTURE_TRANSFORM].extendTexture(z,G),R.associations.set(z,V)}}return T[E]=z,z})}assignFinalMaterial(T){let E=T.geometry,N=T.material,R=E.attributes.tangent!==void 0,z=E.attributes.color!==void 0,G=E.attributes.normal===void 0;if(T.isPoints){let V="PointsMaterial:"+N.uuid,k=this.cache.get(V);k||(k=new ge.PointsMaterial,ge.Material.prototype.copy.call(k,N),k.color.copy(N.color),k.map=N.map,k.sizeAttenuation=!1,this.cache.add(V,k)),N=k}else if(T.isLine){let V="LineBasicMaterial:"+N.uuid,k=this.cache.get(V);k||(k=new ge.LineBasicMaterial,ge.Material.prototype.copy.call(k,N),k.color.copy(N.color),this.cache.add(V,k)),N=k}if(R||z||G){let V="ClonedMaterial:"+N.uuid+":";N.isGLTFSpecularGlossinessMaterial&&(V+="specular-glossiness:"),R&&(V+="vertex-tangents:"),z&&(V+="vertex-colors:"),G&&(V+="flat-shading:");let k=this.cache.get(V);k||(k=N.clone(),z&&(k.vertexColors=!0),G&&(k.flatShading=!0),R&&(k.normalScale&&(k.normalScale.y*=-1),k.clearcoatNormalScale&&(k.clearcoatNormalScale.y*=-1)),this.cache.add(V,k),this.associations.set(k,this.associations.get(N))),N=k}N.aoMap&&E.attributes.uv2===void 0&&E.attributes.uv!==void 0&&E.setAttribute("uv2",E.attributes.uv),T.material=N}getMaterialType(){return ge.MeshStandardMaterial}loadMaterial(T){let E=this,N=this.json,R=this.extensions,z=N.materials[T],G,V={},k=z.extensions||{},re=[];if(k[M.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]){let fe=R[M.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];G=fe.getMaterialType(),re.push(fe.extendParams(V,z,E))}else if(k[M.KHR_MATERIALS_UNLIT]){let fe=R[M.KHR_MATERIALS_UNLIT];G=fe.getMaterialType(),re.push(fe.extendParams(V,z,E))}else{let fe=z.pbrMetallicRoughness||{};if(V.color=new ge.Color(1,1,1),V.opacity=1,Array.isArray(fe.baseColorFactor)){let je=fe.baseColorFactor;V.color.fromArray(je),V.opacity=je[3]}fe.baseColorTexture!==void 0&&re.push(E.assignTexture(V,"map",fe.baseColorTexture)),V.metalness=fe.metallicFactor!==void 0?fe.metallicFactor:1,V.roughness=fe.roughnessFactor!==void 0?fe.roughnessFactor:1,fe.metallicRoughnessTexture!==void 0&&(re.push(E.assignTexture(V,"metalnessMap",fe.metallicRoughnessTexture)),re.push(E.assignTexture(V,"roughnessMap",fe.metallicRoughnessTexture))),G=this._invokeOne(function(je){return je.getMaterialType&&je.getMaterialType(T)}),re.push(Promise.all(this._invokeAll(function(je){return je.extendMaterialParams&&je.extendMaterialParams(T,V)})))}z.doubleSided===!0&&(V.side=ge.DoubleSide);let Me=z.alphaMode||Bn.OPAQUE;return Me===Bn.BLEND?(V.transparent=!0,V.depthWrite=!1):(V.format=ge.RGBFormat,V.transparent=!1,Me===Bn.MASK&&(V.alphaTest=z.alphaCutoff!==void 0?z.alphaCutoff:.5)),z.normalTexture!==void 0&&G!==ge.MeshBasicMaterial&&(re.push(E.assignTexture(V,"normalMap",z.normalTexture)),V.normalScale=new ge.Vector2(1,-1),z.normalTexture.scale!==void 0&&V.normalScale.set(z.normalTexture.scale,-z.normalTexture.scale)),z.occlusionTexture!==void 0&&G!==ge.MeshBasicMaterial&&(re.push(E.assignTexture(V,"aoMap",z.occlusionTexture)),z.occlusionTexture.strength!==void 0&&(V.aoMapIntensity=z.occlusionTexture.strength)),z.emissiveFactor!==void 0&&G!==ge.MeshBasicMaterial&&(V.emissive=new ge.Color().fromArray(z.emissiveFactor)),z.emissiveTexture!==void 0&&G!==ge.MeshBasicMaterial&&re.push(E.assignTexture(V,"emissiveMap",z.emissiveTexture)),Promise.all(re).then(function(){let fe;return G===Ve?fe=R[M.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(V):fe=new G(V),z.name&&(fe.name=z.name),fe.map&&(fe.map.encoding=ge.sRGBEncoding),fe.emissiveMap&&(fe.emissiveMap.encoding=ge.sRGBEncoding),tt(fe,z),E.associations.set(fe,{type:"materials",index:T}),z.extensions&&Ze(R,fe,z),fe})}createUniqueName(T){let E=ge.PropertyBinding.sanitizeNodeName(T||""),N=E;for(let R=1;this.nodeNamesUsed[N];++R)N=E+"_"+R;return this.nodeNamesUsed[N]=!0,N}loadGeometries(T){let E=this,N=this.extensions,R=this.primitiveCache;function z(V){return N[M.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(V,E).then(function(k){return An(k,V,E)})}let G=[];for(let V=0,k=T.length;V<k;V++){let re=T[V],Me=Ct(re),fe=R[Me];if(fe)G.push(fe.promise);else{let je;re.extensions&&re.extensions[M.KHR_DRACO_MESH_COMPRESSION]?je=z(re):je=An(new ge.BufferGeometry,re,E),R[Me]={primitive:re,promise:je},G.push(je)}}return Promise.all(G)}loadMesh(T){let E=this,N=this.json,R=this.extensions,z=N.meshes[T],G=z.primitives,V=[];for(let k=0,re=G.length;k<re;k++){let Me=G[k].material===void 0?Oe(this.cache):this.getDependency("material",G[k].material);V.push(Me)}return V.push(E.loadGeometries(G)),Promise.all(V).then(function(k){let re=k.slice(0,k.length-1),Me=k[k.length-1],fe=[];for(let rt=0,Et=Me.length;rt<Et;rt++){let nt=Me[rt],Ke=G[rt],at,Wt=re[rt];if(Ke.mode===U.TRIANGLES||Ke.mode===U.TRIANGLE_STRIP||Ke.mode===U.TRIANGLE_FAN||Ke.mode===void 0)at=z.isSkinnedMesh===!0?new ge.SkinnedMesh(nt,Wt):new ge.Mesh(nt,Wt),at.isSkinnedMesh===!0&&!at.geometry.attributes.skinWeight.normalized&&at.normalizeSkinWeights(),Ke.mode===U.TRIANGLE_STRIP?at.geometry=Gn(at.geometry,ge.TriangleStripDrawMode):Ke.mode===U.TRIANGLE_FAN&&(at.geometry=Gn(at.geometry,ge.TriangleFanDrawMode));else if(Ke.mode===U.LINES)at=new ge.LineSegments(nt,Wt);else if(Ke.mode===U.LINE_STRIP)at=new ge.Line(nt,Wt);else if(Ke.mode===U.LINE_LOOP)at=new ge.LineLoop(nt,Wt);else if(Ke.mode===U.POINTS)at=new ge.Points(nt,Wt);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+Ke.mode);Object.keys(at.geometry.morphAttributes).length>0&&At(at,z),at.name=E.createUniqueName(z.name||"mesh_"+T),tt(at,z),Ke.extensions&&Ze(R,at,Ke),E.assignFinalMaterial(at),fe.push(at)}if(fe.length===1)return fe[0];let je=new ge.Group;for(let rt=0,Et=fe.length;rt<Et;rt++)je.add(fe[rt]);return je})}loadCamera(T){let E,N=this.json.cameras[T],R=N[N.type];if(!R){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return N.type==="perspective"?E=new ge.PerspectiveCamera(ge.MathUtils.radToDeg(R.yfov),R.aspectRatio||1,R.znear||1,R.zfar||2e6):N.type==="orthographic"&&(E=new ge.OrthographicCamera(-R.xmag,R.xmag,R.ymag,-R.ymag,R.znear,R.zfar)),N.name&&(E.name=this.createUniqueName(N.name)),tt(E,N),Promise.resolve(E)}loadSkin(T){let E=this.json.skins[T],N={joints:E.joints};return E.inverseBindMatrices===void 0?Promise.resolve(N):this.getDependency("accessor",E.inverseBindMatrices).then(function(R){return N.inverseBindMatrices=R,N})}loadAnimation(T){let N=this.json.animations[T],R=[],z=[],G=[],V=[],k=[];for(let re=0,Me=N.channels.length;re<Me;re++){let fe=N.channels[re],je=N.samplers[fe.sampler],rt=fe.target,Et=rt.node!==void 0?rt.node:rt.id,nt=N.parameters!==void 0?N.parameters[je.input]:je.input,Ke=N.parameters!==void 0?N.parameters[je.output]:je.output;R.push(this.getDependency("node",Et)),z.push(this.getDependency("accessor",nt)),G.push(this.getDependency("accessor",Ke)),V.push(je),k.push(rt)}return Promise.all([Promise.all(R),Promise.all(z),Promise.all(G),Promise.all(V),Promise.all(k)]).then(function(re){let Me=re[0],fe=re[1],je=re[2],rt=re[3],Et=re[4],nt=[];for(let at=0,Wt=Me.length;at<Wt;at++){let Dt=Me[at],kn=fe[at],ti=je[at],Ln=rt[at],me=Et[at];if(Dt===void 0)continue;Dt.updateMatrix(),Dt.matrixAutoUpdate=!0;let Nt;switch(kt[me.path]){case kt.weights:Nt=ge.NumberKeyframeTrack;break;case kt.rotation:Nt=ge.QuaternionKeyframeTrack;break;case kt.position:case kt.scale:default:Nt=ge.VectorKeyframeTrack;break}let Rn=Dt.name?Dt.name:Dt.uuid,ui=Ln.interpolation!==void 0?Mn[Ln.interpolation]:ge.InterpolateLinear,gr=[];kt[me.path]===kt.weights?Dt.traverse(function(xn){xn.isMesh===!0&&xn.morphTargetInfluences&&gr.push(xn.name?xn.name:xn.uuid)}):gr.push(Rn);let zt=ti.array;if(ti.normalized){let xn=Vt(zt.constructor),_t=new Float32Array(zt.length);for(let $t=0,Qr=zt.length;$t<Qr;$t++)_t[$t]=zt[$t]*xn;zt=_t}for(let xn=0,_t=gr.length;xn<_t;xn++){let $t=new Nt(gr[xn]+"."+kt[me.path],kn.array,zt,ui);Ln.interpolation==="CUBICSPLINE"&&($t.createInterpolant=function($r){let tn=this instanceof ge.QuaternionKeyframeTrack?j:ze;return new tn(this.times,this.values,this.getValueSize()/3,$r)},$t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),nt.push($t)}}let Ke=N.name?N.name:"animation_"+T;return new ge.AnimationClip(Ke,void 0,nt)})}createNodeMesh(T){let E=this.json,N=this,R=E.nodes[T];return R.mesh===void 0?null:N.getDependency("mesh",R.mesh).then(function(z){let G=N._getNodeRef(N.meshCache,R.mesh,z);return R.weights!==void 0&&G.traverse(function(V){if(V.isMesh)for(let k=0,re=R.weights.length;k<re;k++)V.morphTargetInfluences[k]=R.weights[k]}),G})}loadNode(T){let E=this.json,N=this.extensions,R=this,z=E.nodes[T],G=z.name?R.createUniqueName(z.name):"";return function(){let V=[],k=R._invokeOne(function(re){return re.createNodeMesh&&re.createNodeMesh(T)});return k&&V.push(k),z.camera!==void 0&&V.push(R.getDependency("camera",z.camera).then(function(re){return R._getNodeRef(R.cameraCache,z.camera,re)})),R._invokeAll(function(re){return re.createNodeAttachment&&re.createNodeAttachment(T)}).forEach(function(re){V.push(re)}),Promise.all(V)}().then(function(V){let k;if(z.isBone===!0?k=new ge.Bone:V.length>1?k=new ge.Group:V.length===1?k=V[0]:k=new ge.Object3D,k!==V[0])for(let re=0,Me=V.length;re<Me;re++)k.add(V[re]);if(z.name&&(k.userData.name=z.name,k.name=G),tt(k,z),z.extensions&&Ze(N,k,z),z.matrix!==void 0){let re=new ge.Matrix4;re.fromArray(z.matrix),k.applyMatrix4(re)}else z.translation!==void 0&&k.position.fromArray(z.translation),z.rotation!==void 0&&k.quaternion.fromArray(z.rotation),z.scale!==void 0&&k.scale.fromArray(z.scale);return R.associations.set(k,{type:"nodes",index:T}),k})}loadScene(T){let E=this.json,N=this.extensions,R=this.json.scenes[T],z=this,G=new ge.Group;R.name&&(G.name=z.createUniqueName(R.name)),tt(G,R),R.extensions&&Ze(N,G,R);let V=R.nodes||[],k=[];for(let re=0,Me=V.length;re<Me;re++)k.push(vn(V[re],G,E,z));return Promise.all(k).then(function(){return G})}}function vn(xe,T,E,N){let R=E.nodes[xe];return N.getDependency("node",xe).then(function(z){if(R.skin===void 0)return z;let G;return N.getDependency("skin",R.skin).then(function(V){G=V;let k=[];for(let re=0,Me=G.joints.length;re<Me;re++)k.push(N.getDependency("node",G.joints[re]));return Promise.all(k)}).then(function(V){return z.traverse(function(k){if(!k.isMesh)return;let re=[],Me=[];for(let fe=0,je=V.length;fe<je;fe++){let rt=V[fe];if(rt){re.push(rt);let Et=new ge.Matrix4;G.inverseBindMatrices!==void 0&&Et.fromArray(G.inverseBindMatrices.array,fe*16),Me.push(Et)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',G.joints[fe])}k.bind(new ge.Skeleton(re,Me),k.matrixWorld)}),z})}).then(function(z){T.add(z);let G=[];if(R.children){let V=R.children;for(let k=0,re=V.length;k<re;k++){let Me=V[k];G.push(vn(Me,z,E,N))}}return Promise.all(G)})}function En(xe,T,E){let N=T.attributes,R=new ge.Box3;if(N.POSITION!==void 0){let V=E.json.accessors[N.POSITION],k=V.min,re=V.max;if(k!==void 0&&re!==void 0){if(R.set(new ge.Vector3(k[0],k[1],k[2]),new ge.Vector3(re[0],re[1],re[2])),V.normalized){let Me=Vt(Ae[V.componentType]);R.min.multiplyScalar(Me),R.max.multiplyScalar(Me)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;let z=T.targets;if(z!==void 0){let V=new ge.Vector3,k=new ge.Vector3;for(let re=0,Me=z.length;re<Me;re++){let fe=z[re];if(fe.POSITION!==void 0){let je=E.json.accessors[fe.POSITION],rt=je.min,Et=je.max;if(rt!==void 0&&Et!==void 0){if(k.setX(Math.max(Math.abs(rt[0]),Math.abs(Et[0]))),k.setY(Math.max(Math.abs(rt[1]),Math.abs(Et[1]))),k.setZ(Math.max(Math.abs(rt[2]),Math.abs(Et[2]))),je.normalized){let nt=Vt(Ae[je.componentType]);k.multiplyScalar(nt)}V.max(k)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}R.expandByVector(V)}xe.boundingBox=R;let G=new ge.Sphere;R.getCenter(G.center),G.radius=R.min.distanceTo(R.max)/2,xe.boundingSphere=G}function An(xe,T,E){let N=T.attributes,R=[];function z(G,V){return E.getDependency("accessor",G).then(function(k){xe.setAttribute(V,k)})}for(let G in N){let V=Qt[G]||G.toLowerCase();V in xe.attributes||R.push(z(N[G],V))}if(T.indices!==void 0&&!xe.index){let G=E.getDependency("accessor",T.indices).then(function(V){xe.setIndex(V)});R.push(G)}return tt(xe,T),En(xe,T,E),Promise.all(R).then(function(){return T.targets!==void 0?Ft(xe,T.targets,E):xe})}function Gn(xe,T){let E=xe.getIndex();if(E===null){let G=[],V=xe.getAttribute("position");if(V!==void 0){for(let k=0;k<V.count;k++)G.push(k);xe.setIndex(G),E=xe.getIndex()}else return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),xe}let N=E.count-2,R=[];if(T===ge.TriangleFanDrawMode)for(let G=1;G<=N;G++)R.push(E.getX(0)),R.push(E.getX(G)),R.push(E.getX(G+1));else for(let G=0;G<N;G++)G%2===0?(R.push(E.getX(G)),R.push(E.getX(G+1)),R.push(E.getX(G+2))):(R.push(E.getX(G+2)),R.push(E.getX(G+1)),R.push(E.getX(G)));R.length/3!==N&&console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");let z=xe.clone();return z.setIndex(R),z}ge.GLTFLoader=l})();Md.exports=bd=ge.GLTFLoader});var Ed=Ht((Sd,Td)=>{var Nl=Tn(),zl=hi(),Bm=_d(),Hm=wd(),Um=new Bm,Gm=new Hm;function km(l,_,M){if(l===void 0)return console.error("Invalid options provided to loadObj()");l=Nl._validate(l,zl.prototype._defaults.loadObj);let b;switch(l.type||(l.type="mtl"),l.type){case"gltf":case"glb":b=Gm;break}Um.load(l.mtl,P,()=>null,W=>{console.warn("No material file found "+W.stack)});function P(W){W&&l.type=="mtl"&&(W.preload(),b.setMaterials(W)),b.load(l.obj,Z=>{let Se=[];switch(l.type){case"mtl":Z=Z.children[0];break;case"gltf":case"glb":case"dae":Se=Z.animations,Z=Z.scene;break;case"fbx":Se=Z.animations;break}Z.animations=Se;let ve=Nl.types.rotation(l.rotation,[0,0,0]),ie=Nl.types.scale(l.scale,[1,1,1]);Z.rotation.set(ve[0],ve[1],ve[2]),Z.scale.set(ie[0],ie[1],ie[2]),l.normalize&&H(Z),Z.name="model";let Y=zl.prototype._makeGroup(Z,l);zl.prototype._addMethods(Y),Y.setAnchor(l.anchor),Y.setCenter(l.adjustment),Y.raycasted=l.raycasted,M(Y),_(Y),Y.setFixedZoom(l.mapScale),Y.idle()},()=>null,Z=>{console.error("Could not load model file: "+l.obj+` 
 `+Z.stack),M("Error loading the model")})}function H(W){W.traverse(function(Z){if(Z.isMesh){let Se;Z.material.type=="MeshStandardMaterial"?(Z.material.metalness&&(Z.material.metalness*=.1),Z.material.glossiness&&(Z.material.glossiness*=.25),Se=new THREE.Color(12,12,12)):Z.material.type=="MeshPhongMaterial"&&(Z.material.shininess=.1,Se=new THREE.Color(20,20,20)),Z.material.specular&&Z.material.specular.isColor&&(Z.material.specular=Se)}})}}Td.exports=Sd=km});var Rd=Ht((Ad,Ld)=>{var Fe=mn(),Qa=Tn(),Vm=hi();function Os(l){l=Qa._validate(l,Vm.prototype._defaults.line);var _=Qa.lnglatsToWorld(l.geometry),M=Qa.normalizeVertices(_),b=Qa.flattenVectors(M.vertices),P=new Fe.LineGeometry;P.setPositions(b);let H=new Fe.LineMaterial({color:l.color,linewidth:l.width,dashed:!1,opacity:l.opacity});return H.resolution.set(window.innerWidth,window.innerHeight),H.isMaterial=!0,H.transparent=!0,H.depthWrite=!1,Os=new Fe.Line2(P,H),Os.position.copy(M.position),Os.computeLineDistances(),Os}Ld.exports=Ad=Os;(function(){let l=new Fe.Box3,_=new Fe.Vector3;class M extends Fe.InstancedBufferGeometry{constructor(){super(),this.type="LineSegmentsGeometry";let P=[-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],H=[-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],W=[0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5];this.setIndex(W),this.setAttribute("position",new Fe.Float32BufferAttribute(P,3)),this.setAttribute("uv",new Fe.Float32BufferAttribute(H,2))}applyMatrix4(P){let H=this.attributes.instanceStart,W=this.attributes.instanceEnd;return H!==void 0&&(H.applyMatrix4(P),W.applyMatrix4(P),H.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}setPositions(P){let H;P instanceof Float32Array?H=P:Array.isArray(P)&&(H=new Float32Array(P));let W=new Fe.InstancedInterleavedBuffer(H,6,1);return this.setAttribute("instanceStart",new Fe.InterleavedBufferAttribute(W,3,0)),this.setAttribute("instanceEnd",new Fe.InterleavedBufferAttribute(W,3,3)),this.computeBoundingBox(),this.computeBoundingSphere(),this}setColors(P){let H;P instanceof Float32Array?H=P:Array.isArray(P)&&(H=new Float32Array(P));let W=new Fe.InstancedInterleavedBuffer(H,6,1);return this.setAttribute("instanceColorStart",new Fe.InterleavedBufferAttribute(W,3,0)),this.setAttribute("instanceColorEnd",new Fe.InterleavedBufferAttribute(W,3,3)),this}fromWireframeGeometry(P){return this.setPositions(P.attributes.position.array),this}fromEdgesGeometry(P){return this.setPositions(P.attributes.position.array),this}fromMesh(P){return this.fromWireframeGeometry(new Fe.WireframeGeometry(P.geometry)),this}fromLineSegments(P){let H=P.geometry;if(H.isGeometry){console.error("THREE.LineSegmentsGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.");return}else H.isBufferGeometry&&this.setPositions(H.attributes.position.array);return this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Fe.Box3);let P=this.attributes.instanceStart,H=this.attributes.instanceEnd;P!==void 0&&H!==void 0&&(this.boundingBox.setFromBufferAttribute(P),l.setFromBufferAttribute(H),this.boundingBox.union(l))}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Fe.Sphere),this.boundingBox===null&&this.computeBoundingBox();let P=this.attributes.instanceStart,H=this.attributes.instanceEnd;if(P!==void 0&&H!==void 0){let W=this.boundingSphere.center;this.boundingBox.getCenter(W);let Z=0;for(let Se=0,ve=P.count;Se<ve;Se++)_.fromBufferAttribute(P,Se),Z=Math.max(Z,W.distanceToSquared(_)),_.fromBufferAttribute(H,Se),Z=Math.max(Z,W.distanceToSquared(_));this.boundingSphere.radius=Math.sqrt(Z),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}toJSON(){}applyMatrix(P){return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."),this.applyMatrix4(P)}}M.prototype.isLineSegmentsGeometry=!0,Fe.LineSegmentsGeometry=M})();(function(){class l extends Fe.LineSegmentsGeometry{constructor(){super(),this.type="LineGeometry"}setPositions(M){for(var b=M.length-3,P=new Float32Array(2*b),H=0;H<b;H+=3)P[2*H]=M[H],P[2*H+1]=M[H+1],P[2*H+2]=M[H+2],P[2*H+3]=M[H+3],P[2*H+4]=M[H+4],P[2*H+5]=M[H+5];return super.setPositions(P),this}setColors(M){for(var b=M.length-3,P=new Float32Array(2*b),H=0;H<b;H+=3)P[2*H]=M[H],P[2*H+1]=M[H+1],P[2*H+2]=M[H+2],P[2*H+3]=M[H+3],P[2*H+4]=M[H+4],P[2*H+5]=M[H+5];return super.setColors(P),this}fromLine(M){var b=M.geometry;if(b.isGeometry){console.error("THREE.LineGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.");return}else b.isBufferGeometry&&this.setPositions(b.attributes.position.array);return this}}l.prototype.isLineGeometry=!0,Fe.LineGeometry=l})();(function(){class l extends Fe.LineSegmentsGeometry{constructor(M){super(),this.type="WireframeGeometry2",this.fromWireframeGeometry(new Fe.WireframeGeometry(M))}}l.prototype.isWireframeGeometry2=!0,Fe.WireframeGeometry2=l})();(function(){Fe.UniformsLib.line={worldUnits:{value:1},linewidth:{value:1},resolution:{value:new Fe.Vector2(1,1)},dashScale:{value:1},dashSize:{value:1},gapSize:{value:1}},Fe.ShaderLib.line={uniforms:Fe.UniformsUtils.merge([Fe.UniformsLib.common,Fe.UniformsLib.fog,Fe.UniformsLib.line]),vertexShader:`
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		varying vec2 vUv;
		varying vec4 worldPos;
		varying vec3 worldStart;
		varying vec3 worldEnd;

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;

			#endif

			float aspect = resolution.x / resolution.y;

			vUv = uv;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			worldStart = start.xyz;
			worldEnd = end.xyz;

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( position.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( position.y > 1.0 || position.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( position.y < 0.5 ) ? start : end;
				worldPos.xyz += offset;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segements overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`,fragmentShader:`
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;
		varying vec4 worldPos;
		varying vec3 worldStart;
		varying vec3 worldEnd;

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		varying vec2 vUv;

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`};class l extends Fe.ShaderMaterial{constructor(M){super({type:"LineMaterial",uniforms:Fe.UniformsUtils.clone(Fe.ShaderLib.line.uniforms),vertexShader:Fe.ShaderLib.line.vertexShader,fragmentShader:Fe.ShaderLib.line.fragmentShader,clipping:!0}),Object.defineProperties(this,{color:{enumerable:!0,get:function(){return this.uniforms.diffuse.value},set:function(b){this.uniforms.diffuse.value=b}},worldUnits:{enumerable:!0,get:function(){return"WORLD_UNITS"in this.defines},set:function(b){b===!0?this.defines.WORLD_UNITS="":delete this.defines.WORLD_UNITS}},linewidth:{enumerable:!0,get:function(){return this.uniforms.linewidth.value},set:function(b){this.uniforms.linewidth.value=b}},dashed:{enumerable:!0,get:function(){return"USE_DASH"in this.defines},set(b){!!b!="USE_DASH"in this.defines&&(this.needsUpdate=!0),b===!0?this.defines.USE_DASH="":delete this.defines.USE_DASH}},dashScale:{enumerable:!0,get:function(){return this.uniforms.dashScale.value},set:function(b){this.uniforms.dashScale.value=b}},dashSize:{enumerable:!0,get:function(){return this.uniforms.dashSize.value},set:function(b){this.uniforms.dashSize.value=b}},dashOffset:{enumerable:!0,get:function(){return this.uniforms.dashOffset.value},set:function(b){this.uniforms.dashOffset.value=b}},gapSize:{enumerable:!0,get:function(){return this.uniforms.gapSize.value},set:function(b){this.uniforms.gapSize.value=b}},opacity:{enumerable:!0,get:function(){return this.uniforms.opacity.value},set:function(b){this.uniforms.opacity.value=b}},resolution:{enumerable:!0,get:function(){return this.uniforms.resolution.value},set:function(b){this.uniforms.resolution.value.copy(b)}},alphaToCoverage:{enumerable:!0,get:function(){return"ALPHA_TO_COVERAGE"in this.defines},set:function(b){!!b!="ALPHA_TO_COVERAGE"in this.defines&&(this.needsUpdate=!0),b===!0?(this.defines.ALPHA_TO_COVERAGE="",this.extensions.derivatives=!0):(delete this.defines.ALPHA_TO_COVERAGE,this.extensions.derivatives=!1)}}}),this.setValues(M)}}l.prototype.isLineMaterial=!0,Fe.LineMaterial=l})();(function(){let l=new Fe.Vector3,_=new Fe.Vector3,M=new Fe.Vector4,b=new Fe.Vector4,P=new Fe.Vector4,H=new Fe.Vector3,W=new Fe.Matrix4,Z=new Fe.Line3,Se=new Fe.Vector3,ve=new Fe.Box3,ie=new Fe.Sphere,Y=new Fe.Vector4;class Ge extends Fe.Mesh{constructor(He=new Fe.LineSegmentsGeometry,yt=new Fe.LineMaterial({color:Math.random()*16777215})){super(He,yt),this.type="LineSegments2"}computeLineDistances(){let He=this.geometry,yt=He.attributes.instanceStart,Rt=He.attributes.instanceEnd,xt=new Float32Array(2*yt.count);for(let Ve=0,it=0,he=yt.count;Ve<he;Ve++,it+=2)l.fromBufferAttribute(yt,Ve),_.fromBufferAttribute(Rt,Ve),xt[it]=it===0?0:xt[it-1],xt[it+1]=xt[it]+l.distanceTo(_);let Tt=new Fe.InstancedInterleavedBuffer(xt,2,1);return He.setAttribute("instanceDistanceStart",new Fe.InterleavedBufferAttribute(Tt,1,0)),He.setAttribute("instanceDistanceEnd",new Fe.InterleavedBufferAttribute(Tt,1,1)),this}raycast(He,yt){He.camera===null&&console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2.');let Rt=He.params.Line2!==void 0&&He.params.Line2.threshold||0,xt=He.ray,Tt=He.camera,Ve=Tt.projectionMatrix,it=this.matrixWorld,he=this.geometry,ze=this.material,We=ze.resolution,j=ze.linewidth+Rt,U=he.attributes.instanceStart,Ae=he.attributes.instanceEnd,Qe=-Tt.near,dt=2*Math.max(j/We.width,j/We.height);he.boundingSphere===null&&he.computeBoundingSphere(),ie.copy(he.boundingSphere).applyMatrix4(it);let Gt=Math.max(Tt.near,ie.distanceToPoint(xt.origin));Y.set(0,0,-Gt,1).applyMatrix4(Tt.projectionMatrix),Y.multiplyScalar(1/Y.w),Y.applyMatrix4(Tt.projectionMatrixInverse);let Qt=Math.abs(dt/Y.w)*.5;if(ie.radius+=Qt,He.ray.intersectsSphere(ie)===!1)return;he.boundingBox===null&&he.computeBoundingBox(),ve.copy(he.boundingBox).applyMatrix4(it);let kt=Math.max(Tt.near,ve.distanceToPoint(xt.origin));Y.set(0,0,-kt,1).applyMatrix4(Tt.projectionMatrix),Y.multiplyScalar(1/Y.w),Y.applyMatrix4(Tt.projectionMatrixInverse);let Mn=Math.abs(dt/Y.w)*.5;if(ve.max.x+=Mn,ve.max.y+=Mn,ve.max.z+=Mn,ve.min.x-=Mn,ve.min.y-=Mn,ve.min.z-=Mn,He.ray.intersectsBox(ve)!==!1){xt.at(1,P),P.w=1,P.applyMatrix4(Tt.matrixWorldInverse),P.applyMatrix4(Ve),P.multiplyScalar(1/P.w),P.x*=We.x/2,P.y*=We.y/2,P.z=0,H.copy(P),W.multiplyMatrices(Tt.matrixWorldInverse,it);for(let Zt=0,Oe=U.count;Zt<Oe;Zt++){M.fromBufferAttribute(U,Zt),b.fromBufferAttribute(Ae,Zt),M.w=1,b.w=1,M.applyMatrix4(W),b.applyMatrix4(W);var Bn=M.z>Qe&&b.z>Qe;if(Bn)continue;if(M.z>Qe){let Ct=M.z-b.z,vt=(M.z-Qe)/Ct;M.lerp(b,vt)}else if(b.z>Qe){let Ct=b.z-M.z,vt=(b.z-Qe)/Ct;b.lerp(M,vt)}M.applyMatrix4(Ve),b.applyMatrix4(Ve),M.multiplyScalar(1/M.w),b.multiplyScalar(1/b.w),M.x*=We.x/2,M.y*=We.y/2,b.x*=We.x/2,b.y*=We.y/2,Z.start.copy(M),Z.start.z=0,Z.end.copy(b),Z.end.z=0;let Ze=Z.closestPointToPointParameter(H,!0);Z.at(Ze,Se);let tt=Fe.MathUtils.lerp(M.z,b.z,Ze),Ft=tt>=-1&&tt<=1,At=H.distanceTo(Se)<j*.5;if(Ft&&At){Z.start.fromBufferAttribute(U,Zt),Z.end.fromBufferAttribute(Ae,Zt),Z.start.applyMatrix4(it),Z.end.applyMatrix4(it);let Ct=new Fe.Vector3,vt=new Fe.Vector3;xt.distanceSqToSegment(Z.start,Z.end,vt,Ct),yt.push({point:vt,pointOnLine:Ct,distance:xt.origin.distanceTo(vt),object:this,face:null,faceIndex:Zt,uv:null,uv2:null})}}}}}Ge.prototype.LineSegments2=!0,Fe.LineSegments2=Ge})();(function(){class l extends Fe.LineSegments2{constructor(M=new Fe.LineGeometry,b=new Fe.LineMaterial({color:Math.random()*16777215})){super(M,b),this.type="Line2"}}l.prototype.isLine2=!0,Fe.Line2=l})();(function(){let l=new Fe.Vector3,_=new Fe.Vector3;class M extends Fe.Mesh{constructor(P=new Fe.LineSegmentsGeometry,H=new Fe.LineMaterial({color:Math.random()*16777215})){super(P,H),this.type="Wireframe"}computeLineDistances(){let P=this.geometry,H=P.attributes.instanceStart,W=P.attributes.instanceEnd,Z=new Float32Array(2*H.count);for(let ve=0,ie=0,Y=H.count;ve<Y;ve++,ie+=2)l.fromBufferAttribute(H,ve),_.fromBufferAttribute(W,ve),Z[ie]=ie===0?0:Z[ie-1],Z[ie+1]=Z[ie]+l.distanceTo(_);let Se=new Fe.InstancedInterleavedBuffer(Z,2,1);return P.setAttribute("instanceDistanceStart",new Fe.InterleavedBufferAttribute(Se,1,0)),P.setAttribute("instanceDistanceEnd",new Fe.InterleavedBufferAttribute(Se,1,1)),this}}M.prototype.isWireframe=!0,Fe.Wireframe=M})()});var Dd=Ht((Cd,Pd)=>{var Wm=Tn(),qm=Cs(),jm=hi(),$a=mn(),Xm=Ds();function Zm(l,_){l=Wm._validate(l,jm.prototype._defaults.tube);let M=[];l.geometry.forEach(Z=>{M.push(new $a.Vector3(Z[0],Z[1],Z[2]))});let b=new $a.CatmullRomCurve3(M),P=new $a.TubeGeometry(b,M.length,l.radius,l.sides,!1),H=qm(l),W=new $a.Mesh(P,H);return new Xm({obj:W,units:l.units,anchor:l.anchor,adjustment:l.adjustment,bbox:l.bbox,tooltip:l.tooltip,raycasted:l.raycasted})}Pd.exports=Cd=Zm});var Fd=Ht((Id,Od)=>{var Ym=Ps();function Jm(l){this.map=l,this.renderer=new Ym.CSS2DRenderer,this.renderer.setSize(this.map.getCanvas().clientWidth,this.map.getCanvas().clientHeight),this.renderer.domElement.style.position="absolute",this.renderer.domElement.id="labelCanvas",this.renderer.domElement.style.top=0,this.renderer.domElement.style.zIndex="0",this.map.getCanvasContainer().appendChild(this.renderer.domElement),this.scene,this.camera,this.dispose=function(){this.map.getCanvasContainer().removeChild(this.renderer.domElement),this.renderer.domElement.remove(),this.renderer={}},this.setSize=function(_,M){this.renderer.setSize(_,M)},this.map.on("resize",function(){this.renderer?.setSize(this.map.getCanvas().clientWidth,this.map.getCanvas().clientHeight)}.bind(this)),this.state={reset:function(){}},this.render=async function(_,M){return this.scene=_,this.camera=M,new Promise(b=>{b(this.renderer.render(_,M))})},this.toggleLabels=async function(_,M){return new Promise(b=>{b(this.setVisibility(_,M,this.scene,this.camera,this.renderer))})},this.setVisibility=function(_,M,b,P,H){var W=this.renderer.cacheList;W.forEach(function(Z){Z.visible!=M&&Z.layer===_&&(M&&Z.alwaysVisible||!M)&&(Z.visible=M,H.renderObject(Z,b,P))})}}Od.exports=Id=Jm});var Bd=Ht((Nd,zd)=>{var Ug=Dl(),Bl=class{constructor(_,M){this.id=_.layerId,this.type="custom",this.renderingMode="3d",this.opacity=.5,this.buildingsLayerId=_.buildingsLayerId,this.minAltitude=_.minAltitude||.1,this.tb=M}onAdd(_,M){this.map=_;let b=`
			uniform mat4 u_matrix;
			uniform float u_height_factor;
			uniform float u_altitude;
			uniform float u_azimuth;
			attribute vec2 a_pos;
			attribute vec4 a_normal_ed;
			attribute lowp vec2 a_base;
			attribute lowp vec2 a_height;
			void main() {
				float base = max(0.0, a_base.x);
				float height = max(0.0, a_height.x);
				float t = mod(a_normal_ed.x, 2.0);
				vec4 pos = vec4(a_pos, t > 0.0 ? height : base, 1);
				float len = pos.z * u_height_factor / tan(u_altitude);
				pos.x += cos(u_azimuth) * len;
				pos.y += sin(u_azimuth) * len;
				pos.z = 0.0;
				gl_Position = u_matrix * pos;
			}
			`,P=`
			void main() {
				gl_FragColor = vec4(0.0, 0.0, 0.0, 0.7);
			}
			`,H=M.createShader(M.VERTEX_SHADER);M.shaderSource(H,b),M.compileShader(H);let W=M.createShader(M.FRAGMENT_SHADER);M.shaderSource(W,P),M.compileShader(W),this.program=M.createProgram(),M.attachShader(this.program,H),M.attachShader(this.program,W),M.linkProgram(this.program),M.validateProgram(this.program),this.uMatrix=M.getUniformLocation(this.program,"u_matrix"),this.uHeightFactor=M.getUniformLocation(this.program,"u_height_factor"),this.uAltitude=M.getUniformLocation(this.program,"u_altitude"),this.uAzimuth=M.getUniformLocation(this.program,"u_azimuth"),this.aPos=M.getAttribLocation(this.program,"a_pos"),this.aNormal=M.getAttribLocation(this.program,"a_normal_ed"),this.aBase=M.getAttribLocation(this.program,"a_base"),this.aHeight=M.getAttribLocation(this.program,"a_height")}render(_,M){_.useProgram(this.program);let b=this.map.style.sourceCaches.composite,P=b.getVisibleCoordinates().reverse(),H=this.map.getLayer(this.buildingsLayerId),W=this.map.painter.context,{lng:Z,lat:Se}=this.map.getCenter(),ve=this.tb.getSunPosition(this.tb.lightDateTime,[Z,Se]);_.uniform1f(this.uAltitude,ve.altitude>this.minAltitude?ve.altitude:0),_.uniform1f(this.uAzimuth,ve.azimuth+3*Math.PI/2),_.enable(_.BLEND),_.blendFunc(_.SRC_ALPHA,_.ONE_MINUS_SRC_ALPHA);var ie=_.getExtension("EXT_blend_minmax");_.disable(_.DEPTH_TEST);for(let Y of P){let Ge=b.getTile(Y),qe=Ge.getBucket(H);if(!qe)continue;let[He,yt]=qe.programConfigurations.programConfigurations[this.buildingsLayerId]._buffers;_.uniformMatrix4fv(this.uMatrix,!1,Y.posMatrix),_.uniform1f(this.uHeightFactor,Math.pow(2,Y.overscaledZ)/Ge.tileSize/8);for(let Rt of qe.segments.get()){let xt=W.currentNumAttributes||0,Tt=2;for(let it=Tt;it<xt;it++)_.disableVertexAttribArray(it);let Ve=Rt.vertexOffset||0;_.enableVertexAttribArray(this.aPos),_.enableVertexAttribArray(this.aNormal),_.enableVertexAttribArray(this.aHeight),_.enableVertexAttribArray(this.aBase),qe.layoutVertexBuffer.bind(),_.vertexAttribPointer(this.aPos,2,_.SHORT,!1,12,12*Ve),_.vertexAttribPointer(this.aNormal,4,_.SHORT,!1,12,4+12*Ve),He.bind(),_.vertexAttribPointer(this.aHeight,1,_.FLOAT,!1,4,4*Ve),yt.bind(),_.vertexAttribPointer(this.aBase,1,_.FLOAT,!1,4,4*Ve),qe.indexBuffer.bind(),W.currentNumAttributes=Tt,_.drawElements(_.TRIANGLES,Rt.primitiveLength*3,_.UNSIGNED_SHORT,Rt.primitiveOffset*3*2)}}}};zd.exports=Nd=Bl});var Gd=Ht((Hd,Ud)=>{Ud.exports=Hd=function(l,_){let M=l.x-_.x,b=l.y-_.y;return Math.sqrt(M*M+b*b)}});var Wd=Ht((kd,Vd)=>{var Km=Gd(),Qm=25,$m=250;function eg(l,_,M={}){let b=M.tolerance!=null?M.tolerance:Qm,P=M.interval!=null?M.interval:$m;return l.point=l.point||_.point,l.time=l.time||_.time,Km(l.point,_.point)<b&&_.time-l.time<P}Vd.exports=kd=eg});var Zd=Ht((jd,Xd)=>{var Lt=mn(),tg=Vu(),Gi=Tn(),Hl=Dl(),Ul=Xa(),ng=hi(),ig=Cs(),rg=ld(),sg=ud(),ag=fd(),og=yd(),qd=Ed(),lg=Ds(),cg=Rd(),hg=Dd(),ug=Fd(),dg=Bd(),pg=Wd();function Fs(l,_,M){this.init(l,_,M)}Fs.prototype={repaint:function(){this.map.repaint=!0},init:function(l,_,M){this.options=Gi._validate(M||{},fg),this.map=l,this.map.tb=this,this.objects=new ng,this.mapboxVersion=parseFloat(this.map.version),this.renderer=new Lt.WebGLRenderer({alpha:!0,antialias:!0,preserveDrawingBuffer:M.preserveDrawingBuffer,canvas:l.getCanvas(),context:_}),this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.setSize(this.map.getCanvas().clientWidth,this.map.getCanvas().clientHeight),this.renderer.outputEncoding=Lt.sRGBEncoding,this.renderer.autoClear=!1,this.labelRenderer=new ug(this.map),this.scene=new Lt.Scene,this.world=new Lt.Group,this.world.name="world",this.scene.add(this.world),this.objectsCache=new Map,this.zoomLayers=[],this.fov=this.options.fov,this.orthographic=this.options.orthographic||!1,this.raycaster=new Lt.Raycaster,this.raycaster.layers.set(0),this.mapCenter=this.map.getCenter(),this.mapCenterUnits=Gi.projectToWorld([this.mapCenter.lng,this.mapCenter.lat]),this.lightDateTime=new Date,this.lightLng=this.mapCenter.lng,this.lightLat=this.mapCenter.lat,this.sunPosition,this.rotationStep=5,this.gridStep=7,this.altitudeStep=.1,this.defaultCursor="default",this.lights=structuredClone(this.initLights),this.options.defaultLights&&this.defaultLights(),this.options.realSunlight&&this.realSunlight(this.options.realSunlightHelper),this.skyLayerName="sky-layer",this.terrainSourceName="mapbox-dem",this.terrainExaggeration=1,this.terrainLayerName="",this.enableSelectingFeatures=this.options.enableSelectingFeatures||!1,this.enableSelectingObjects=this.options.enableSelectingObjects||!1,this.enableDraggingObjects=this.options.enableDraggingObjects||!1,this.enableRotatingObjects=this.options.enableRotatingObjects||!1,this.enableTooltips=this.options.enableTooltips||!1,this.multiLayer=this.options.multiLayer||!1,this.enableHelpTooltips=this.options.enableHelpTooltips||!1,this.map.on("style.load",function(){this.tb.zoomLayers=[],this.tb.options.multiLayer&&this.addLayer({id:"threebox_layer",type:"custom",renderingMode:"3d",map:this,onAdd:function(P,H){},render:function(P,H){this.map.tb.update()}}),this.once("idle",()=>{this.tb.setObjectsScale()}),this.tb.options.sky&&(this.tb.sky=!0),this.tb.options.terrain&&(this.tb.terrain=!0),["satellite","mapbox-mapbox-satellite","satelliteLayer"].forEach(P=>{this.getLayer(P)&&(this.tb.terrainLayerName=P)})}),this.map.on("load",function(){this.touchstartInfo={},this.selectedObject,this.selectedFeature,this.draggedObject,this.draggedAction,this.overedObject,this.overedFeature;let b=this.getCanvasContainer(),P,H=[],W,Z,Se,ve,ie=(he,ze)=>{let We=0;do isNaN(he[ze])||(We+=he[ze]);while(he=he.offsetParent);return We};function Y(he){if(he.originalEvent.type.includes("touch")){let ze=he.originalEvent.targetTouches[0];if(ze.clientX!=null)return{x:ze.pageX-ie(b,"offsetLeft"),y:ze.clientY-ie(b,"offsetTop")}}return{x:he.originalEvent.clientX-ie(b,"offsetLeft"),y:he.originalEvent.clientY-ie(b,"offsetTop")}}this.unselectObject=function(){this.selectedObject.selected=!1,this.selectedObject=null},this.outObject=function(){this.overedObject.over=!1,this.overedObject=null},this.unselectFeature=function(he){typeof he.id>"u"||(this.setFeatureState({source:he.source,sourceLayer:he.sourceLayer,id:he.id},{select:!1}),this.removeTooltip(he),he=this.queryRenderedFeatures({layers:[he.layer.id],filter:["==",["id"],he.id]})[0],he&&this.fire("SelectedFeatureChange",{detail:he}),this.selectedFeature=null)},this.selectFeature=function(he){this.selectedFeature=he,this.setFeatureState({source:this.selectedFeature.source,sourceLayer:this.selectedFeature.sourceLayer,id:this.selectedFeature.id},{select:!0}),this.selectedFeature=this.queryRenderedFeatures({layers:[this.selectedFeature.layer.id],filter:["==",["id"],this.selectedFeature.id]})[0],this.addTooltip(this.selectedFeature),this.fire("SelectedFeatureChange",{detail:this.selectedFeature})},this.outFeature=function(he){this.overedFeature&&typeof this.overedFeature<"u"&&this.overedFeature.id!=he&&(l.setFeatureState({source:this.overedFeature.source,sourceLayer:this.overedFeature.sourceLayer,id:this.overedFeature.id},{hover:!1}),this.removeTooltip(this.overedFeature),this.overedFeature=null)},this.addTooltip=function(he){if(!this.tb.enableTooltips)return;let ze=this.tb.getFeatureCenter(he),We=this.tb.tooltip({text:he.properties.name||he.id||he.type,mapboxStyle:!0,feature:he});We.setCoords(ze),this.tb.add(We,he.layer.id),he.tooltip=We,he.tooltip.tooltip.visible=!0},this.removeTooltip=function(he){he.tooltip&&(he.tooltip.visibility=!1,this.tb.remove(he.tooltip),he.tooltip=null)},l.onContextMenu=function(he){alert("contextMenu")},this.selectObject=function(he){let We=he.getSize(),U=Math.sqrt(Math.pow(We.x,2)+Math.pow(We.y,2))/2*tb.projectedUnitsPerMeter(l.getCenter().lat)+.0075;if(U=+(U*1.15).toFixed(5),U=Math.max(U,.3),this.selectedFeature&&this.unselectFeature(this.selectedFeature),!this.selectedObject)this.selectedObject=he,this.selectedObject.selected=!0;else if(this.selectedObject.uuid!=he.uuid)this.selectedObject.selected=!1,he.selected=!0,this.selectedObject=he;else if(this.selectedObject.uuid==he.uuid){this.unselectObject(),this.isDrawing=!1,this.draggedObject=null,this.selectedObject=null,this.tb.remove(this.ring),this.tb.remove(this.displayRing);return}this.ring&&tb.remove(this.ring),this.displayRing&&tb.remove(this.displayRing);let Ae=new Lt.TorusGeometry(U,.0075*4,30,25),Qe=new Lt.MeshStandardMaterial({color:16760832,side:Lt.BackSide,transparent:!0,opacity:0,visible:!1}),dt=new Lt.Mesh(Ae,Qe),Gt=new Lt.TorusGeometry(U,.0075,30,50),Qt=new Lt.MeshStandardMaterial({color:16760832,side:Lt.DoubleSide}),kt=new Lt.Mesh(Gt,Qt),Mn=We.z/4,Bn=he.coordinates;this.ring=tb.Object3D({obj:dt,anchor:"center",bbox:!1}),this.ring.setCoords([...Bn,Mn-this.ring.getSize().y/2]),this.ring.userData.ring="hidden",this.displayRing=tb.Object3D({obj:kt,anchor:"center",bbox:!1,raycasted:!1}),this.displayRing.setCoords([...Bn,Mn]),tb.add(this.displayRing),tb.add(this.ring),this.ring.addEventListener("ObjectMouseOver",()=>{this.getCanvasContainer().style.removeProperty("cursor"),this.getCanvasContainer().classList.add("cursor-rotate"),kt.material.color.setHex(14352898),this.once("mousedown",Zt),this.once("touchstart",Zt),this.once("touchend",Oe),this.once("mouseup",Oe)},!1),this.ring.addEventListener("ObjectMouseOut",()=>{this.off("mousedown",Zt),this.off("touchstart",Zt),kt.material.color.setHex(16760832),this.getCanvasContainer().classList.remove("cursor-rotate")},!1);function Zt(Ze){this.allowRotate=!0}function Oe(Ze){this.allowRotate=!1}this.once("cancel",()=>{this.allowRotate=!1,kt.material.color.setHex(16760832),this.getCanvasContainer().classList.remove("cursor-rotate")}),this.selectedObject.dispatchEvent({type:"Wireframed",detail:this.selectedObject}),this.selectedObject.dispatchEvent({type:"IsPlayingChanged",detail:this.selectedObject}),this.repaint=!0},this.onTap=this.onClick=function(he){this.ring!==void 0&&this.tb.remove(this.ring),this.displayRing!==void 0&&this.tb.remove(this.displayRing);let ze,We=[];if(l.tb.enableSelectingObjects&&(We=this.tb.queryRenderedFeatures(he.point)),ze=typeof We[0]=="object",ze){he.originalEvent.cancelBubble=!0,this.isDrawing=!0,this.fire("cancelActions");let j=Fs.prototype.findParent3DObject(We[0]);j&&this.selectObject(j),he.preventDefault!==void 0&&he.preventDefault()}else{let j=[];if(l.tb.enableSelectingFeatures&&(j=this.queryRenderedFeatures(he.point)),j.length>0){if(j[0].layer.type=="fill-extrusion"&&typeof j[0].id<"u"){if(this.selectedObject&&this.unselectObject(),!this.selectedFeature)this.selectFeature(j[0]);else if(this.selectedFeature.id!=j[0].id)this.unselectFeature(this.selectedFeature),this.selectFeature(j[0]);else if(this.selectedFeature.id==j[0].id){this.unselectFeature(this.selectedFeature);return}}}else if(this.selectedObject!==null&&this.selectedObject!==void 0){this.unselectObject(),this.isDrawing=!1,this.draggedObject=null,this.selectedObject=null,this.tb.remove(this.ring),this.tb.remove(this.displayRing);return}}},this.onTouchMove=this.onMouseMove=function(he){let ze=Y(he);if((this.allowRotate||he.originalEvent.altKey)&&this.draggedObject){if(!l.tb.enableRotatingObjects)return;this.draggedAction="rotate",this.getCanvasContainer().style.removeProperty("cursor");let U={x:0,y:0,z:Math.round(ve[2]+~~((ze.x-P.x)/this.tb.rotationStep)%360*this.tb.rotationStep%360)};this.draggedObject.setRotation(U),l.tb.enableHelpTooltips&&this.draggedObject.addHelp("rot: "+U.z+"&#176;");return}if(this.draggedObject){if(!l.tb.enableDraggingObjects)return;this.draggedAction="translate",this.getCanvasContainer().style.cursor="move";let U=he.lngLat,Ae=[Number((U.lng+W).toFixed(this.tb.gridStep)),Number((U.lat+Z).toFixed(this.tb.gridStep)),this.draggedObject.modelHeight];if(this.ring&&this.displayRing){let Qe=this.draggedObject.getSize().z/4;this.ring.setCoords([Ae[0],Ae[1],Qe-this.ring.getSize().y/2]),this.displayRing.setCoords([Ae[0],Ae[1],Qe])}this.draggedObject.setCoords(Ae),l.tb.enableHelpTooltips&&this.draggedObject.addHelp("lng: "+Ae[0]+"&#176;, lat: "+Ae[1]+"&#176;");return}let We,j=[];if(l.tb.enableSelectingObjects&&(j=this.tb.queryRenderedFeatures(he.point)),We=typeof j[0]=="object",We){let U=Fs.prototype.findParent3DObject(j[0]);U.userData.type!=null&&U.userData.type!=null&&this.overedObject&&(this.outObject(),this.fire("cancel")),U&&(this.outFeature(this.overedFeature),this.getCanvasContainer().style.cursor="pointer",!this.selectedObject||U.uuid!=this.selectedObject.uuid?(this.overedObject&&this.overedObject.uuid!=U.uuid&&this.outObject(),U.over=!0,this.overedObject=U):this.selectedObject&&U.uuid==this.selectedObject.uuid&&(U.over=!0,this.overedObject=U),this.repaint=!0,he.preventDefault())}else{this.getCanvasContainer().style.removeProperty("cursor"),this.overedObject&&this.outObject();let U=[];l.tb.enableSelectingFeatures&&(U=this.queryRenderedFeatures(he.point)),U.length>0&&(this.outFeature(U[0]),U[0].layer.type=="fill-extrusion"&&typeof U[0].id<"u"&&(!this.selectedFeature||this.selectedFeature.id!=U[0].id)&&(this.getCanvasContainer().style.cursor="pointer",this.overedFeature=U[0],this.setFeatureState({source:this.overedFeature.source,sourceLayer:this.overedFeature.sourceLayer,id:this.overedFeature.id},{hover:!0}),this.overedFeature=l.queryRenderedFeatures({layers:[this.overedFeature.layer.id],filter:["==",["id"],this.overedFeature.id]})[0],this.addTooltip(this.overedFeature)))}},this.onTouchStart=this.onMouseDown=function(he){let ze,We=[];if(l.tb.enableSelectingObjects&&(We=this.tb.queryRenderedFeatures(he.point)),ze=typeof We[0]=="object",!ze&&this.selectedObject&&(this.unselectObject(),this.isDrawing=!1,this.draggedObject=null,this.selectedObject=null,this.tb.remove(this.ring),this.tb.remove(this.displayRing)),this.touchStartInfo={time:new Date().getTime(),point:he.point},he.type=="touchstart"){let j=this.tb.queryRenderedFeatures(he.point);if(typeof j[0]=="object"){let U=Fs.prototype.findParent3DObject(j[0]);this.outFeature(this.overedFeature),U&&(U.over=!0,this.overedObject=U)}}this.selectedObject&&(!l.tb.enableDraggingObjects&&!l.tb.enableRotatingObjects||(he.preventDefault(),l.getCanvasContainer().style.cursor="move",l.once("mouseup",this.onMouseUp),this.draggedObject=this.selectedObject,P=Y(he),H=this.draggedObject.coordinates,ve=Gi.degreeify(this.draggedObject.rotation),W=H[0]-he.lngLat.lng,Z=H[1]-he.lngLat.lat,Se=-this.draggedObject.modelHeight-he.point.y*this.tb.altitudeStep))},this.onTouchEnd=this.onMouseUp=function(he){if(this.allowRotate=!1,this.getCanvasContainer().style.removeProperty("cursor"),he.type=="touchend"&&this.overedObject&&this.outObject(),pg(this.touchStartInfo,{time:new Date().getTime(),point:he.point})){this.fire("tap",he);return}this.off("mouseup",this.onMouseUp),this.off("mouseout",this.onMouseUp),this.dragPan.enable(),this.scrollZoom.enable(),this.dragRotate.enable(),this.touchZoomRotate.enable(),this.draggedObject&&(this.draggedObject.dispatchEvent({type:"ObjectDragged",detail:{draggedObject:this.draggedObject,draggedAction:this.draggedAction}}),this.draggedObject.removeHelp(),this.draggedObject=null,this.draggedAction=null)},this.onMouseOut=function(he){if(this.getCanvasContainer().style.removeProperty("cursor"),this.overedObject&&this.outObject(),this.overedFeature){let ze=this.queryRenderedFeatures(he.point);ze.length>0&&this.overedFeature.id!=ze[0].id&&this.outFeature(ze[0])}},this.onZoom=function(he){this.tb.zoomLayers.forEach(ze=>{this.tb.toggleLayer(ze)}),this.tb.setObjectsScale()};let Ge=!1,qe=!1,He=17,yt=91,Rt=16,xt=83,Tt=68;function Ve(he){(he.which===He||he.which===yt)&&(Ge=!0),he.which===Rt&&(qe=!0);let ze=this.selectedObject;if(qe&&he.which===xt&&ze){let We=Gi.toDecimal;if(ze.help)ze.removeHelp();else{let j=ze.modelSize,U=1;ze.userData.units!=="meters"&&(U=Gi.projectedUnitsPerMeter(ze.coordinates[1]),U||(U=1),U=We(U,7)),l.tb.enableHelpTooltips&&ze.addHelp("size(m): "+We(j.x/U,3)+" W, "+We(j.y/U,3)+" L, "+We(j.z/U,3)+" H"),this.repaint=!0}return!1}}function it(he){(he.which==He||he.which==yt)&&(Ge=!1),he.which===Rt&&(qe=!1)}this.on("click",this.onClick),this.on("mousemove",this.onMouseMove),this.on("mouseout",this.onMouseOut),this.on("mousedown",this.onMouseDown),this.on("zoom",this.onZoom),this.on("zoomend",this.onZoom),this.on("touchstart",this.onTouchStart),this.on("touchmove",this.onTouchMove),this.on("touchend",this.onTouchEnd),this.on("tap",this.onTap),document.addEventListener("keydown",Ve.bind(this),!0),document.addEventListener("keyup",it.bind(this))})},get sky(){return this.options.sky},set sky(l){l?this.createSkyLayer():this.removeLayer(this.skyLayerName),this.options.sky=l},get terrain(){return this.options.terrain},set terrain(l){if(this.terrainLayerName="",l)this.createTerrainLayer();else{if(this.mapboxVersion<2){console.warn("Terrain layer are only supported by Mapbox-gl-js > v2.0");return}this.map.getTerrain()&&(this.map.setTerrain(null),this.map.removeSource(this.terrainSourceName))}this.options.terrain=l},get fov(){return this.options.fov},set fov(l){this.camera instanceof Lt.PerspectiveCamera&&this.options.fov!==l&&(this.map.transform.fov=l,this.camera.fov=this.map.transform.fov,this.cameraSync.setupCamera(),this.map.repaint=!0,this.options.fov=l)},get orthographic(){return this.options.orthographic},set orthographic(l){let _=this.map.getCanvas().clientHeight,M=this.map.getCanvas().clientWidth;l?(this.map.transform.fov=0,this.camera=new Lt.OrthographicCamera(M/-2,M/2,_/2,_/-2,.1,1e21)):(this.map.transform.fov=this.fov,this.camera=new Lt.PerspectiveCamera(this.map.transform.fov,M/_,.1,1e21)),this.camera.layers.enable(0),this.camera.layers.enable(1),this.cameraSync=new tg(this.map,this.camera,this.world),this.map.repaint=!0,this.options.orthographic=l},createSkyLayer:function(){if(this.mapboxVersion<2){console.warn("Sky layer are only supported by Mapbox-gl-js > v2.0"),this.options.sky=!1;return}this.map.getLayer(this.skyLayerName)||(this.map.addLayer({id:this.skyLayerName,type:"sky",paint:{"sky-opacity":["interpolate",["linear"],["zoom"],0,0,5,.3,8,1],"sky-type":"atmosphere","sky-atmosphere-sun":this.getSunSky(this.lightDateTime),"sky-atmosphere-sun-intensity":10}}),this.map.once("idle",()=>{this.setSunlight(),this.repaint()}))},createTerrainLayer:function(){if(this.mapboxVersion<2){console.warn("Terrain layer are only supported by Mapbox-gl-js > v2.0"),this.options.terrain=!1;return}this.map.getTerrain()||(this.map.addSource(this.terrainSourceName,{type:"raster-dem",url:"mapbox://mapbox.mapbox-terrain-dem-v1",tileSize:512,maxzoom:14}),this.map.setTerrain({source:this.terrainSourceName,exaggeration:this.terrainExaggeration}),this.map.once("idle",()=>{this.cameraSync.updateCamera(),this.repaint()}))},createShadowLayer:function(){if(this.shadowPlane)return;let l=3e3,_=new Lt.PlaneBufferGeometry(l,l),M=new Lt.ShadowMaterial;M.opacity=.5;let b=new Lt.Mesh(_,M);b.name="shadowPlane",b.layers.enable(1),b.layers.disable(0),b.receiveShadow=!0,this.shadowPlane=b,this.scene.add(b)},sphere:function(l){return this.setDefaultView(l,this.options),rg(l,this.world)},line:cg,label:ag,tooltip:og,tube:function(l){return this.setDefaultView(l,this.options),hg(l,this.world)},extrusion:function(l){return this.setDefaultView(l,this.options),sg(l)},Object3D:function(l){return this.setDefaultView(l,this.options),lg(l)},loadObj:async function(_,M){if(this.setDefaultView(_,this.options),_.clone===!1)return new Promise(async b=>{qd(_,M,async P=>{b(P)})});{let b=this.objectsCache.get(_.obj);b?b.promise.then(P=>{M(P.duplicate(_))}).catch(P=>{this.objectsCache.delete(_.obj),console.error("Could not load model file: "+_.obj)}):this.objectsCache.set(_.obj,{promise:new Promise(async(P,H)=>{qd(_,M,async W=>{W.duplicate?P(W.duplicate()):H(W)})})})}},material:function(l){return ig(l)},initLights:{ambientLight:null,dirLight:null,dirLightBack:null,dirLightHelper:null,hemiLight:null,pointLight:null},utils:Gi,SunCalc:Hl,Constants:Ul,projectToWorld:function(l){return this.utils.projectToWorld(l)},unprojectFromWorld:function(l){return this.utils.unprojectFromWorld(l)},projectedUnitsPerMeter:function(l){return this.utils.projectedUnitsPerMeter(l)},getFeatureCenter:function(_,M,b){return Gi.getFeatureCenter(_,M,b)},getObjectHeightOnFloor:function(l,_,M){return Gi.getObjectHeightOnFloor(l,_,M)},queryRenderedFeatures:function(l){let _=new Lt.Vector2;return _.x=l.x/this.map.transform.width*2-1,_.y=1-l.y/this.map.transform.height*2,this.raycaster.setFromCamera(_,this.camera),this.raycaster.intersectObjects(this.world.children,!0)},findParent3DObject:function(l){var _;return l.object.traverseAncestors(function(M){M.parent&&M.parent.type=="Group"&&M.userData.obj&&(_=M)}),_},setLayoutProperty:function(l,_,M){this.map.setLayoutProperty(l,_,M),M!=null&&_==="visibility"&&this.world.children.filter(b=>b.layer===l).forEach(b=>{b.visibility=M})},setLayerZoomRange:function(l,_,M){this.map.getLayer(l)&&(this.map.setLayerZoomRange(l,_,M),this.zoomLayers.includes(l)||this.zoomLayers.push(l),this.toggleLayer(l))},setLayerHeigthProperty:function(l,_){let M=this.map.getLayer(l);if(M)if(M.type=="fill-extrusion"){let b=this.map.getStyle().sources[M.source].data;b.features.forEach(function(H){H.properties.level=_}),this.map.getSource(M.source).setData(b)}else M.type=="custom"&&this.world.children.forEach(function(b){let P=b.userData.feature;if(P&&P.layer===l){let H=this.tb.getFeatureCenter(P,b,_);b.setCoords(H)}})},setObjectsScale:function(){this.world.children.filter(l=>l.fixedZoom!=null).forEach(l=>{l.setObjectScale(this.map.transform.scale)})},setStyle:function(l,_){this.clear().then(()=>{this.map.setStyle(l,_)})},toggleLayer:function(l,_=!0){let M=this.map.getLayer(l);if(M){if(!_){this.toggle(M.id,!1);return}let b=this.map.getZoom();if(M.minzoom&&b<M.minzoom){this.toggle(M.id,!1);return}if(M.maxzoom&&b>=M.maxzoom){this.toggle(M.id,!1);return}this.toggle(M.id,!0)}},toggle:function(l,_){this.setLayoutProperty(l,"visibility",_?"visible":"none"),this.labelRenderer.toggleLabels(l,_)},update:function(){this.map.repaint&&(this.map.repaint=!1);var l=Date.now();this.objects.animationManager.update(l),this.updateLightHelper(),this.renderer.resetState(),this.renderer.render(this.scene,this.camera),this.labelRenderer.render(this.scene,this.camera),this.options.passiveRendering===!1&&this.map.triggerRepaint()},add:function(l,_,M){if(!this.enableTooltips&&l.tooltip&&(l.tooltip.visibility=!1),this.world.add(l),_){l.layer=_,l.source=M;let b=this.map.getLayer(_);if(b){let P=b.visibility,H=typeof P>"u";l.visibility=!!(H||P==="visible")}}},removeByName:function(l){let _=this.world.getObjectByName(l);_&&this.remove(_)},remove:function(l){this.map.selectedObject&&l.uuid==this.map.selectedObject.uuid&&this.map.unselectObject(),this.map.draggedObject&&l.uuid==this.map.draggedObject.uuid&&(this.map.draggedObject=null),l.dispose&&l.dispose(),this.map.isDrawing=!1,this.world.remove(l),l=null},clear:async function(l=null,_=!1){return new Promise((M,b)=>{let P=[];this.world.children.forEach(function(H){P.push(H)});for(let H=0;H<P.length;H++){let W=P[H];(W.layer===l||!l)&&this.remove(W)}_&&this.objectsCache.forEach(H=>{H.promise.then(W=>{W.dispose(),W=null})}),M("clear")})},removeLayer:function(l){this.clear(l,!0).then(()=>{this.map.removeLayer(l)})},getSunPosition:function(l,_){return Hl.getPosition(l||Date.now(),_[1],_[0])},getSunTimes:function(l,_){return Hl.getTimes(l,_[1],_[0],_[2]?_[2]:0)},setBuildingShadows:function(l){if(this.map.getLayer(l.buildingsLayerId)){let _=new dg(l,this);this.map.addLayer(_,l.buildingsLayerId)}else console.warn("The layer '"+l.buildingsLayerId+"' does not exist in the map.")},setSunlight:function(l,_){if(!this.lights.dirLight||!this.options.realSunlight){console.warn("To use setSunlight it's required to set realSunlight : true in Threebox initial options.");return}l||(l=this.lightDateTime??new Date);var M=new Date(l.getTime());if(_?_.lng&&_.lat?this.mapCenter=_:this.mapCenter={lng:_[0],lat:_[1]}:this.mapCenter=this.map.getCenter(),this.lightDateTime&&this.lightDateTime.getTime()===M.getTime()&&this.lightLng===this.mapCenter.lng&&this.lightLat===this.mapCenter.lat)return;this.lightDateTime=M,this.lightLng=this.mapCenter.lng,this.lightLat=this.mapCenter.lat,this.sunPosition=this.getSunPosition(M,[this.mapCenter.lng,this.mapCenter.lat]);let b=this.sunPosition.altitude,P=Math.PI+this.sunPosition.azimuth,H=Ul.WORLD_SIZE/2,W=Math.sin(b),Z=Math.cos(b),Se=Math.cos(P)*Z,ve=Math.sin(P)*Z;if(this.lights.dirLight.position.set(ve,Se,W),this.lights.dirLight.position.multiplyScalar(H),this.lights.dirLight.intensity=Math.max(W,0),this.lights.hemiLight.intensity=Math.max(W*1,.1),this.lights.dirLight.updateMatrixWorld(),this.updateLightHelper(),this.map.loaded()){this.updateSunGround(this.sunPosition);let ie={anchor:"map",position:[3,180+this.sunPosition.azimuth*180/Math.PI,90-this.sunPosition.altitude*180/Math.PI],intensity:Math.cos(this.sunPosition.altitude),color:`hsl(40, ${50*Math.cos(this.sunPosition.altitude)}%, ${Math.max(20,20+96*Math.sin(this.sunPosition.altitude))}%)`};this.map.setLights([{id:"flat",type:"flat",properties:ie}]),this.sky&&this.updateSunSky(this.getSunSky(M,this.sunPosition))}},getSunSky:function(l,_){if(!_){var M=this.map.getCenter();_=this.getSunPosition(l||Date.now(),[M.lng,M.lat])}var b=180+_.azimuth*180/Math.PI,P=90-_.altitude*180/Math.PI;return[b,P]},updateSunSky:function(l){this.sky&&this.map.setPaintProperty(this.skyLayerName,"sky-atmosphere-sun",l)},updateSunGround:function(l){this.terrainLayerName!=""&&this.map.setPaintProperty(this.terrainLayerName,"raster-opacity",Math.max(Math.min(1,l.altitude*4),.25))},updateLightHelper:function(){this.lights.dirLightHelper&&(this.lights.dirLightHelper.position.setFromMatrixPosition(this.lights.dirLight.matrixWorld),this.lights.dirLightHelper.updateMatrix(),this.lights.dirLightHelper.update())},dispose:async function(){return console.log(this.memory()),new Promise(l=>{l(this.clear(null,!0).then(_=>(this.map.remove(),this.map={},this.scene.remove(this.world),this.world.children=[],this.world=null,this.objectsCache.clear(),this.labelRenderer.dispose(),console.log(this.memory()),this.renderer.dispose(),_)))})},defaultLights:function(){this.lights.ambientLight=new Lt.AmbientLight(new Lt.Color("hsl(0, 0%, 100%)"),.75),this.scene.add(this.lights.ambientLight),this.lights.dirLightBack=new Lt.DirectionalLight(new Lt.Color("hsl(0, 0%, 100%)"),.25),this.lights.dirLightBack.position.set(30,100,100),this.scene.add(this.lights.dirLightBack),this.lights.dirLight=new Lt.DirectionalLight(new Lt.Color("hsl(0, 0%, 100%)"),.25),this.lights.dirLight.position.set(-30,100,-100),this.scene.add(this.lights.dirLight),this.repaint()},realSunlight:function(l=!1){this.renderer.shadowMap.enabled=!0,this.lights.dirLight=new Lt.DirectionalLight(16777215,1),this.scene.add(this.lights.dirLight),l&&(this.lights.dirLightHelper=new Lt.DirectionalLightHelper(this.lights.dirLight,5),this.scene.add(this.lights.dirLightHelper));let _=1e3,M=2,b=4096;this.lights.dirLight.castShadow=!0,this.lights.dirLight.shadow.radius=M,this.lights.dirLight.shadow.mapSize.width=b,this.lights.dirLight.shadow.mapSize.height=b,this.lights.dirLight.shadow.camera.top=this.lights.dirLight.shadow.camera.right=_,this.lights.dirLight.shadow.camera.bottom=this.lights.dirLight.shadow.camera.left=-_,this.lights.dirLight.shadow.camera.near=1,this.lights.dirLight.shadow.camera.visible=!0,this.lights.dirLight.shadow.camera.far=4e8,this.lights.hemiLight=new Lt.HemisphereLight(new Lt.Color(16777215),new Lt.Color(16777215),.6),this.lights.hemiLight.color.setHSL(.661,.96,.12),this.lights.hemiLight.groundColor.setHSL(.11,.96,.14),this.lights.hemiLight.position.set(0,0,50),this.scene.add(this.lights.hemiLight);let P=new Date(this.lightDateTime);P.setMilliseconds(P.getMilliseconds()+1),this.setSunlight(P),this.repaint()},setDefaultView:function(l,_){l.bbox=(l.bbox||l.bbox==null)&&_.enableSelectingObjects,l.tooltip=(l.tooltip||l.tooltip==null)&&_.enableTooltips,l.mapScale=this.map.transform.scale},memory:function(){return this.renderer.info.memory},programs:function(){return this.renderer.info.programs.length},version:"2.2.7"};var fg={defaultLights:!1,realSunlight:!1,realSunlightHelper:!1,passiveRendering:!0,preserveDrawingBuffer:!1,enableSelectingFeatures:!1,enableSelectingObjects:!1,enableDraggingObjects:!1,enableRotatingObjects:!1,enableTooltips:!1,enableHelpTooltips:!1,multiLayer:!1,orthographic:!1,fov:Ul.FOV_DEGREES,sky:!1,terrain:!1};Xd.exports=jd=Fs});var mg=Ht((Yd,Jd)=>{Jd.exports=Yd={Threebox:Zd(),THREE:mn()}});export default mg();
/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
